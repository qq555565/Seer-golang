# 野生精灵刷新逻辑说明

本文档说明 **lua的后台精灵刷新逻辑** 文件夹中野生精灵是如何实现刷新的，以及 Go 后端的对应实现与差异。

---

## 一、Lua 后端野生精灵刷新实现概览

### 1. 涉及文件

| 文件 | 作用 |
|------|------|
| `config/game_config.lua` | 地图野怪配置 `Config.MapOgres`（刷新间隔、闪光率、每张图的 `monsters` / 等级 / 权重） |
| `handlers/map_handlers.lua` | 进入地图时生成初始槽位 `getOgresForMap()`，写入 `user.mapOgreSlots`，发 CMD 2004 |
| `servers/gameserver/localgameserver.lua` | **核心**：定时器按间隔刷新精灵，更新 `playerOgreCache` 与 `user.mapOgreSlots`，并推送 CMD 2004 |
| `handlers/fight_handlers.lua` | 战斗/捕捉/逃跑时使用 `user.mapOgreSlots` 解析敌方精灵；结束后清空 `mapOgreSlots` |

### 2. 配置结构（game_config.lua）

```lua
Config.MapOgres = {
    RefreshInterval = 10,   -- 刷新间隔(秒)
    ShinyRate = 0.1,        -- 闪光概率
    ServerPushInterval = 1,  -- 定时器检查间隔(秒)
    EnterMapDelay = 5,      -- 进图后多久开始刷新
    FightEndDelay = 12,     -- 战斗结束后多久开始刷新
    NormalWeight = 90,      -- 普通精灵权重
    RareWeight = 0.35,      -- 稀有(#前缀)精灵权重
    Maps = {
        [地图ID] = {
            monsters = { "精灵名", "#闪光精灵名" }  -- 或 { name = "x", weight = 90 }
            levelMin, levelMax,
            petLevels = { ["精灵名"] = { min, max } },
            fixedDisplay = true/false,  -- 固定显示模式
        },
    },
}
```

- **# 前缀**：表示稀有/闪光配置，按 `RareWeight` 参与权重抽取。
- **fixedDisplay**：为 true 时，前几只精灵各占固定槽位，不按“消失一只、出现一只”动态轮换。

### 3. 进入地图时的流程（map_handlers.lua）

1. **handleEnterMap** 被调用（CMD 2001 进入地图）。
2. 调用 **getOgresForMap(mapId)** 生成当前地图槽位：
   - 若该地图有 `Config.MapOgres.Maps[mapId]`：
     - **fixedDisplay**：按配置的 `monsters` 顺序填满前几格，每格 `{ petId, shiny, level }`，闪光按 `shinyRate` 随机。
     - **非 fixedDisplay**：通过 **buildMonsterPool** 解析 `monsters`（支持 `"名"`、`#名`、`{ name, weight }`），再用 **generateSlotsFromPool** 按权重为槽位 0、1、2 各抽一只，得到 `{ petId, shiny }`（等级在战斗时按 petLevels/levelMin/Max 再算）。
   - 若无配置则走 LEGACY_MAP_OGRES 或返回空。
3. 将结果填满 0..8 槽位，空位填 `{0,0}`，写入 **user.mapOgreSlots**。
4. 同步到 **ctx.gameServer.playerOgreCache[userId][mapId]**（0..2 槽位，带 level），供定时器使用。
5. **先发一次“空精灵列表”的 CMD 2004**（9 个 0），等 **EnterMapDelay（5 秒）** 后由定时器再发“真实精灵”的 2004。

即：**进入地图时先给空列表，真实野生精灵由定时器在 5 秒后第一次刷新并推送。**

### 4. 定时刷新逻辑（localgameserver.lua）——野生精灵如何“刷新”

定时器每秒跑一次（ServerPushInterval），对每个在线玩家：

1. **条件检查**：
   - 正在战斗中 → 不刷新。
   - 刚结束战斗未满 **FightEndDelay（3 秒）** → 不刷新。
   - 进入地图未满 **EnterMapDelay（5 秒）** → 不刷新。
   - 距离上次刷新未满 **RefreshInterval（10 秒）** → 不刷新。

2. **数据来源**：  
   使用 **playerOgreCache[userId][mapId]**；若没有（例如战斗结束后被清空），则按当前地图配置重新初始化并生成一批精灵。

3. **fixedDisplay 地图**：  
   缓存已有固定槽位，定时器只负责把“当前缓存”再发一次 2004，不做了“消失/出现”的轮换。

4. **非 fixedDisplay 地图**——两种分支：
   - **当前 0..2 槽位全空**（例如刚战斗结束被清空）：
     - 按 `monsters` 权重（NormalWeight/RareWeight 或每条 weight）为槽位 0、1、2 **各独立抽一只**。
     - 每只再按 ShinyRate 决定是否闪光；`#名` 可强制闪光。
     - 写入 `playerOgreCache[userId][mapId]` 和 **user.mapOgreSlots**。
   - **当前已有精灵**：
     - **随机选一个槽位**，把该槽位置空（精灵“消失”）。
     - **再随机选一个空槽位**，按权重抽一只新精灵（同上），写入该槽（精灵“出现”）。
     - 再同步到 **user.mapOgreSlots**。

5. **推送**：  
   用当前 **playerOgreCache[userId][mapId]** 的 0..8 槽（每槽 petId）组包，发 **CMD 2004** 给该玩家。

总结：**野生精灵的“刷新”= 定时器每 10 秒（在满足进图/战毕延迟后）要么“三格全空则一次生成 3 只”，要么“随机一只消失 + 随机一只新出现”，并同步到 user.mapOgreSlots 和 2004 协议。**

### 5. 战斗侧如何使用（fight_handlers.lua）

- 客户端发 **CMD 2408**（FIGHT_NPC_MONSTER）时，参数为槽位索引 0~8 或直接为 petId。
- 服务端用 **user.mapOgreSlots[slotIndex]** 得到 `{ petId, shiny }`，再结合地图/精灵配置算等级，进入战斗。
- 战斗/捕捉/逃跑结束后，会**清空**该玩家 **user.mapOgreSlots**（部分多 BOSS 地图如 348 保留），下次定时器周期会按“全空”分支重新生成 3 只。

---

## 二、Go 后端对应实现（golang_version）

### 1. 涉及文件

| 文件 | 作用 |
|------|------|
| `internal/game/mapogres/mapogres.go` | 地图野怪配置（maps）、**GetSlots(mapID)**、10 秒缓存、雷伊/雷雨天等特殊逻辑 |
| `internal/handlers/handlers.go` | CMD 2004（handleMapOgreList）、CMD 2408（handleFightNpcMonster）、进入地图/战后推送 2004 |

### 2. 配置方式

- 在 **mapogres.go** 里用 `maps = map[int]mapConfig` 写死配置；每张图有 **Common / Rare / Monsters**、**Slots**、等级范围、RareInLast50Min、SPTBoss 等。
- **GetSlots(mapID)**：  
  - 若该地图有 Common/Rare：按“10 个蛋（8 普通 + 1 稀有 + 1 空）抽 3 个”的规则生成 3 只，再随机放进 4 个槽位（即 4 槽中 3 有怪 1 空）。  
  - 否则按 Monsters 列表随机填满 Slots（默认 9）格，等级默认 5。  
  - 结果带 **10 秒缓存**（mapSlotCache），同一地图在同一 10 秒内所有玩家拿到同一批槽位；缓存过期后重新随机。

### 3. 何时发 CMD 2004

- **进入地图**：`pushInitialMapEnter` → **buildMapOgreList(mapId)** → **GetSlots(mapId)**，立即发 2004（没有“先空列表再 5 秒后真列表”）。
- **客户端主动请求 2004**：handleMapOgreList 同样 **GetSlots(mapID)** 后发 2004。
- **战斗/捕捉/逃跑结束**：**pushMapOgreListAfterFightOver** 再调 **GetSlots(mapID)** 发一次 2004。
- **没有**类似 Lua 的“每 10 秒定时：一只消失、一只出现”的**持续刷新定时器**；刷新只发生在“再次调用 GetSlots”时（例如 10 秒后有人进图或请求 2004 时缓存过期）。

### 4. CMD 2408（野怪战斗）

- 客户端发槽位索引或 petId；Go 用 **mapogres.GetCachedSlots(mapID)** 取当前地图槽位（与 2004 一致），解析出 enemyID、level、shiny，进入战斗。
- 战斗结束后会 **InvalidateMap(mapID)** 清掉该地图缓存，下次 GetSlots 会重新随机。

### 5. 与 Lua 的差异小结

| 项目 | Lua | Go |
|------|-----|-----|
| 配置来源 | game_config.lua 的 Config.MapOgres.Maps | mapogres.go 内 maps |
| 槽位缓存 | 按玩家+地图 playerOgreCache[userId][mapId] | 按地图 mapSlotCache[mapID]，全服共享 |
| 进图 2004 | 先发空列表，5 秒后定时器发真实列表 | 进图即发 GetSlots 结果 |
| 持续刷新 | 有：每 10 秒“一只消失+一只出现”或“全空则生成 3 只” | 无定时刷新；仅 GetSlots 被调用时（含 10 秒缓存过期）更新 |
| 战斗结束 | 清空该玩家 mapOgreSlots，等定时器再填 | 清地图缓存并立即再发一次 2004（新 GetSlots） |
| 2004 body | Lua 中仅 9×uint32 petId（36 字节） | Go 中 9×(petId+shiny)=72 字节，需确认客户端是否兼容 |

---

## 三、Go 后端已实现的“与 Lua 一致”的定时刷新（已完成）

1. **每玩家每地图槽位**：`GameServer.OgreSlots[userId][mapID]` 存当前 4 槽；`OgreRefreshState[userId]` 存进图时间、战毕时间、上次刷新时间。
2. **进图**：`handleEnterMap` / `pushInitialMapEnter` 调用 `SetOgreEnterMapTime`，用 `mapogres.GenerateNewSlotsNoCache(mapID)` 生成槽位并 `SetPlayerOgreSlots`，再发 2004。
3. **定时刷新**：`runOgreRefreshLoop` 每秒执行 `TickOgreRefresh`：非战斗中、进图≥5 秒、战毕≥3 秒、距上次刷新≥10 秒时，**整批重新生成**该地图槽位（`mapogres.GenerateNewSlotsNoCache(mapID)`）并推送 2004（不再“每次只替换一个”）。
4. **战斗**：CMD 2408 优先用 `GetPlayerOgreSlots(userID, mapID)`，无则回退 `GetCachedSlots(mapID)`。战斗/捕捉/逃跑结束后 `pushMapOgreListAfterFightOver` 调用 `SetOgreFightEndTime`、`ClearPlayerOgreSlots`，发送空精灵列表 2004；3 秒后定时器会整批重新生成并推送。
5. **mapogres**：`GenerateNewSlotsNoCache(mapID)` 用于进图与定时整批刷新；`GenerateOneSlot(mapID)` 保留供单格逻辑使用。

协议 2004 包体为 72 字节（9×（petId+shiny）），与现有 `buildMapOgreList` 一致；客户端若只读前 36 字节也可兼容。
