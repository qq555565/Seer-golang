# 他人仍看不见飞行 — 排查与修复

改完 NonoManager、BasePeoleModel、PeopleActionEvent 后，同图另一客户端仍看不到对方飞行，按下面顺序排查。

**已做修改（NonoManager_改后全文.txt）**：  
1. **2112 常驻监听**：原先 2112 只在「自己点击飞行」时临时注册，**右侧客户端从未发送 2112，因此没有监听器，服务端广播的 2112 被忽略**。现已在 `getInstance()` 中为 `CommandID.ON_OR_OFF_FLYING` 注册**全局常驻监听**（仅注册一次），并去掉 `nonoFlyAction` 里的临时 add/remove，这样左侧开飞行时，右侧收到的广播 2112 也会被处理，从而刷新他人飞行 NONO。  
2. **2112「他人」分支**：若有 UserInfo 则更新其 actionType；若 `UserManager.getUserModel(uid)` 能取到他人模型则同步 `model.info.actionType`；**最后无论如何都会执行** `UserManager.dispatchAction(uid, PeopleActionEvent.FLY_MODE, {actionType})`。只要地图上已有该玩家的 BasePeoleModel，模型就会收到 FLY_MODE 并刷新飞行形态。  
若仍不显示，再按下面步骤排查。

---

## 0. 右侧仍看不见飞行时请先做这两处（缺一不可）

**① 2112 常驻监听（NonoManager）**  
- 若只有左侧能看到飞行、右侧完全看不到，多半是右侧从未注册 2112 监听（原逻辑只在「自己点击飞行」时临时注册，右侧没点飞行就不会注册，广播的 2112 被忽略）。  
- 已在 **NonoManager** 的 `getInstance()` 里为 2112 注册**常驻监听**（见 NonoManager_改后全文.txt），并去掉 `nonoFlyAction` 的临时 add/remove、`onFlyHandler` 里的 remove。  
- 务必保证在收到任何 2112 之前已调用过 `NonoManager.getInstance()`（进图或主界面初始化时调用一次），否则监听仍未挂上。

**② 2003 处理里补发 FLY_MODE（必做，否则对比后仍无变化）**  
- 右侧在进图或刷新时先收到 **2003**（地图玩家列表），再收 2112。2003 里已经带了别人的 actionType（如 4），但若 2003 处理里**只**写了 UserInfo、没有根据 actionType 触发一次「飞行状态同步」，则 BasePeoleModel 的 FLY_MODE 分支不会执行，他人 NONO 不会切到飞行形态，**对比后仍无变化**。  
- **必须在「处理 CMD 2003」的类里**，对每条 PeopleInfo 解析并更新/创建完该玩家后，若 `actionType != 0`，执行：  
  `UserManager.dispatchAction(userId, PeopleActionEvent.FLY_MODE, { actionType: actionType });`  
- 详细步骤与代码位置见：**docs/2003处理补发FLY_MODE_他人看见飞行.txt**。

---

## 1. 确认 2112 的「他人」分支真的在执行

- 在 **NonoManager.onFlyHandler** 的 `else` 里加一行临时 trace：  
  `trace("2112 other: uid=", _loc3_, " mode=", _loc4_);`  
  运行后让 A 开飞行，用 B 号看控制台是否出现该 trace。  
- 若**没有**：说明 2112 里走的仍是「自己」分支（例如 `MainManager.actorInfo.userID` 与包体里的 uid 比较方式不一致），要检查用的是 `MainManager.actorInfo.userID` 还是 `MainManager.actorID`，和包体前 4 字节一致。
- 若**有**：说明已进 else，继续下面步骤。

---

## 2. 确认 UserManager.getUser(他人 uid) 非 null

- 在 else 里 `var _loc5_:UserInfo = UserManager.getUser(_loc3_);` 后面加：  
  `trace("getUser(", _loc3_, ") = ", _loc5_);`  
- 若 **getUser 为 null**：说明「他人」的 UserInfo 不是用 `UserManager.getUser(uid)` 取的，或还没写入。  
  - 在工程里搜 **getUser**、**getUserModel**、**addUser**、**setUser**，看 2003 处理里是怎么把同图玩家放进 Manager 的（例如按 userId 存 map）。  
  - 2112 的 else 里要改成用**同一套存储**取「他人」的 UserInfo（例如 `UserManager.getUserByUserId(_loc3_)` 或从 2003 用的 map 里取）。  
- 若 **getUser 非 null**：再确认后面是否执行了 `UserManager.dispatchAction(_loc3_, PeopleActionEvent.FLY_MODE, {actionType:_loc4_});`（可再 trace 一次）。

---

## 3. 确认 PeopleActionEvent.FLY_MODE 存在且一致

- 在 **PeopleActionEvent** 里必须有：  
  `public static var FLY_MODE:String = "flyMode";`  
  （或你起的名字，但要和 dispatch 时用的完全一致。）
- 在 **BasePeoleModel.onAction** 里，`switch(param1.actionType)` 的 case 必须和上面常量一致，例如：  
  `case PeopleActionEvent.FLY_MODE:`  
- 若常量没加或拼写不一致，dispatch 了也不会进 case，他人模型不会刷新。

---

## 4. 确认 2003 会更新「已存在玩家」的 actionType 并触发刷新

- 日志里 2003 里已经带 **actionType=04**，若客户端**先处理 2003、再处理 2112**，理论上 2003 里就会把「他人」的 actionType 写成 4。
- 问题往往是：2003 只**写了 UserInfo.actionType**，没有触发该玩家 **BasePeoleModel** 的「根据 actionType 切飞行骨骼 / 换 NonoFlyModel」。
- 建议在 **处理 2003 的类**里（例如解析完一条 PeopleInfo、得到 userId 和 actionType 后）：
  - 若该 userId 已有 **BasePeoleModel**（例如已在地图上），则**补发一次「飞行状态同步」**：  
    `UserManager.dispatchAction(userId, PeopleActionEvent.FLY_MODE, { actionType: actionType });`  
  - 这样即使用户先收 2003 再收 2112，或只收 2003，他人模型也会按 actionType 刷新成飞行/落地。
- 若 2003 是「只追加新玩家、不更新已有玩家」，需要改成：对已存在的 userId 用 setForPeoleInfo 等更新其 UserInfo（含 actionType），再对已有模型 dispatch 上面这一句。

---

## 5. 确认 BasePeoleModel 的「walk」可写

- FLY_MODE 的 case 里有 `this.walk = new WalkAction()` / `new FlyAction(this)`。
- 若 **BobyModel** 或 **BasePeoleModel** 里没有 **set walk**，只读的 `walk` 会报错，整个 case 可能静默失败。
- 在 FFDec 里搜 **walk**、**set walk**、**_walk**，看父类/本类里是否有 setter；若没有，要改成项目里实际用来切换行走/飞行的方式（例如 setter 名不同，或通过别的方法设置 FlyAction）。

---

## 6. 建议的 2003 处「补刷新」写法（核心）

在 **2003 处理**里，**每处理完一条玩家**（已 setForPeoleInfo 或等效解析，并已创建/取得该玩家的 BasePeoleModel）后，加一段：

```actionscript
// 根据 actionType 触发飞行/落地表现，否则他人 NONO 不会切到飞行形态
if (actionType != 0)  // 或 info.actionType
{
   UserManager.dispatchAction(userId, PeopleActionEvent.FLY_MODE, { actionType: actionType });
}
```

（若 2003 里变量名是 `info`、`uid`，用 `info.userID`、`info.actionType` 等替换即可。）  
**不必**判断「模型是否已存在」：只要本条 2003 已解析并写入了该玩家的 UserInfo、模型会在 2003 流程里被创建或已存在，就应补发；这样 2003 先于 2112 到达时，右侧也能立刻显示他人飞行。  
完整步骤见 **docs/2003处理补发FLY_MODE_他人看见飞行.txt**。

---

## 7. 小结

| 现象 | 可能原因 | 处理 |
|------|----------|------|
| 2112 的 else 没执行 | uid 判断方式与包体不一致 | 统一用 MainManager.actorInfo.userID 与包体前 4 字节比较 |
| getUser(他人) 为 null | 他人 UserInfo 存在别处 | 用 2003 那套存储取 UserInfo，或先确保 2003 已执行 |
| dispatch 了仍不刷新 | 没加 FLY_MODE 常量或 case 不匹配 | 加常量并与 case 字符串一致 |
| 只收 2003 不刷新 | 2003 只写了 actionType，没触发模型 | 2003 里对已有模型 dispatch FLY_MODE |
| 报错 / 静默失败 | walk 无 setter 或类型不对 | 查 BobyModel/BasePeoleModel 里 walk 的实际写法 |

按 1→2→3→4→5 的顺序排查，一般能定位到是「取不到他人 UserInfo」「没进 FLY_MODE case」还是「2003 没触发刷新」中的哪一种，再按上表改即可。

---

## 8. NONO 已飞行、赛尔身体仍站立

若**他人**的 NONO 已显示飞行形态（翅膀/光晕），但**赛尔本人（机器人身体）仍站在地上**：

- **BasePeoleModel_改后全文.txt** 中已在 FLY_MODE 的「飞行」分支里增加：  
  `dispatchEvent(new RobotEvent(RobotEvent.WALK_START));`  
  这样在设置 `walk = new FlyAction(this)` 后，会触发 `onWalkStart` → `this._skeletonSys.play()`，部分项目里骨骼会根据当前 walk 类型切到飞行姿态。
- 若加上后身体仍不飞：
  - 让**对方先开飞行，再移动几步**，看是否在收到 2101 移动包后身体才切到飞行（说明 FlyAction 是在 `walk.execute` 时才改姿态）。
  - 在 FFDec 里打开 **FlyAction**、**EmptySkeletonStrategy**（或当前用的骨骼类），看是否有根据 `actionType` / 当前 walk 类型播放「飞行」动画或调整骨骼 pose 的逻辑；若有，确认他人收到 FLY_MODE 后 `this._info.actionType` 已为 4，且该逻辑对「他人」同样生效。
