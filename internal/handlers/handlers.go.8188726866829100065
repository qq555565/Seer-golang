package handlers

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"math"
	"math/rand"
	"strconv"
	"sync"
	"time"

	"github.com/seer-game/golang-version/internal/core/logger"
	"github.com/seer-game/golang-version/internal/core/packet"
	"github.com/seer-game/golang-version/internal/core/userdb"
	gamebattle "github.com/seer-game/golang-version/internal/game/battle"
	gameogres "github.com/seer-game/golang-version/internal/game/mapogres"
	gamepets "github.com/seer-game/golang-version/internal/game/pets"
	gameskills "github.com/seer-game/golang-version/internal/game/skills"
	"github.com/seer-game/golang-version/internal/game/sptboss"
	"github.com/seer-game/golang-version/internal/server/gameserver"
)

// BOSS 防护罩血量缓存：userID -> "mapID_region" -> 当前血量（0 表示满血/未初始化）
var (
	bossHpCache   = make(map[int64]map[string]int)
	bossHpCacheMu sync.RWMutex
)

// bossSkillOverrides 为特定 BOSS 设置固定技能列表（优先级高于按等级可学技能）
// 顺序即 UI 显示顺序，可按需要扩展
var bossSkillOverrides = map[int][]int{
	// 闪光波克尔（克洛斯星 Boss 及其变体 ID）：红韵、同生共死、魅惑、挥翼飘舞
	40:  {20210, 10036, 20209, 10486},
	63:  {20210, 10036, 20209, 10486},
	86:  {20210, 10036, 20209, 10486},
	166: {20210, 10036, 20209, 10486},
}

// bossHPOverrides 地图 BOSS 固定血量（仅用于 PVE 敌人，不影响玩家自己拥有的同名精灵）
// key 为精灵 ID，value 为战斗开始时的 MaxHP/HP。
var bossHPOverrides = map[int]int{
	47:  100,     // 蘑菇怪
	34:  200,     // 钢牙鲨
	42:  338,     // 里奥斯
	50:  1000,    // 阿克希亚
	69:  500,     // 提亚斯
	70:  800,     // 雷伊
	88:  1400,    // 纳多雷
	113: 1500,    // 雷纳多
	132: 2800,    // 尤纳斯
	187: 3000000, // 魔狮迪露
	216: 10000,   // 哈莫雷特
	264: 2500,    // 奈尼芬多
	421: 3000,    // 厄尔塞拉
	261: 2000,    // 盖亚
	274: 13000,   // 塔克林
	391: 10000,   // 塔西亚
}

// applyBossHPOverride 若为地图 BOSS，则返回指定的固定血量，否则返回原始值
func applyBossHPOverride(petID int, original int) int {
	if hp, ok := bossHPOverrides[petID]; ok && hp > 0 {
		return hp
	}
	return original
}

// getEnemySkillsForPet 返回敌方精灵的技能列表，若有覆盖则优先覆盖
func getEnemySkillsForPet(petID, level int) []int {
	if skills, ok := bossSkillOverrides[petID]; ok {
		return skills
	}
	petMgr := gamepets.GetInstance()
	return petMgr.GetSkillsForLevel(petID, level)
}

// pickEnemySkill 挑选敌方本回合要用的技能：
// - 优先从“有威力或非纯辅助”的技能中随机选择（包括 BOSS 自定义技能列表）
// - 若全是纯辅助技能，则随机选其中一个
// - 若仍没有可用技能，则返回 nil,0，表示本回合不出招
func pickEnemySkill(skillMgr *gameskills.Skills, petID, level int) (*gameskills.Skill, uint32) {
	skills := getEnemySkillsForPet(petID, level)
	var candidates []*gameskills.Skill
	var candidateIDs []uint32
	var fallback *gameskills.Skill
	var fallbackID uint32

	for _, sid := range skills {
		if sid <= 0 {
			continue
		}
		if sk := skillMgr.Get(sid); sk != nil {
			if sk.Power > 0 || sk.Category != 4 {
				// 具有攻击性的技能：加入候选池，后续随机挑选
				candidates = append(candidates, sk)
				candidateIDs = append(candidateIDs, uint32(sid))
			} else if fallback == nil {
				// 记录一个纯辅助技能作为兜底
				fallback = sk
				fallbackID = uint32(sid)
			}
		}
	}

	// 在候选攻击技能中随机挑选一个
	if len(candidates) > 0 {
		idx := rand.Intn(len(candidates))
		return candidates[idx], candidateIDs[idx]
	}

	// 没有攻击技能时，随机使用第一个找到的辅助技能
	if fallback != nil {
		return fallback, fallbackID
	}

	// 没有任何技能可用：本回合不出招
	return nil, 0
}

// RegisterHandlers 注册所有命令处理器
func RegisterHandlers(gs *gameserver.GameServer) {
	// 注册核心命令处理器
	registerCoreHandlers(gs)

	// 注册游戏逻辑命令处理器
	registerGameHandlers(gs)

	// 注册精灵相关命令处理器
	registerPetHandlers(gs)

	// 注册战斗相关命令处理器
	registerBattleHandlers(gs)

	// 注册未实现命令的空响应（对齐 Lua 服 CMD 列表，避免客户端触发“未实现的命令”）
	registerStubHandlers(gs)

	// 客户端断线时向同地图其他玩家广播更新后的 2003 列表
	gs.OnClientDisconnect = func(_ *gameserver.ClientData, mapID int) {
		body := buildMapPlayerListForMap(gs, mapID)
		gs.BroadcastToMap(mapID, 0, 2003, body)
		logger.Info(fmt.Sprintf("[2003] 用户离开地图后广播: MapID=%d", mapID))
	}
}

// registerCoreHandlers 注册核心命令处理器
func registerCoreHandlers(gs *gameserver.GameServer) {
	gs.RegisterCommandHandler(1001, handleLogin)
	gs.RegisterCommandHandler(1002, handleSystemTime)
	// 登录后初始化阶段常见请求（对齐 Lua 服，避免客户端 Bean/模块卡死）
	gs.RegisterCommandHandler(2150, handleGetRelationList)  // 好友/黑名单
	gs.RegisterCommandHandler(2151, handleFriendAdd)        // 添加好友
	gs.RegisterCommandHandler(2152, handleFriendAnswer)     // 好友请求回复
	gs.RegisterCommandHandler(2153, handleFriendRemove)     // 删除好友
	gs.RegisterCommandHandler(2154, handleBlackAdd)         // 添加黑名单
	gs.RegisterCommandHandler(2155, handleBlackRemove)      // 移除黑名单
	gs.RegisterCommandHandler(2157, handleSeeOnline)        // 查看在线状态
	gs.RegisterCommandHandler(2158, handleRequestOut)       // 发送请求
	gs.RegisterCommandHandler(2159, handleRequestAnswer)    // 请求回复
	gs.RegisterCommandHandler(2751, handleMailGetList)      // 邮件列表
	gs.RegisterCommandHandler(2757, handleMailGetUnread)    // 未读邮件
	gs.RegisterCommandHandler(50004, handleXinCheck)        // 客户端上报
	gs.RegisterCommandHandler(50008, handleXinGetQuadTime)  // 四倍经验时间
	gs.RegisterCommandHandler(70001, handleGetExchangeInfo) // 荣誉/交换
	gs.RegisterCommandHandler(1106, handleGoldOnlineCheckRemain)
	gs.RegisterCommandHandler(1104, handleGoldBuyProduct)   // 金豆购买商品
	gs.RegisterCommandHandler(1101, handleMoneyCheckPsw)    // 米币支付密码检查（返回1则客户端继续购买流程）
	gs.RegisterCommandHandler(1103, handleMoneyCheckRemain) // 米币余额检查
	gs.RegisterCommandHandler(80008, handleHeartbeat)
	gs.RegisterCommandHandler(2701, handleTalkCount)       // 对话计数（物品领取）
	gs.RegisterCommandHandler(2702, handleTalkCate)        // 对话分类（发放领取物品）
	gs.RegisterCommandHandler(10006, handleFitmentUsering) // 正在使用的家具（基地）
	// 系统/支付 完整协议
	gs.RegisterCommandHandler(1005, handleGetImageAddress)
	gs.RegisterCommandHandler(1102, handleMoneyBuyProduct)
	gs.RegisterCommandHandler(1105, handleGoldCheckRemain)
	// 协议层/校验 完整协议
	gs.RegisterCommandHandler(1022, handleCheckFightCode)
	gs.RegisterCommandHandler(8002, handleSystemMessage)
	gs.RegisterCommandHandler(9049, handleOpenBagGet)
	gs.RegisterCommandHandler(11003, handleGetPetInfoAlt)
	gs.RegisterCommandHandler(11007, handleGetPetByCatchTime)
	gs.RegisterCommandHandler(11022, handleGetSecondBag)
	gs.RegisterCommandHandler(41983, handleReconnect)
	gs.RegisterCommandHandler(46046, handleGetMultiForever)
	gs.RegisterCommandHandler(40001, handleGetSuperValue)
	gs.RegisterCommandHandler(40002, handleGetSuperValueByIds)
	gs.RegisterCommandHandler(42023, handleBatchGetBitset)
	gs.RegisterCommandHandler(46057, handleGetMultiForeverByDb)
	gs.RegisterCommandHandler(41080, handleGetForeverValue)
	gs.RegisterCommandHandler(47334, handleFriendListAlt)
	gs.RegisterCommandHandler(47335, handleBlacklistAlt)
	gs.RegisterCommandHandler(10301, handleSystemTimeAlt)
	gs.RegisterCommandHandler(4475, handleItemListAlt)
	gs.RegisterCommandHandler(8001, handleInform)
	gs.RegisterCommandHandler(8004, handleGetBossMonster)
	// 成就/称号 协议（3403 ACHIEVETITLELIST 等，3404 SETTITLE 单独实现）
	gs.RegisterCommandHandler(3404, handleSetTitle)

	// 注册NONO系统命令处理器
	registerNonoHandlers(gs)
}

// registerGameHandlers 注册游戏逻辑命令处理器
func registerGameHandlers(gs *gameserver.GameServer) {
	// 注册地图相关命令处理器
	gs.RegisterCommandHandler(2001, handleEnterMap)
	gs.RegisterCommandHandler(2002, handleLeaveMap)
	gs.RegisterCommandHandler(2003, handleListMapPlayer)
	gs.RegisterCommandHandler(1004, handleMapHot) // 地图热点（宇宙地图热点数据）
	gs.RegisterCommandHandler(2004, handleMapOgreList)
	gs.RegisterCommandHandler(2401, handleInviteToFight)     // 邀请玩家对战（转发 2501 给被邀请方）
	gs.RegisterCommandHandler(2403, handleHandleFightInvite) // 接受/拒绝对战邀请（转发 2502 给邀请方）
	gs.RegisterCommandHandler(2408, handleFightNpcMonster)   // 地图野怪战斗
	gs.RegisterCommandHandler(2412, handleAttackBoss)        // 攻击 SPT BOSS（破除防护罩）
	gs.RegisterCommandHandler(2051, handleGetSimUserInfo)    // 获取简单用户信息
	gs.RegisterCommandHandler(2052, handleGetMoreUserInfo)   // 获取详细用户信息
	gs.RegisterCommandHandler(2101, handlePeopleWalk)        // 人物移动
	gs.RegisterCommandHandler(2102, handleChat)              // 聊天
	gs.RegisterCommandHandler(2104, handleAimat)             // 射击/瞄准（AIMAT）
	gs.RegisterCommandHandler(2107, handleTransformUser)     // 射击命中后变身（TRANSFORM_USER），广播 2108 给同图
	// 地图/玩家 完整协议
	gs.RegisterCommandHandler(2061, handleChangeNickName)
	gs.RegisterCommandHandler(2063, handleChangeColor)
	gs.RegisterCommandHandler(2103, handleDanceAction)
	gs.RegisterCommandHandler(2111, handlePeopleTransform)
	gs.RegisterCommandHandler(2112, handleOnOrOffFlying)

	// 精灵相关（部分，只实现新手流程必需）
	gs.RegisterCommandHandler(2301, handleGetPetInfo)
	// 2302 = MODIFY_PET_NAME（修改精灵名字），由 stub 处理；2308 = PET_DEFAULT（设为首发）
	gs.RegisterCommandHandler(2303, handleGetPetList) // 获取精灵列表（切换精灵时需要）

	// 任务 / 新手奖励相关（2201/2202/2203）、每日任务（2231/2232/2233）、魂珠列表（2354）
	gs.RegisterCommandHandler(2201, handleAcceptTask)
	gs.RegisterCommandHandler(2202, handleCompleteTask)
	gs.RegisterCommandHandler(2203, handleGetTaskBuf)        // 获取任务进度（GET_TASK_BUF），地图装置等依赖此接口
	gs.RegisterCommandHandler(2231, handleAcceptDailyTask)   // 接受每日任务
	gs.RegisterCommandHandler(2232, handleDeleteDailyTask)   // 放弃每日任务
	gs.RegisterCommandHandler(2233, handleCompleteDailyTask) // 完成每日任务（响应格式同 2202 NoviceFinishInfo）
	gs.RegisterCommandHandler(2354, handleGetSoulBeadList)
	gs.RegisterCommandHandler(2204, handleAddTaskBuf)
	gs.RegisterCommandHandler(2234, handleGetDailyTaskBuf)
	gs.RegisterCommandHandler(2235, handleStub4Zero) // ADD_DAILY_TASK_BUF，与 Lua emptyResponse(4) 一致，暂不持久化每日任务 buf
	gs.RegisterCommandHandler(2065, handleExchangeNewYear)
	gs.RegisterCommandHandler(2251, handleExchangeOre)
	gs.RegisterCommandHandler(2902, handleExchangePetComplete)

	// 背包/物品系统
	registerItemHandlers(gs)

	// 新手战斗触发：2411 -> 回推 2503
	gs.RegisterCommandHandler(2411, handleChallengeBoss)

	// 战斗初始化：2404 READY_TO_FIGHT
	gs.RegisterCommandHandler(2404, handleReadyToFight)
}

// registerPetHandlers 注册精灵相关命令处理器
func registerPetHandlers(gs *gameserver.GameServer) {
	gs.RegisterCommandHandler(2304, handlePetRelease)                   // 精灵仓库互转
	gs.RegisterCommandHandler(2305, handlePetShow)                      // 展示精灵（跟随面板）
	gs.RegisterCommandHandler(2308, handleSetDefaultPet)                // 设为首发精灵（客户端 PET_DEFAULT）
	gs.RegisterCommandHandler(2319, handlePetGetExp)                    // 获取经验池经验
	gs.RegisterCommandHandler(2318, handlePetSetExp)                    // 从经验池分配经验给精灵
	gs.RegisterCommandHandler(3007, handleExperienceSharedComplete)     // 发明室经验接收器：领取并平均分配给背包精灵
	gs.RegisterCommandHandler(3009, handleMyExperiencePondComplete)     // 发明室经验接收器：查询教官积累经验值
	gs.RegisterCommandHandler(3011, handleGetMyExperienceComplete)      // 发明室经验接收器：教官查看未领取经验
	gs.RegisterCommandHandler(2325, handlePetRoomInfo)                  // 精灵房间信息（简略面板）
	gs.RegisterCommandHandler(2312, handlePetSkillSwitch)               // 精灵技能切换（技能唤醒仪替换技能）
	gs.RegisterCommandHandler(2336, handleGetPetSkill)                  // 获取精灵技能（技能唤醒仪）
	gs.RegisterCommandHandler(2326, handleUsePetItemOutOfFight)         // 战斗外使用精灵道具（学习力清零/等）
	gs.RegisterCommandHandler(9278, handleUsePetItemFullAbilityOfStudy) // 学习力注入（单项拉满）
}

// registerBattleHandlers 注册战斗相关命令处理器
func registerBattleHandlers(gs *gameserver.GameServer) {
	gs.RegisterCommandHandler(2405, handleUseSkill)     // 使用技能
	gs.RegisterCommandHandler(2406, handleUsePetItem)   // 使用道具
	gs.RegisterCommandHandler(2407, handleChangePet)    // 切换精灵
	gs.RegisterCommandHandler(2409, handleCatchMonster) // 捕捉精灵
	gs.RegisterCommandHandler(2410, handleEscapeFight)  // 逃跑
}

// registerStubHandlers 注册尚未实现完整协议的 CMD：按 Lua 响应格式区分 4 字节 0 / 8 字节 0 / 空包
func registerStubHandlers(gs *gameserver.GameServer) {
	// 扭蛋机：3201 精灵扭蛋机、9757 梦幻扭蛋机 已单独实现
	gs.RegisterCommandHandler(3201, handleGacha)
	gs.RegisterCommandHandler(9757, handleGacha)
	// Lua 返回 writeUInt32BE(0) 的 CMD，响应 4 字节 0
	stub4Zero := []int32{
		5001, 5002, 2442, 2444, 2445, 2446,
		// 用户信息相关 (2051/2052 已实现)：2053 REQUEST_COUNT, 2054 GP_GHAZI_MAX_LEVEL, 2055 USER_PARTY_GET_USER_IMAGE_NAME
		2053, 2054, 2055,
		2302, 2306, 2307, 2309, 2310, 2311, 2313, 2314, 2315, 2316,
		2320, 2321, 2322, 2323, 2324, 2327, 2328, 2329, 2330, 2331, 2332,
		2343, 2351, 2352, 2353, 2356, 2357, 2358, 2393,
		// 成就/称号 (ACHIEVELIST/ACHIEVEINFO/ACHIEVETITLELIST/SETTITLE/CONFERACHIEVEMENT/ACHIEVE_AND_TITLE)，3404 单独实现，3405 在 stubEmpty
		3401, 3402, 3403, 3406, 3407,
		2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2428, 2429, 2430,
		2910, 2911, 2912, 2913, 2914, 2917, 2918, 2928, 2929, 2962, 2963,
		3001, 3002, 3003, 3004, 3005, 3006, 3008, 3010,
		4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014,
		4017, 4018, 4019, 4020, 4022, 4023, 4024, 4025, 4101, 4102, 2481,
		10001, 10002, 10003, 10004, 10005, 10007, 10008, 10009,
		// 2151-2159 好友协议已实现完整处理，不再使用 stub4Zero
	}
	for _, cmd := range stub4Zero {
		gs.RegisterCommandHandler(cmd, handleStub4Zero)
	}
	// Lua 返回 ret(4)+count(4) 等 8 字节的 CMD
	gs.RegisterCommandHandler(5052, handleStub8Zero)
	// Lua 返回空或客户端不依赖包体的 CMD（含 gamepktprotocol.lua emptyCmds 中未单独实现的 CMD，9003/2354 已实现故不在此列）
	stubEmpty := []int32{
		5003, // LEAVE_GAME
		1011, 1016, 2289, 2192, 2196, 2361, 3405, 4359, 4364, 4501, 5005,
		9112, 9677, 41006, 41249, 41253, 4148, 4178, 4181, 43706, 45512, 45524,
		45773, 45793, 45798, 45824, 47309, 45071,
		40006, 40007,
	}
	// 注：2313 已在 stub4Zero（精灵 IS_COLLECT），9003/2354 已有完整实现，故不放入 stubEmpty
	for _, cmd := range stubEmpty {
		gs.RegisterCommandHandler(cmd, handleStubEmpty)
	}
}

// handleSystemTime CMD 1002 系统时间，对齐 Lua system_handlers.handleSystemTime
func handleSystemTime(ctx *gameserver.HandlerContext) {
	buf := make([]byte, 8)
	t := uint32(time.Now().Unix())
	binary.BigEndian.PutUint32(buf[0:4], t)
	binary.BigEndian.PutUint32(buf[4:8], 0)
	ctx.GameServer.SendResponse(ctx.ClientData, 1002, ctx.UserID, ctx.SeqID, buf)
}

// handleStubEmpty 未实现命令的空响应（返回 result=0 空包，避免客户端报“未实现的命令”）
func handleStubEmpty(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, []byte{})
}

// handleStub4Zero 返回 4 字节 0 的协议体（对齐 Lua writeUInt32BE(0)）
func handleStub4Zero(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, body)
}

// handleStub8Zero 返回 8 字节 0（对齐 Lua ret(4)+count(4) 等）
func handleStub8Zero(ctx *gameserver.HandlerContext) {
	body := make([]byte, 8)
	ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, body)
}

// putFixedString 将字符串写入固定长度（不足补0）
func putFixedString(buf []byte, off int, s string, n int) {
	b := []byte(s)
	if len(b) > n {
		b = b[:n]
	}
	copy(buf[off:], b)
	for i := len(b); i < n; i++ {
		buf[off+i] = 0
	}
}

// ==================== 系统/支付 完整协议 ====================

// handleGetImageAddress CMD 1005 GET_IMAGE_ADDRESS
// 响应: host(16) + port(2) + session(16)，对齐 Lua system_handlers.handleGetImageAddress
func handleGetImageAddress(ctx *gameserver.HandlerContext) {
	body := make([]byte, 16+2+16)
	putFixedString(body, 0, "127.0.0.1", 16)
	binary.BigEndian.PutUint16(body[16:18], 80)
	putFixedString(body, 18, "", 16)
	ctx.GameServer.SendResponse(ctx.ClientData, 1005, ctx.UserID, ctx.SeqID, body)
}

// handleMoneyBuyProduct CMD 1102 MONEY_BUY_PRODUCT
// 请求: productId(4) + count(2)。响应: unknown(4) + payMoney(4) + remain(4)，对齐 Lua
func handleMoneyBuyProduct(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	payMoney := uint32(0)
	remain := uint32(user.Gold * 100)
	if len(ctx.Body) >= 6 {
		_ = binary.BigEndian.Uint32(ctx.Body[0:4])
		_ = binary.BigEndian.Uint16(ctx.Body[4:6])
	}
	body := make([]byte, 12)
	binary.BigEndian.PutUint32(body[0:4], 0)
	binary.BigEndian.PutUint32(body[4:8], payMoney)
	binary.BigEndian.PutUint32(body[8:12], remain)
	ctx.GameServer.SendResponse(ctx.ClientData, 1102, ctx.UserID, ctx.SeqID, body)
}

// handleGoldCheckRemain CMD 1105 GOLD_CHECK_REMAIN
// 响应: (gold*100)(4)，对齐 Lua
func handleGoldCheckRemain(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body, uint32(user.Gold*100))
	ctx.GameServer.SendResponse(ctx.ClientData, 1105, ctx.UserID, ctx.SeqID, body)
}

// ==================== 协议层/校验 完整协议 ====================

// handleCheckFightCode CMD 1022 验证战斗码，响应空包
func handleCheckFightCode(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, 1022, ctx.UserID, ctx.SeqID, []byte{})
}

// handleSystemMessage CMD 8002 系统消息（客户端发，服回空）
func handleSystemMessage(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, 8002, ctx.UserID, ctx.SeqID, []byte{})
}

// handleOpenBagGet CMD 9049 响应: count(4)=0 + extra(4)=0
func handleOpenBagGet(ctx *gameserver.HandlerContext) {
	body := make([]byte, 8)
	ctx.GameServer.SendResponse(ctx.ClientData, 9049, ctx.UserID, ctx.SeqID, body)
}

// handleGetPetInfoAlt CMD 11003 另一套编号的 GET_PET_INFO，响应: petCount(4)=0
func handleGetPetInfoAlt(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, 11003, ctx.UserID, ctx.SeqID, body)
}

// handleGetPetByCatchTime CMD 11007 响应空包
func handleGetPetByCatchTime(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, 11007, ctx.UserID, ctx.SeqID, []byte{})
}

// handleGetSecondBag CMD 11022 响应: count(4)=0
func handleGetSecondBag(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, 11022, ctx.UserID, ctx.SeqID, body)
}

// handleReconnect CMD 41983 RECONNECT 响应空包
func handleReconnect(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, 41983, ctx.UserID, ctx.SeqID, []byte{})
}

// handleGetMultiForever CMD 46046 响应: count(4)=5 + 5*uint32(0)=20 共24字节
func handleGetMultiForever(ctx *gameserver.HandlerContext) {
	body := make([]byte, 24)
	binary.BigEndian.PutUint32(body[0:4], 5)
	ctx.GameServer.SendResponse(ctx.ClientData, 46046, ctx.UserID, ctx.SeqID, body)
}

// handleGetSuperValue CMD 40001 响应: count(4)=0
func handleGetSuperValue(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, 40001, ctx.UserID, ctx.SeqID, body)
}

// handleGetSuperValueByIds CMD 40002 响应: count(4)=0
func handleGetSuperValueByIds(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, 40002, ctx.UserID, ctx.SeqID, body)
}

// handleBatchGetBitset CMD 42023 响应: count(4)=0
func handleBatchGetBitset(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, 42023, ctx.UserID, ctx.SeqID, body)
}

// handleGetMultiForeverByDb CMD 46057 响应: count(4)=0
func handleGetMultiForeverByDb(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, 46057, ctx.UserID, ctx.SeqID, body)
}

// handleGetForeverValue CMD 41080 响应: 4 字节 0
func handleGetForeverValue(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, 41080, ctx.UserID, ctx.SeqID, body)
}

// handleFriendListAlt CMD 47334 好友列表另一套编号，响应: count(4)=0
func handleFriendListAlt(ctx *gameserver.HandlerContext) {
	var friends []userdb.Friend
	if ctx.GameServer.UserDB != nil {
		friends = ctx.GameServer.UserDB.GetFriends(ctx.UserID)
	} else {
		user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
		friends = user.Friends
	}
	body := make([]byte, 0, 4+len(friends)*8)
	tmp := make([]byte, 4)
	binary.BigEndian.PutUint32(tmp, uint32(len(friends)))
	body = append(body, tmp...)
	for _, f := range friends {
		binary.BigEndian.PutUint32(tmp, uint32(f.UserID))
		body = append(body, tmp...)
		binary.BigEndian.PutUint32(tmp, uint32(f.TimePoke))
		body = append(body, tmp...)
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 47334, ctx.UserID, ctx.SeqID, body)
}

// handleBlacklistAlt CMD 47335 黑名单另一套编号，响应: blackCount(4) + [userId(4)]*n
func handleBlacklistAlt(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	body := make([]byte, 0, 4+len(user.Blacklist)*4)
	tmp := make([]byte, 4)
	binary.BigEndian.PutUint32(tmp, uint32(len(user.Blacklist)))
	body = append(body, tmp...)
	for _, b := range user.Blacklist {
		binary.BigEndian.PutUint32(tmp, uint32(b.UserID))
		body = append(body, tmp...)
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 47335, ctx.UserID, ctx.SeqID, body)
}

// handleSystemTimeAlt CMD 10301 系统时间另一套编号，响应同 1002: time(4)+4
func handleSystemTimeAlt(ctx *gameserver.HandlerContext) {
	body := make([]byte, 8)
	binary.BigEndian.PutUint32(body[0:4], uint32(time.Now().Unix()))
	ctx.GameServer.SendResponse(ctx.ClientData, 10301, ctx.UserID, ctx.SeqID, body)
}

// handleItemListAlt CMD 4475 物品列表另一套编号，响应: itemCount(4)=0 + updateTime(4)=0
func handleItemListAlt(ctx *gameserver.HandlerContext) {
	body := make([]byte, 8)
	ctx.GameServer.SendResponse(ctx.ClientData, 4475, ctx.UserID, ctx.SeqID, body)
}

// ==================== 地图/玩家 完整协议 ====================

// handleChangeNickName CMD 2061 修改昵称
// 请求: newNick(16)。响应: userId(4)+newNick(16)，对齐 Lua map_handlers.handleChangeNickName
func handleChangeNickName(ctx *gameserver.HandlerContext) {
	newNick := ""
	if len(ctx.Body) >= 16 {
		newNick = string(bytes.TrimRight(ctx.Body[0:16], "\x00"))
	}
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	user.Nick = newNick
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	body := make([]byte, 4+16)
	binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
	putFixedString(body, 4, newNick, 16)
	ctx.GameServer.SendResponse(ctx.ClientData, 2061, ctx.UserID, ctx.SeqID, body)
}

// handleChangeColor CMD 2063 修改颜色
// 请求: newColor(4)。响应: userId(4)+newColor(4)+cost(4)+remain(4)，对齐 Lua
func handleChangeColor(ctx *gameserver.HandlerContext) {
	newColor := uint32(0)
	if len(ctx.Body) >= 4 {
		newColor = binary.BigEndian.Uint32(ctx.Body[0:4])
	}
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	user.Color = int(newColor)
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	body := make([]byte, 16)
	binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
	binary.BigEndian.PutUint32(body[4:8], newColor)
	binary.BigEndian.PutUint32(body[8:12], 0)
	binary.BigEndian.PutUint32(body[12:16], uint32(user.Coins))
	ctx.GameServer.SendResponse(ctx.ClientData, 2063, ctx.UserID, ctx.SeqID, body)
}

// handleDanceAction CMD 2103 跳舞动作
// 请求: aid(4)+atype(4)。响应: userId(4)+aid(4)+atype(4)，对齐 Lua
func handleDanceAction(ctx *gameserver.HandlerContext) {
	aid, atype := uint32(0), uint32(0)
	if len(ctx.Body) >= 8 {
		aid = binary.BigEndian.Uint32(ctx.Body[0:4])
		atype = binary.BigEndian.Uint32(ctx.Body[4:8])
	}
	body := make([]byte, 12)
	binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
	binary.BigEndian.PutUint32(body[4:8], aid)
	binary.BigEndian.PutUint32(body[8:12], atype)
	ctx.GameServer.SendResponse(ctx.ClientData, 2103, ctx.UserID, ctx.SeqID, body)
}

// handlePeopleTransform CMD 2111 变身
// 请求: transId(4)。响应: userId(4)+transId(4)，对齐 Lua；并广播给同地图其他玩家
func handlePeopleTransform(ctx *gameserver.HandlerContext) {
	transId := uint32(0)
	if len(ctx.Body) >= 4 {
		transId = binary.BigEndian.Uint32(ctx.Body[0:4])
	}
	body := make([]byte, 8)
	binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
	binary.BigEndian.PutUint32(body[4:8], transId)
	ctx.GameServer.SendResponse(ctx.ClientData, 2111, ctx.UserID, ctx.SeqID, body)
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.MapID > 0 {
		ctx.GameServer.BroadcastToMap(user.MapID, ctx.UserID, 2111, body)
	}
}

// handleOnOrOffFlying CMD 2112 飞行开关
// 请求: flyMode(4)。响应: userId(4)+flyMode(4)，对齐 Lua；并广播给同地图其他玩家
func handleOnOrOffFlying(ctx *gameserver.HandlerContext) {
	flyMode := uint32(0)
	if len(ctx.Body) >= 4 {
		flyMode = binary.BigEndian.Uint32(ctx.Body[0:4])
	}
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	body := make([]byte, 8)
	binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
	binary.BigEndian.PutUint32(body[4:8], flyMode)
	ctx.GameServer.SendResponse(ctx.ClientData, 2112, ctx.UserID, ctx.SeqID, body)
	if user.MapID > 0 {
		ctx.GameServer.BroadcastToMap(user.MapID, ctx.UserID, 2112, body)
	}
}

// ==================== 交换 完整协议 ====================

// handleExchangeNewYear CMD 2065 新年交换，响应: 4 字节 0
func handleExchangeNewYear(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, 2065, ctx.UserID, ctx.SeqID, body)
}

// handleExchangeOre CMD 2251 矿石交换，响应: ret(4)=0 + count(4)=0
func handleExchangeOre(ctx *gameserver.HandlerContext) {
	body := make([]byte, 8)
	ctx.GameServer.SendResponse(ctx.ClientData, 2251, ctx.UserID, ctx.SeqID, body)
}

// handleExchangePetComplete CMD 2902 精灵交换完成，响应: 4 字节 0
func handleExchangePetComplete(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, 2902, ctx.UserID, ctx.SeqID, body)
}

// ==================== 任务 完整协议 ====================

// handleAddTaskBuf CMD 2204 添加/更新任务缓存（NPC 对话进度等）
// 请求（前端）: taskId(4) + buf(20 字节)，SetTaskBuf/TasksManager 为 writeUnsignedInt(taskId)+writeBytes(ByteArray(20))
// 兼容旧格式: taskId(4) + index(1) + value(4)。响应: 4 字节 0
func handleAddTaskBuf(ctx *gameserver.HandlerContext) {
	if len(ctx.Body) >= 4 {
		taskID := binary.BigEndian.Uint32(ctx.Body[0:4])
		user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
		if user.Tasks == nil {
			user.Tasks = make(map[string]userdb.Task)
		}
		key := strconv.FormatUint(uint64(taskID), 10)
		t := user.Tasks[key]
		if t.Buf == nil {
			t.Buf = make(map[int]int)
		}
		if len(ctx.Body) >= 24 {
			for i := 0; i < 20; i++ {
				t.Buf[i] = int(ctx.Body[4+i])
			}
		} else if len(ctx.Body) >= 5 {
			index := int(ctx.Body[4])
			value := 0
			if len(ctx.Body) >= 9 {
				value = int(binary.BigEndian.Uint32(ctx.Body[5:9]))
			}
			t.Buf[index] = value
		}
		user.Tasks[key] = t
		if ctx.GameServer.UserDB != nil {
			ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
		}
	}
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, 2204, ctx.UserID, ctx.SeqID, body)
}

// handleGetDailyTaskBuf CMD 2234 获取每日任务缓存，响应: 8 字节 (0,0)，对齐 Lua task_handlers
func handleGetDailyTaskBuf(ctx *gameserver.HandlerContext) {
	body := make([]byte, 8)
	ctx.GameServer.SendResponse(ctx.ClientData, 2234, ctx.UserID, ctx.SeqID, body)
}

// handleInform CMD 8001 通知，响应: type(4)+userID(4)+nick(16)+accept(4)+serverID(4)+mapType(4)+mapID(4)+mapName(64)=104 字节
func handleInform(ctx *gameserver.HandlerContext) {
	body := make([]byte, 104)
	binary.BigEndian.PutUint32(body[0:4], 0)
	binary.BigEndian.PutUint32(body[4:8], uint32(ctx.UserID))
	putFixedString(body, 8, "", 16)
	binary.BigEndian.PutUint32(body[24:28], 0)
	binary.BigEndian.PutUint32(body[28:32], 1)
	binary.BigEndian.PutUint32(body[32:36], 0)
	binary.BigEndian.PutUint32(body[36:40], 301)
	putFixedString(body, 40, "", 64)
	ctx.GameServer.SendResponse(ctx.ClientData, 8001, ctx.UserID, ctx.SeqID, body)
}

// handleGetBossMonster CMD 8004 获取 BOSS 怪物，响应: bonusID(4)+petID(4)+captureTm(4)+itemCount(4)=16 字节
func handleGetBossMonster(ctx *gameserver.HandlerContext) {
	body := make([]byte, 16)
	ctx.GameServer.SendResponse(ctx.ClientData, 8004, ctx.UserID, ctx.SeqID, body)
}

// handleSetTitle CMD 3404 SETTITLE 设置当前称号
// 请求: titleId(4)。响应: 4 字节 0 表示成功。对齐 seer_cmdlist ACHIEVETITLELIST(3403)/SETTITLE(3404)
func handleSetTitle(ctx *gameserver.HandlerContext) {
	titleID := 0
	if len(ctx.Body) >= 4 {
		titleID = int(binary.BigEndian.Uint32(ctx.Body[0:4]))
	}
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	user.CurTitle = titleID
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, 3404, ctx.UserID, ctx.SeqID, body)
}

// handleMailGetList CMD 2751 获取邮件列表（空列表）
// 对齐 Lua: mail_handlers.handleMailGetList
func handleMailGetList(ctx *gameserver.HandlerContext) {
	body := make([]byte, 8)
	// total=0, count=0
	ctx.GameServer.SendResponse(ctx.ClientData, 2751, ctx.UserID, ctx.SeqID, body)
}

// handleMailGetUnread CMD 2757 获取未读邮件数（0）
// 对齐 Lua: mail_handlers.handleMailGetUnread
func handleMailGetUnread(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	// unread=0
	ctx.GameServer.SendResponse(ctx.ClientData, 2757, ctx.UserID, ctx.SeqID, body)
}

// handleGetRelationList CMD 2150 获取好友/黑名单列表
// 对齐 Lua: friend_handlers.handleGetRelationList
func handleGetRelationList(ctx *gameserver.HandlerContext) {
	// 从数据库加载最新的好友和黑名单列表（确保数据最新）
	var friends []userdb.Friend
	var black []userdb.BlacklistEntry
	if ctx.GameServer.UserDB != nil {
		friends = ctx.GameServer.UserDB.GetFriends(ctx.UserID)
		black = ctx.GameServer.UserDB.GetBlacklist(ctx.UserID)
		// 更新内存中的用户数据
		user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
		user.Friends = friends
		user.Blacklist = black
	} else {
		user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
		friends = user.Friends
		black = user.Blacklist
	}

	// friendCount(4) + blackCount(4) + [FriendInfo]*n + [BlackInfo]*m
	body := make([]byte, 0, 8+len(friends)*8+len(black)*4)
	tmp := make([]byte, 4)
	binary.BigEndian.PutUint32(tmp, uint32(len(friends)))
	body = append(body, tmp...)
	binary.BigEndian.PutUint32(tmp, uint32(len(black)))
	body = append(body, tmp...)

	for _, f := range friends {
		binary.BigEndian.PutUint32(tmp, uint32(f.UserID))
		body = append(body, tmp...)
		binary.BigEndian.PutUint32(tmp, uint32(f.TimePoke))
		body = append(body, tmp...)
	}
	for _, b := range black {
		binary.BigEndian.PutUint32(tmp, uint32(b.UserID))
		body = append(body, tmp...)
	}

	ctx.GameServer.SendResponse(ctx.ClientData, 2150, ctx.UserID, ctx.SeqID, body)
}

// handleFriendAdd CMD 2151 发送好友请求（需要对方同意）
// 请求: friendID(4)
// 响应: friendID(4) - 返回请求的好友ID
// 同时向对方推送 8001 (INFORM) 通知，type=FRIEND_ADD
func handleFriendAdd(ctx *gameserver.HandlerContext) {
	var friendID int64
	if len(ctx.Body) >= 4 {
		friendID = int64(binary.BigEndian.Uint32(ctx.Body[0:4]))
	}

	if friendID <= 0 {
		// 无效的好友ID
		body := make([]byte, 4)
		ctx.GameServer.SendResponse(ctx.ClientData, 2151, ctx.UserID, ctx.SeqID, body)
		return
	}

	// 不能添加自己为好友
	if friendID == ctx.UserID {
		body := make([]byte, 4)
		ctx.GameServer.SendResponse(ctx.ClientData, 2151, ctx.UserID, ctx.SeqID, body)
		logger.Info(fmt.Sprintf("[2151] 不能添加自己为好友: UID=%d", ctx.UserID))
		return
	}

	// 检查是否已经是好友
	if ctx.GameServer.UserDB != nil {
		if ctx.GameServer.UserDB.IsFriend(ctx.UserID, friendID) {
			body := make([]byte, 4)
			binary.BigEndian.PutUint32(body, uint32(friendID))
			ctx.GameServer.SendResponse(ctx.ClientData, 2151, ctx.UserID, ctx.SeqID, body)
			logger.Info(fmt.Sprintf("[2151] 已经是好友: UID=%d FriendID=%d", ctx.UserID, friendID))
			return
		}
	}

	// 向对方发送好友请求通知（8001 INFORM）
	// InformInfo: type(4) + userID(4) + nick(16) + accept(4) + serverID(4) + mapType(4) + mapID(4) + mapName(64) = 104字节
	requestUser := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	requestNick := requestUser.Nick
	if requestNick == "" {
		requestNick = fmt.Sprintf("Seer%d", ctx.UserID)
	}

	// 构建 InformInfo 包体
	informBody := make([]byte, 104)
	binary.BigEndian.PutUint32(informBody[0:4], 2151) // type = FRIEND_ADD
	binary.BigEndian.PutUint32(informBody[4:8], uint32(ctx.UserID))
	putFixedString := func(s string, n int, offset int) {
		b := []byte(s)
		if len(b) > n {
			b = b[:n]
		}
		copy(informBody[offset:offset+len(b)], b)
		for i := len(b); i < n; i++ {
			informBody[offset+i] = 0
		}
	}
	putFixedString(requestNick, 16, 8)
	binary.BigEndian.PutUint32(informBody[24:28], 0) // accept = 0（请求）
	binary.BigEndian.PutUint32(informBody[28:32], 1) // serverID = 1
	binary.BigEndian.PutUint32(informBody[32:36], 0) // mapType = 0
	mapID := requestUser.MapID
	if mapID <= 0 {
		mapID = 1
	}
	binary.BigEndian.PutUint32(informBody[36:40], uint32(mapID))
	putFixedString("", 64, 40) // mapName

	// 向对方推送通知
	if targetClient := ctx.GameServer.GetClientByUserID(friendID); targetClient != nil && targetClient.LoggedIn {
		ctx.GameServer.SendResponse(targetClient, 8001, friendID, 0, informBody)
		logger.Info(fmt.Sprintf("[2151] 发送好友请求通知: UID=%d -> FriendID=%d", ctx.UserID, friendID))
	} else {
		logger.Info(fmt.Sprintf("[2151] 对方不在线，无法发送好友请求: UID=%d -> FriendID=%d", ctx.UserID, friendID))
	}

	// 响应：返回 friendID（与 Lua 版本一致）
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body, uint32(friendID))
	ctx.GameServer.SendResponse(ctx.ClientData, 2151, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[2151] 发送好友请求: UID=%d FriendID=%d", ctx.UserID, friendID))
}

// handleFriendAnswer CMD 2152 好友请求回复
// 请求: targetID(4) + accept(4) - accept: 1=接受, 0=拒绝
// 响应: accept(4)
// 如果接受，双方都添加为好友，并向请求方发送 8001 (INFORM) 通知
func handleFriendAnswer(ctx *gameserver.HandlerContext) {
	var targetID int64
	var accept uint32
	if len(ctx.Body) >= 8 {
		targetID = int64(binary.BigEndian.Uint32(ctx.Body[0:4]))
		accept = binary.BigEndian.Uint32(ctx.Body[4:8])
	}

	if accept == 1 && targetID > 0 && ctx.GameServer.UserDB != nil {
		// 接受好友请求：双方都添加为好友
		// 1. 我添加对方为好友
		success1, msg1 := ctx.GameServer.UserDB.AddFriend(ctx.UserID, targetID)
		if success1 {
			logger.Info(fmt.Sprintf("[2152] 接受好友请求: UID=%d 添加 FriendID=%d", ctx.UserID, targetID))
			// 更新内存中的用户数据
			user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
			user.Friends = ctx.GameServer.UserDB.GetFriends(ctx.UserID)
		} else {
			logger.Info(fmt.Sprintf("[2152] 接受好友请求失败: UID=%d FriendID=%d Reason=%s", ctx.UserID, targetID, msg1))
		}

		// 2. 对方也添加我为好友（双向好友关系）
		success2, msg2 := ctx.GameServer.UserDB.AddFriend(targetID, ctx.UserID)
		if success2 {
			logger.Info(fmt.Sprintf("[2152] 双向添加好友: FriendID=%d 添加 UID=%d", targetID, ctx.UserID))
			// 更新对方内存中的用户数据
			if targetUser := ctx.GameServer.GetOrCreateUser(targetID); targetUser != nil {
				targetUser.Friends = ctx.GameServer.UserDB.GetFriends(targetID)
			}
		} else {
			logger.Info(fmt.Sprintf("[2152] 双向添加好友失败: FriendID=%d UID=%d Reason=%s", targetID, ctx.UserID, msg2))
		}

		// 3. 向请求方发送接受通知（8001 INFORM）
		// InformInfo: type(4) + userID(4) + nick(16) + accept(4) + serverID(4) + mapType(4) + mapID(4) + mapName(64) = 104字节
		myUser := ctx.GameServer.GetOrCreateUser(ctx.UserID)
		myNick := myUser.Nick
		if myNick == "" {
			myNick = fmt.Sprintf("Seer%d", ctx.UserID)
		}

		informBody := make([]byte, 104)
		binary.BigEndian.PutUint32(informBody[0:4], 2152) // type = FRIEND_ANSWER
		binary.BigEndian.PutUint32(informBody[4:8], uint32(ctx.UserID))
		putFixedString := func(s string, n int, offset int) {
			b := []byte(s)
			if len(b) > n {
				b = b[:n]
			}
			copy(informBody[offset:offset+len(b)], b)
			for i := len(b); i < n; i++ {
				informBody[offset+i] = 0
			}
		}
		putFixedString(myNick, 16, 8)
		binary.BigEndian.PutUint32(informBody[24:28], 1) // accept = 1（已接受）
		binary.BigEndian.PutUint32(informBody[28:32], 1) // serverID = 1
		binary.BigEndian.PutUint32(informBody[32:36], 0) // mapType = 0
		mapID := myUser.MapID
		if mapID <= 0 {
			mapID = 1
		}
		binary.BigEndian.PutUint32(informBody[36:40], uint32(mapID))
		putFixedString("", 64, 40) // mapName

		// 向请求方推送通知
		if requestClient := ctx.GameServer.GetClientByUserID(targetID); requestClient != nil && requestClient.LoggedIn {
			ctx.GameServer.SendResponse(requestClient, 8001, targetID, 0, informBody)
			logger.Info(fmt.Sprintf("[2152] 发送接受通知: UID=%d -> RequestID=%d", ctx.UserID, targetID))
		}
	} else if accept == 0 && targetID > 0 {
		logger.Info(fmt.Sprintf("[2152] 拒绝好友请求: UID=%d FriendID=%d", ctx.UserID, targetID))
		// 可选：向请求方发送拒绝通知
	}

	// 响应：返回 accept
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body, accept)
	ctx.GameServer.SendResponse(ctx.ClientData, 2152, ctx.UserID, ctx.SeqID, body)
}

// handleFriendRemove CMD 2153 删除好友
// 请求: friendID(4)
// 响应: 空
func handleFriendRemove(ctx *gameserver.HandlerContext) {
	var friendID int64
	if len(ctx.Body) >= 4 {
		friendID = int64(binary.BigEndian.Uint32(ctx.Body[0:4]))
	}

	if friendID > 0 && ctx.GameServer.UserDB != nil {
		success := ctx.GameServer.UserDB.RemoveFriend(ctx.UserID, friendID)
		if success {
			logger.Info(fmt.Sprintf("[2153] 删除好友成功: UID=%d FriendID=%d", ctx.UserID, friendID))
			// 更新内存中的用户数据
			user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
			user.Friends = ctx.GameServer.UserDB.GetFriends(ctx.UserID)
		} else {
			logger.Info(fmt.Sprintf("[2153] 删除好友失败（可能不存在）: UID=%d FriendID=%d", ctx.UserID, friendID))
		}
	}

	// 响应：空（与 Lua 版本一致）
	ctx.GameServer.SendResponse(ctx.ClientData, 2153, ctx.UserID, ctx.SeqID, []byte{})
}

// handleBlackAdd CMD 2154 添加黑名单
// 请求: targetID(4)
// 响应: 空
func handleBlackAdd(ctx *gameserver.HandlerContext) {
	var targetID int64
	if len(ctx.Body) >= 4 {
		targetID = int64(binary.BigEndian.Uint32(ctx.Body[0:4]))
	}

	if targetID > 0 && ctx.GameServer.UserDB != nil {
		success, msg := ctx.GameServer.UserDB.AddBlacklist(ctx.UserID, targetID)
		if success {
			logger.Info(fmt.Sprintf("[2154] 添加黑名单成功: UID=%d TargetID=%d", ctx.UserID, targetID))
			// 更新内存中的用户数据
			user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
			user.Blacklist = ctx.GameServer.UserDB.GetBlacklist(ctx.UserID)
		} else {
			logger.Info(fmt.Sprintf("[2154] 添加黑名单失败: UID=%d TargetID=%d Reason=%s", ctx.UserID, targetID, msg))
		}
	}

	// 响应：空（与 Lua 版本一致）
	ctx.GameServer.SendResponse(ctx.ClientData, 2154, ctx.UserID, ctx.SeqID, []byte{})
}

// handleBlackRemove CMD 2155 移除黑名单
// 请求: targetID(4)
// 响应: 空
func handleBlackRemove(ctx *gameserver.HandlerContext) {
	var targetID int64
	if len(ctx.Body) >= 4 {
		targetID = int64(binary.BigEndian.Uint32(ctx.Body[0:4]))
	}

	if targetID > 0 && ctx.GameServer.UserDB != nil {
		success := ctx.GameServer.UserDB.RemoveBlacklist(ctx.UserID, targetID)
		if success {
			logger.Info(fmt.Sprintf("[2155] 移除黑名单成功: UID=%d TargetID=%d", ctx.UserID, targetID))
			// 更新内存中的用户数据
			user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
			user.Blacklist = ctx.GameServer.UserDB.GetBlacklist(ctx.UserID)
		} else {
			logger.Info(fmt.Sprintf("[2155] 移除黑名单失败（可能不存在）: UID=%d TargetID=%d", ctx.UserID, targetID))
		}
	}

	// 响应：空（与 Lua 版本一致）
	ctx.GameServer.SendResponse(ctx.ClientData, 2155, ctx.UserID, ctx.SeqID, []byte{})
}

// handleSeeOnline CMD 2157 查看在线状态
// 请求: count(4) + userIDs[count] (每个4字节)
// 响应: onlineCount(4) + [OnLineInfo]...
// OnLineInfo: userID(4) + serverID(4) + mapType(4) + mapID(4) = 16 bytes
func handleSeeOnline(ctx *gameserver.HandlerContext) {
	var requestCount uint32
	if len(ctx.Body) >= 4 {
		requestCount = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	// 读取所有请求的用户ID
	userIDs := make([]int64, 0, requestCount)
	for i := uint32(0); i < requestCount; i++ {
		offset := 4 + int(i)*4
		if len(ctx.Body) >= offset+4 {
			userID := int64(binary.BigEndian.Uint32(ctx.Body[offset : offset+4]))
			userIDs = append(userIDs, userID)
		}
	}

	// 构建在线用户列表
	onlineUsers := make([]struct {
		userID   int64
		serverID uint32
		mapType  uint32
		mapID    uint32
	}, 0)

	for _, targetID := range userIDs {
		// 检查用户是否在线
		if client := ctx.GameServer.GetClientByUserID(targetID); client != nil && client.LoggedIn {
			user := ctx.GameServer.GetOrCreateUser(targetID)
			mapID := user.MapID
			if mapID == 0 {
				mapID = 1
			}
			mapType := uint32(0)  // 默认地图类型
			serverID := uint32(1) // 当前服务器ID

			onlineUsers = append(onlineUsers, struct {
				userID   int64
				serverID uint32
				mapType  uint32
				mapID    uint32
			}{
				userID:   targetID,
				serverID: serverID,
				mapType:  mapType,
				mapID:    uint32(mapID),
			})
		}
	}

	// 构建响应: count(4) + [OnLineInfo]...
	body := make([]byte, 0, 4+len(onlineUsers)*16)
	tmp := make([]byte, 4)
	binary.BigEndian.PutUint32(tmp, uint32(len(onlineUsers)))
	body = append(body, tmp...)

	for _, info := range onlineUsers {
		binary.BigEndian.PutUint32(tmp, uint32(info.userID))
		body = append(body, tmp...)
		binary.BigEndian.PutUint32(tmp, info.serverID)
		body = append(body, tmp...)
		binary.BigEndian.PutUint32(tmp, info.mapType)
		body = append(body, tmp...)
		binary.BigEndian.PutUint32(tmp, info.mapID)
		body = append(body, tmp...)
	}

	ctx.GameServer.SendResponse(ctx.ClientData, 2157, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[2157] 查看在线状态: UID=%d Requested=%d Online=%d", ctx.UserID, requestCount, len(onlineUsers)))
}

// handleRequestOut CMD 2158 发送请求
// 响应: 空
func handleRequestOut(ctx *gameserver.HandlerContext) {
	// 响应：空（与 Lua 版本一致）
	ctx.GameServer.SendResponse(ctx.ClientData, 2158, ctx.UserID, ctx.SeqID, []byte{})
}

// handleRequestAnswer CMD 2159 请求回复
// 响应: 空
func handleRequestAnswer(ctx *gameserver.HandlerContext) {
	// 响应：空（与 Lua 版本一致）
	ctx.GameServer.SendResponse(ctx.ClientData, 2159, ctx.UserID, ctx.SeqID, []byte{})
}

// handleGetExchangeInfo CMD 70001 获取交换/荣誉信息（当前返回 0）
// 对齐 Lua: misc_handlers.handleGetExchangeInfo
func handleGetExchangeInfo(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	// honorValue=0
	ctx.GameServer.SendResponse(ctx.ClientData, 70001, ctx.UserID, ctx.SeqID, body)
}

// handleXinCheck CMD 50004 客户端信息上报（空回包）
func handleXinCheck(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, 50004, ctx.UserID, ctx.SeqID, []byte{})
}

// handleXinGetQuadTime CMD 50008 获取四倍经验时间（0）
func handleXinGetQuadTime(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	ctx.GameServer.SendResponse(ctx.ClientData, 50008, ctx.UserID, ctx.SeqID, body)
}

// handleGoldOnlineCheckRemain CMD 1106 在线金豆余额（客户端 /100 显示）
func handleGoldOnlineCheckRemain(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	// 客户端读取 readUnsignedInt()/100 为金豆数
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body, uint32(user.Gold*100))
	ctx.GameServer.SendResponse(ctx.ClientData, 1106, ctx.UserID, ctx.SeqID, body)
}

// handleMoneyCheckPsw CMD 1101 米币支付密码检查
// 客户端：若返回 1 则继续发送 MONEY_CHECK_REMAIN(1103)；否则提示设置支付密码
func handleMoneyCheckPsw(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body, 1) // 1 = 已设置/跳过，继续购买流程
	ctx.GameServer.SendResponse(ctx.ClientData, 1101, ctx.UserID, ctx.SeqID, body)
}

// handleMoneyCheckRemain CMD 1103 米币余额检查（客户端 /100 显示为米币数）
func handleMoneyCheckRemain(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	// 本地服无米币体系，用金豆*100 返回，使购买流程可走通
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body, uint32(user.Gold*100))
	ctx.GameServer.SendResponse(ctx.ClientData, 1103, ctx.UserID, ctx.SeqID, body)
}

// goldProductEntry 金豆商城商品（与 xml/225.xml GoldProduct 一致）
type goldProductEntry struct {
	Price  int
	ItemID int
}

// goldProductMap 金豆商品 productID -> 价格与物品ID（来自 225.xml）
var goldProductMap = map[uint32]goldProductEntry{
	240000: {50, 300006}, 240001: {5, 300024}, 240002: {10, 300025}, 240003: {5, 300026},
	240004: {5, 300027}, 240005: {30, 100266}, 240006: {30, 100267}, 240007: {30, 100268},
	240008: {10, 400054}, 240009: {10, 300028}, 240010: {5, 300029}, 240011: {2, 300030},
	240012: {2, 300031}, 240013: {3, 300032}, 240014: {3, 300033}, 240015: {4, 300034},
	240016: {10, 300035}, 240017: {10, 300036}, 240018: {15, 300037}, 240019: {15, 300038},
	240020: {15, 300039}, 240021: {15, 300040}, 240022: {15, 300041}, 240023: {15, 300042},
	240024: {50, 300043}, 240025: {5, 300044}, 240026: {80, 300009}, 240027: {4, 300045},
	240028: {4, 300046}, 240029: {6, 300047}, 240030: {6, 300048}, 240031: {8, 300049},
	240032: {16, 300050},
}

// handleGoldBuyProduct CMD 1104 金豆购买商品
// 请求: productID(4) + count(2 字节 short 大端)
// 响应: result(4) + payGold*100(4) + gold*100(4)，客户端 GoldBuyProductInfo 解析 payGold/gold 为 /100
func handleGoldBuyProduct(ctx *gameserver.HandlerContext) {
	if len(ctx.Body) < 6 {
		ctx.GameServer.SendResponse(ctx.ClientData, 1104, ctx.UserID, ctx.SeqID, []byte{})
		return
	}
	productID := binary.BigEndian.Uint32(ctx.Body[0:4])
	count := int(uint32(ctx.Body[4])<<8 | uint32(ctx.Body[5]))
	if count <= 0 {
		count = 1
	}
	entry, ok := goldProductMap[productID]
	if !ok {
		logger.Warning(fmt.Sprintf("[1104] 未知金豆商品 productID=%d", productID))
		ctx.GameServer.SendResponse(ctx.ClientData, 1104, ctx.UserID, ctx.SeqID, []byte{})
		return
	}
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	totalCost := entry.Price * count
	if user.Gold < totalCost {
		logger.Warning(fmt.Sprintf("[1104] 金豆不足: 需要%d 当前%d", totalCost, user.Gold))
		ctx.GameServer.SendResponse(ctx.ClientData, 1104, ctx.UserID, ctx.SeqID, []byte{})
		return
	}
	user.Gold -= totalCost
	itemKey := strconv.Itoa(entry.ItemID)
	if it, has := user.Items[itemKey]; has {
		it.Count += count
		user.Items[itemKey] = it
	} else {
		user.Items[itemKey] = userdb.Item{Count: count, ExpireTime: 0x057E40}
	}
	// 服装/套装（100000-199999）需同时加入 Clothes，否则“我的服装”中不显示
	addClothIfNeeded(user, entry.ItemID)
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	// 响应: result(4) + payGold*100(4) + gold*100(4)
	body := make([]byte, 12)
	binary.BigEndian.PutUint32(body[0:4], 0)
	binary.BigEndian.PutUint32(body[4:8], uint32(totalCost*100))
	binary.BigEndian.PutUint32(body[8:12], uint32(user.Gold*100))
	ctx.GameServer.SendResponse(ctx.ClientData, 1104, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[1104] 金豆购买: productID=%d itemID=%d count=%d 消耗金豆=%d 剩余=%d", productID, entry.ItemID, count, totalCost, user.Gold))
}

// handleNonoInfo CMD 9003 获取 NONO 信息
// 对齐 Lua: nono_handlers.handleNonoInfo（body 固定 90 字节）
func handleNonoInfo(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	n := user.Nono

	buf := make([]byte, 0, 90)
	writeU32 := func(v uint32) {
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, v)
		buf = append(buf, tmp...)
	}
	writeU16 := func(v uint16) {
		tmp := make([]byte, 2)
		binary.BigEndian.PutUint16(tmp, v)
		buf = append(buf, tmp...)
	}
	writeFixedString := func(s string, n int) {
		b := []byte(s)
		if len(b) > n {
			b = b[:n]
		}
		buf = append(buf, b...)
		if len(b) < n {
			buf = append(buf, make([]byte, n-len(b))...)
		}
	}

	writeU32(uint32(ctx.UserID)) // userId
	writeU32(uint32(n.Flag))     // flag
	writeU32(uint32(n.State))    // state
	writeFixedString(n.Nick, 16) // nick
	if n.SuperNono > 0 {
		writeU32(1)
	} else {
		writeU32(0)
	}
	writeU32(uint32(n.Color))        // color
	writeU32(uint32(n.Power * 1000)) // power (*1000)
	writeU32(uint32(n.Mate * 1000))  // mate (*1000)
	writeU32(uint32(n.IQ))           // iq
	writeU16(uint16(n.AI))           // ai (2)
	if n.Birth > 0 {
		writeU32(uint32(n.Birth))
	} else {
		writeU32(uint32(time.Now().Unix()))
	}
	writeU32(uint32(n.ChargeTime))         // chargeTime
	buf = append(buf, make([]byte, 20)...) // func bitset (20 bytes), 当前不存，填 0
	writeU32(uint32(n.SuperEnergy))
	writeU32(uint32(n.SuperLevel))
	writeU32(uint32(n.SuperStage))

	ctx.GameServer.SendResponse(ctx.ClientData, 9003, ctx.UserID, ctx.SeqID, buf)
}

// ==================== 任务 / 新手奖励 ====================

// 新手任务 ID 对齐 Lua NOVICE_TASK；其他任务 ID 见前端 MapProcess / TaskClass
const (
	taskGetCloth     = 85 // 领取服装
	taskSelectPet    = 86 // 选择精灵
	taskWinBattle    = 87 // 战斗胜利
	taskUseItem      = 88 // 使用道具
	taskBombDisposal = 9  // 赫尔卡星拆弹小游戏（MapProcess_30.as accept(9)），奖励电能锯子
)

// 新手三选一精灵映射，对齐 Lua NOVICE_PET_MAP / MapProcess_102.as
// 1 -> 布布种子 (1)
// 2 -> 小火猴   (7)
// 3 -> 伊优     (4)
var novicePetMap = map[uint32]int{
	1: 1,
	2: 7,
	3: 4,
}

// handleAcceptTask CMD 2201 接受任务
// 对齐 Lua: task_handlers.handleAcceptTask
func handleAcceptTask(ctx *gameserver.HandlerContext) {
	var taskID uint32
	if len(ctx.Body) >= 4 {
		taskID = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.Tasks == nil {
		user.Tasks = make(map[string]userdb.Task)
	}
	key := strconv.FormatUint(uint64(taskID), 10)
	t := user.Tasks[key]
	t.Status = "1" // 1 = 已接受
	user.Tasks[key] = t

	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	buf := make([]byte, 4)
	binary.BigEndian.PutUint32(buf, taskID)
	ctx.GameServer.SendResponse(ctx.ClientData, 2201, ctx.UserID, ctx.SeqID, buf)
}

// handleGetTaskBuf CMD 2203 获取任务进度（GET_TASK_BUF），地图装置/NPC 对话依赖此接口
// 请求: taskId(4)。响应: taskId(4) + flag(4) + buf(20 字节)，与前端 TaskBufInfo(taskId, flag, buf) 及 buf.position=i; readBoolean() 一致
func handleGetTaskBuf(ctx *gameserver.HandlerContext) {
	var taskID uint32
	if len(ctx.Body) >= 4 {
		taskID = binary.BigEndian.Uint32(ctx.Body[0:4])
	}
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	flag := uint32(0)
	bufBytes := make([]byte, 20)
	if user.Tasks != nil {
		key := strconv.FormatUint(uint64(taskID), 10)
		if t, ok := user.Tasks[key]; ok && t.Buf != nil {
			for i := 0; i < 20; i++ {
				if v, ok := t.Buf[i]; ok {
					bufBytes[i] = byte(v & 0xff)
				}
			}
			flag = 1
		}
	}
	body := make([]byte, 4+4+20)
	binary.BigEndian.PutUint32(body[0:4], taskID)
	binary.BigEndian.PutUint32(body[4:8], flag)
	copy(body[8:28], bufBytes)
	ctx.GameServer.SendResponse(ctx.ClientData, 2203, ctx.UserID, ctx.SeqID, body)
}

// handleAcceptDailyTask CMD 2231 接受每日任务
// 请求: taskID(4)，响应: taskID(4)，与 2201 逻辑一致
func handleAcceptDailyTask(ctx *gameserver.HandlerContext) {
	var taskID uint32
	if len(ctx.Body) >= 4 {
		taskID = binary.BigEndian.Uint32(ctx.Body[0:4])
	}
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.Tasks == nil {
		user.Tasks = make(map[string]userdb.Task)
	}
	key := strconv.FormatUint(uint64(taskID), 10)
	t := user.Tasks[key]
	t.Status = "1" // 已接受
	user.Tasks[key] = t
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	buf := make([]byte, 4)
	binary.BigEndian.PutUint32(buf, taskID)
	ctx.GameServer.SendResponse(ctx.ClientData, 2231, ctx.UserID, ctx.SeqID, buf)
}

// handleDeleteDailyTask CMD 2232 放弃每日任务
// 请求: taskID(4)，响应: taskID(4)
func handleDeleteDailyTask(ctx *gameserver.HandlerContext) {
	var taskID uint32
	if len(ctx.Body) >= 4 {
		taskID = binary.BigEndian.Uint32(ctx.Body[0:4])
	}
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.Tasks != nil {
		key := strconv.FormatUint(uint64(taskID), 10)
		delete(user.Tasks, key)
		if ctx.GameServer.UserDB != nil {
			ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
		}
	}
	buf := make([]byte, 4)
	binary.BigEndian.PutUint32(buf, taskID)
	ctx.GameServer.SendResponse(ctx.ClientData, 2232, ctx.UserID, ctx.SeqID, buf)
}

// handleCompleteDailyTask CMD 2233 完成每日任务
// 请求: taskID(4) + param(4)，响应: NoviceFinishInfo（与 2202 相同），客户端据此 setTaskStatus(COMPLETE)
func handleCompleteDailyTask(ctx *gameserver.HandlerContext) {
	var taskID, param uint32
	if len(ctx.Body) >= 4 {
		taskID = binary.BigEndian.Uint32(ctx.Body[0:4])
	}
	if len(ctx.Body) >= 8 {
		param = binary.BigEndian.Uint32(ctx.Body[4:8])
	}
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.Tasks == nil {
		user.Tasks = make(map[string]userdb.Task)
	}
	key := strconv.FormatUint(uint64(taskID), 10)
	t := user.Tasks[key]
	t.Status = "3" // 已完成
	user.Tasks[key] = t
	body := buildTaskCompleteResponse(taskID, param, user)
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 2233, ctx.UserID, ctx.SeqID, body)
}

// handleCompleteTask CMD 2202 完成任务（包含新手奖励）
// 对齐 Lua: task_handlers.handleCompleteTask / buildTaskCompleteResponse
func handleCompleteTask(ctx *gameserver.HandlerContext) {
	var taskID, param uint32
	if len(ctx.Body) >= 4 {
		taskID = binary.BigEndian.Uint32(ctx.Body[0:4])
	}
	if len(ctx.Body) >= 8 {
		param = binary.BigEndian.Uint32(ctx.Body[4:8])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.Tasks == nil {
		user.Tasks = make(map[string]userdb.Task)
	}
	key := strconv.FormatUint(uint64(taskID), 10)
	t := user.Tasks[key]
	t.Status = "3" // 3 = 已完成
	user.Tasks[key] = t

	// 构建任务完成响应（包含新手三选一精灵和物品奖励等）
	body := buildTaskCompleteResponse(taskID, param, user)

	// 保存数据（任务完成可能添加了精灵或物品）
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	ctx.GameServer.SendResponse(ctx.ClientData, 2202, ctx.UserID, ctx.SeqID, body)
}

// buildTaskCompleteResponse 构建任务完成响应
// NoviceFinishInfo: taskID(4) + petID(4) + captureTm(4) + itemCount(4) + [itemID(4) + itemCnt(4)]...
// 这里只精确实现新手三选一精灵，其他任务返回空奖励但保持结构正确。
func buildTaskCompleteResponse(taskID, param uint32, user *userdb.GameData) []byte {
	writeU32To := func(buf []byte, off int, v uint32) {
		binary.BigEndian.PutUint32(buf[off:off+4], v)
	}

	var petID uint32
	var captureTm uint32

	// 处理新手选宠任务
	if taskID == taskSelectPet {
		if mapped, ok := novicePetMap[param]; ok {
			petID = uint32(mapped)
		} else {
			petID = 1
		}
		captureTm = 0x69686700 + petID

		// 添加到 pets 列表（如果还没有该精灵）
		found := false
		for _, p := range user.Pets {
			if p.ID == int(petID) && p.CatchTime == int(captureTm) {
				found = true
				break
			}
		}
		if !found {
			// 随机性格（0-24）
			rand.Seed(time.Now().UnixNano())
			randomNature := rand.Intn(25)
			// 随机个体值（15-31，新手精灵稍微好一点）
			randomDV := 15 + rand.Intn(17) // 15-31

			newPet := userdb.Pet{
				ID:        int(petID),
				CatchTime: int(captureTm),
				Level:     5,
				DV:        randomDV,
				Nature:    randomNature,
				Exp:       0,
				Name:      "",
			}
			user.Pets = append(user.Pets, newPet)
			logger.Info(fmt.Sprintf("[2202] 新手选宠: PetID=%d DV=%d Nature=%d", petID, randomDV, randomNature))
		}
	}

	// 根据任务ID添加物品奖励
	itemCount := uint32(0)
	itemRewards := []struct {
		id    uint32
		count uint32
	}{}

	if user.Items == nil {
		user.Items = make(map[string]userdb.Item)
	}

	// 任务85（领取服装）给新手套装
	if taskID == 85 {
		noviceClothes := []struct {
			id    uint32
			count uint32
		}{
			{100027, 1}, // 新手服装1
			{100028, 1}, // 新手服装2
			{500001, 1}, // 新手家具
			{300650, 3}, // 新手道具1
			{300025, 3}, // 新手道具2
			{300035, 3}, // 新手道具3
			{500502, 1}, // 新手家具2
			{500503, 1}, // 新手家具3
		}

		for _, item := range noviceClothes {
			itemKey := strconv.FormatUint(uint64(item.id), 10)
			if existing, ok := user.Items[itemKey]; ok {
				existing.Count += int(item.count)
				user.Items[itemKey] = existing
			} else {
				user.Items[itemKey] = userdb.Item{Count: int(item.count), ExpireTime: 0x057E40}
			}
			itemRewards = append(itemRewards, item)
			itemCount++
			logger.Info(fmt.Sprintf("[2202] 任务完成奖励: 物品 %d x%d", item.id, item.count))
		}
	}

	// 任务87（战斗胜利）给一些物品奖励
	if taskID == taskWinBattle {
		// 添加治疗药水
		itemKey := "300001"
		if existing, ok := user.Items[itemKey]; ok {
			existing.Count += 5
			user.Items[itemKey] = existing
		} else {
			user.Items[itemKey] = userdb.Item{Count: 5, ExpireTime: 0x057E40}
		}
		itemRewards = append(itemRewards, struct {
			id    uint32
			count uint32
		}{300001, 5})
		itemCount++

		itemKey2 := "300011"
		if existing, ok := user.Items[itemKey2]; ok {
			existing.Count += 3
			user.Items[itemKey2] = existing
		} else {
			user.Items[itemKey2] = userdb.Item{Count: 3, ExpireTime: 0x057E40}
		}
		itemRewards = append(itemRewards, struct {
			id    uint32
			count uint32
		}{300011, 3})
		itemCount++
		logger.Info(fmt.Sprintf("[2202] 任务完成奖励: 物品 300001 x5, 300011 x3"))
	}

	// 任务88（使用道具）给金币奖励
	if taskID == taskUseItem {
		// 添加金币（特殊奖励类型1）
		itemRewards = append(itemRewards, struct {
			id    uint32
			count uint32
		}{1, 50000}) // 类型1=金币
		itemCount++

		// 添加经验（特殊奖励类型3）
		itemRewards = append(itemRewards, struct {
			id    uint32
			count uint32
		}{3, 250000}) // 类型3=经验
		itemCount++

		// 添加其他奖励（特殊奖励类型5）
		itemRewards = append(itemRewards, struct {
			id    uint32
			count uint32
		}{5, 20})
		itemCount++

		// 更新用户金币
		user.Coins += 50000
		logger.Info(fmt.Sprintf("[2202] 任务完成奖励: 金币 +50000, 经验 +250000, 其他 +20"))
	}

	// 任务 9：赫尔卡星拆弹小游戏完成，奖励电能锯子（100059）
	if taskID == taskBombDisposal {
		itemID := uint32(100059) // 电能锯子
		itemKey := strconv.FormatUint(uint64(itemID), 10)
		if existing, ok := user.Items[itemKey]; ok {
			existing.Count++
			user.Items[itemKey] = existing
		} else {
			user.Items[itemKey] = userdb.Item{Count: 1, ExpireTime: 0x057E40}
		}
		itemRewards = append(itemRewards, struct {
			id    uint32
			count uint32
		}{itemID, 1})
		itemCount++
		logger.Info(fmt.Sprintf("[2202] 任务完成奖励: 拆弹小游戏 电能锯子(100059) x1"))
	}

	// 无配置奖励时（如每日任务）给默认 2000 点积累经验，客户端 TaskClass 显示“你获得了 2000 点积累经验！”
	if itemCount == 0 && petID == 0 {
		defaultExp := uint32(2000)
		if user.ExpPool < 0 {
			user.ExpPool = 0
		}
		user.ExpPool += int(defaultExp)
		itemRewards = append(itemRewards, struct {
			id    uint32
			count uint32
		}{3, defaultExp}) // 类型 3 = 积累经验
		itemCount++
		logger.Info(fmt.Sprintf("[2202/2233] 任务完成默认奖励: 积累经验 +%d", defaultExp))
	}

	// 构建响应体
	bodySize := 16 + int(itemCount)*8 // taskID(4) + petID(4) + captureTm(4) + itemCount(4) + [itemID(4) + itemCnt(4)]...
	body := make([]byte, bodySize)
	writeU32To(body, 0, taskID)
	writeU32To(body, 4, petID)
	writeU32To(body, 8, captureTm)
	writeU32To(body, 12, itemCount)

	off := 16
	for _, item := range itemRewards {
		writeU32To(body, off, item.id)
		off += 4
		writeU32To(body, off, item.count)
		off += 4
	}

	return body
}

// handleGetSoulBeadList CMD 2354 获取魂珠列表
// 对齐 Lua: pet_handlers.handleGetSoulBeadList（返回一个 4 字节的 0）
func handleGetSoulBeadList(ctx *gameserver.HandlerContext) {
	buf := make([]byte, 4)
	// 目前没有魂珠系统，直接返回 0
	ctx.GameServer.SendResponse(ctx.ClientData, 2354, ctx.UserID, ctx.SeqID, buf)
}

// ==================== 物品 / 背包 ====================

// handleItemList CMD 2605 物品列表（战斗中/非战斗均可请求）
// 对齐 Lua: item_handlers.handleItemList
// 请求: itemType1(4)+itemType2(4)+itemType3(4)；不足 12 字节或 (a,0,0) 时按“全部”返回，避免战斗中道具面板为空
// 响应: itemCount(4) + [itemId(4)+count(4)+expireTime(4)+unknown(4)]...
func handleItemList(ctx *gameserver.HandlerContext) {
	var a, b, c uint32
	if len(ctx.Body) >= 12 {
		a = binary.BigEndian.Uint32(ctx.Body[0:4])
		b = binary.BigEndian.Uint32(ctx.Body[4:8])
		c = binary.BigEndian.Uint32(ctx.Body[8:12])
	}
	// 部分客户端在战斗中只发类型或 (type,0,0)，导致 b<c 或 b==0 时 inRange 几乎为假，返回空列表
	if a != 0 && b == 0 && c == 0 {
		a, b, c = 0, 0, 0
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	type itemRow struct {
		id         uint32
		count      uint32
		expireTime uint32
	}
	rows := make([]itemRow, 0, len(user.Items))

	// 收藏物品ID范围（与前端 SingleItemInfo ItemType.COLLECTON 一致，排除装备 100001-200000 和 1300001-1400000）
	isCollectionItem := func(id uint32) bool {
		return (id > 10000 && id < 100000) ||
			(id >= 400001 && id <= 500000) ||
			(id >= 1200001 && id <= 1300000) ||
			(id > 1500000 && id < 1600000)
	}

	inRange := func(id uint32) bool {
		if a == 0 && b == 0 && c == 0 {
			// 收藏 tab 请求(0,0,0)：只返回收藏类物品，装备与收藏分开显示
			return isCollectionItem(id)
		}
		return (id >= a && id <= b) || id == c
	}

	logger.Info(fmt.Sprintf("[2605] 物品列表请求: 范围 %d-%d, %d (用户总物品数: %d)", a, b, c, len(user.Items)))

	for k, it := range user.Items {
		id64, err := strconv.ParseUint(k, 10, 32)
		if err != nil {
			logger.Warning(fmt.Sprintf("[2605] 无效的物品ID: %s", k))
			continue
		}
		id := uint32(id64)
		if !inRange(id) {
			logger.Info(fmt.Sprintf("[2605] 物品 %d 不在范围内 (范围: %d-%d, %d)", id, a, b, c))
			continue
		}
		exp := uint32(it.ExpireTime)
		if exp == 0 {
			exp = 0x057E40
		}
		rows = append(rows, itemRow{
			id:         id,
			count:      uint32(it.Count),
			expireTime: exp,
		})
		logger.Info(fmt.Sprintf("[2605] 添加物品: ID=%d Count=%d ExpireTime=%d", id, it.Count, exp))
	}

	body := make([]byte, 4+len(rows)*16)
	binary.BigEndian.PutUint32(body[0:4], uint32(len(rows)))
	off := 4
	for _, r := range rows {
		binary.BigEndian.PutUint32(body[off:off+4], r.id)
		binary.BigEndian.PutUint32(body[off+4:off+8], r.count)
		binary.BigEndian.PutUint32(body[off+8:off+12], r.expireTime)
		binary.BigEndian.PutUint32(body[off+12:off+16], 0)
		off += 16
	}

	logger.Info(fmt.Sprintf("[2605] 返回物品列表: 数量=%d BodyLen=%d", len(rows), len(body)))
	ctx.GameServer.SendResponse(ctx.ClientData, 2605, ctx.UserID, ctx.SeqID, body)
}

// ==================== 精灵互转 / 展示（2304） ====================

// handlePetRelease CMD 2304 释放/背包仓库互转
// 对齐 Lua: pet_handlers.handlePetRelease（返回 PetTakeOutInfo）
// 请求: catchId(4) + flag(4) - flag=1: 仓库->背包, flag=0: 背包->仓库
// 响应: homeEnergy(4) + firstPetTime(4) + flag(4) + [PetInfo]?
func handlePetRelease(ctx *gameserver.HandlerContext) {
	var catchID uint32
	var reqFlag uint32
	if len(ctx.Body) >= 8 {
		catchID = binary.BigEndian.Uint32(ctx.Body[0:4])
		reqFlag = binary.BigEndian.Uint32(ctx.Body[4:8])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	// 确保StoragePets不为nil
	if user.StoragePets == nil {
		user.StoragePets = []userdb.Pet{}
	}

	var picked *userdb.Pet
	var pickedIndex int = -1
	var respFlag uint32 = 0

	if reqFlag == 1 {
		// 仓库 -> 背包
		for i := range user.StoragePets {
			if uint32(user.StoragePets[i].CatchTime) == catchID {
				picked = &user.StoragePets[i]
				pickedIndex = i
				break
			}
		}
		if picked != nil {
			// 从仓库移除
			user.StoragePets = append(user.StoragePets[:pickedIndex], user.StoragePets[pickedIndex+1:]...)
			// 添加到背包
			user.Pets = append(user.Pets, *picked)
			respFlag = 1 // 返回PetInfo
		}
	} else {
		// 背包 -> 仓库
		for i := range user.Pets {
			if uint32(user.Pets[i].CatchTime) == catchID {
				picked = &user.Pets[i]
				pickedIndex = i
				break
			}
		}
		if picked != nil {
			// 从背包移除
			user.Pets = append(user.Pets[:pickedIndex], user.Pets[pickedIndex+1:]...)
			// 添加到仓库
			user.StoragePets = append(user.StoragePets, *picked)
			respFlag = 0 // 不返回PetInfo
		}
	}

	// 如果没找到，尝试使用第一个精灵
	if picked == nil && len(user.Pets) > 0 {
		picked = &user.Pets[0]
		respFlag = 1
	}

	firstPetTime := uint32(0)
	if len(user.Pets) > 0 {
		firstPetTime = uint32(user.Pets[0].CatchTime)
	}

	// 保存数据
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	petBody := []byte{}
	if picked != nil && respFlag == 1 {
		petBody = buildFullPetInfo(*picked)
	}

	body := make([]byte, 12+len(petBody))
	binary.BigEndian.PutUint32(body[0:4], 0)            // homeEnergy
	binary.BigEndian.PutUint32(body[4:8], firstPetTime) // firstPetTime
	binary.BigEndian.PutUint32(body[8:12], respFlag)    // flag
	if len(petBody) > 0 {
		copy(body[12:], petBody)
	}

	ctx.GameServer.SendResponse(ctx.ClientData, 2304, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[2304] 精灵仓库互转: catchID=%d flag=%d respFlag=%d", catchID, reqFlag, respFlag))
}

// handleGetPetInfo CMD 2301 获取精灵完整信息（用于战斗前 PetManager 初始化 / PvP 时查看对方精灵）
// 请求: catchTime(4)；若为 0 则返回当前/第一只精灵。PvP 时客户端会用对方 catchTime 请求，需从对方用户查并返回
func handleGetPetInfo(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	var catch uint32
	if len(ctx.Body) >= 4 {
		catch = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	var picked *userdb.Pet
	if catch != 0 {
		for i := range user.Pets {
			if uint32(user.Pets[i].CatchTime) == catch {
				picked = &user.Pets[i]
				break
			}
		}
		if picked == nil && user.StoragePets != nil {
			for i := range user.StoragePets {
				if uint32(user.StoragePets[i].CatchTime) == catch {
					picked = &user.StoragePets[i]
					break
				}
			}
		}
		// PvP 时：若己方未找到该 catchTime，尝试从对方用户查找（用于显示对方精灵属性/模型）
		if picked == nil {
			ctx.GameServer.BattleMu.Lock()
			battle, ok := ctx.GameServer.BattleStates[ctx.UserID]
			if ok && battle.IsActive && battle.OpponentUserID != 0 {
				oppUser := ctx.GameServer.GetOrCreateUser(battle.OpponentUserID)
				for i := range oppUser.Pets {
					if uint32(oppUser.Pets[i].CatchTime) == catch {
						picked = &oppUser.Pets[i]
						break
					}
				}
				ctx.GameServer.BattleMu.Unlock()
				if picked != nil {
					body := buildFullPetInfo(*picked)
					logger.Info(fmt.Sprintf("[2301] PvP 对方精灵: PetID=%d Level=%d BodyLen=%d", picked.ID, picked.Level, len(body)))
					ctx.GameServer.SendResponse(ctx.ClientData, 2301, ctx.UserID, ctx.SeqID, body)
					return
				}
			} else {
				ctx.GameServer.BattleMu.Unlock()
			}
		}
	}
	if picked == nil && len(user.Pets) > 0 {
		picked = &user.Pets[0]
	}
	if picked == nil {
		ctx.GameServer.SendResponse(ctx.ClientData, 2301, ctx.UserID, ctx.SeqID, []byte{})
		return
	}

	body := buildFullPetInfo(*picked)
	logger.Info(fmt.Sprintf("[2301] 发送完整宠物信息: PetID=%d Level=%d BodyLen=%d", picked.ID, picked.Level, len(body)))
	ctx.GameServer.SendResponse(ctx.ClientData, 2301, ctx.UserID, ctx.SeqID, body)
}

// handleSetDefaultPet CMD 2308 设置首发精灵（客户端 CommandID.PET_DEFAULT）
// 请求: catchTime(4) - 要设置为首发的精灵的捕获时间
// 响应: 4 字节 0 表示成功（客户端部分实现依赖非空包才触发回调）
func handleSetDefaultPet(ctx *gameserver.HandlerContext) {
	respBody := make([]byte, 4)
	binary.BigEndian.PutUint32(respBody[0:4], 0)
	if len(ctx.Body) < 4 {
		logger.Error("[2308] 请求体长度不足")
		ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, respBody)
		return
	}

	catchTime := binary.BigEndian.Uint32(ctx.Body[0:4])
	logger.Info(fmt.Sprintf("[2308] 收到设置首发精灵请求: UID=%d CatchTime=%d", ctx.UserID, catchTime))

	gameData := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if gameData == nil {
		logger.Error(fmt.Sprintf("[2308] 无法获取用户数据: UID=%d", ctx.UserID))
		ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, respBody)
		return
	}

	var targetIndex = -1
	for i, pet := range gameData.Pets {
		if uint32(pet.CatchTime) == catchTime {
			targetIndex = i
			break
		}
	}

	if targetIndex == -1 {
		logger.Error(fmt.Sprintf("[2308] 未找到指定精灵: UID=%d CatchTime=%d", ctx.UserID, catchTime))
		ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, respBody)
		return
	}

	if targetIndex == 0 {
		logger.Info(fmt.Sprintf("[2308] 精灵已是首发: UID=%d PetID=%d", ctx.UserID, gameData.Pets[0].ID))
		ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, respBody)
		return
	}

	targetPet := gameData.Pets[targetIndex]
	logger.Info(fmt.Sprintf("[2308] 移动精灵到首发位置: UID=%d PetID=%d 从位置%d到位置0", ctx.UserID, targetPet.ID, targetIndex))

	newPets := make([]userdb.Pet, len(gameData.Pets))
	newPets[0] = targetPet
	newIndex := 1
	for i, pet := range gameData.Pets {
		if i != targetIndex {
			newPets[newIndex] = pet
			newIndex++
		}
	}
	gameData.Pets = newPets
	ctx.GameServer.UserDB.SaveGameData(ctx.UserID, gameData)

	logger.Info(fmt.Sprintf("[2308] 设置首发精灵成功: UID=%d PetID=%d CatchTime=%d", ctx.UserID, targetPet.ID, catchTime))
	ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, respBody)
}

// handleGetPetList CMD 2303 获取精灵列表（返回仓库中的精灵）
// 对齐 Lua: pet_handlers.handleGetPetList
// 响应: count(4) + [petId(4) + catchTime(4) + skinID(4)]...
func handleGetPetList(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	// 返回仓库中的精灵（不是背包）
	if user.StoragePets == nil {
		user.StoragePets = []userdb.Pet{}
	}
	pets := user.StoragePets
	count := uint32(len(pets))

	body := make([]byte, 4+int(count)*12)
	binary.BigEndian.PutUint32(body[0:4], count)
	off := 4
	for _, p := range pets {
		binary.BigEndian.PutUint32(body[off:off+4], uint32(p.ID))
		off += 4
		binary.BigEndian.PutUint32(body[off:off+4], uint32(p.CatchTime))
		off += 4
		binary.BigEndian.PutUint32(body[off:off+4], 0) // skinID = 0
		off += 4
	}

	ctx.GameServer.SendResponse(ctx.ClientData, 2303, ctx.UserID, ctx.SeqID, body[:off])
}

// ==================== 玩家对战邀请（2401/2403 -> 2501/2502） ====================

// handleInviteToFight CMD 2401 邀请玩家对战（INVITE_TO_FIGHT）
// 请求: targetUserID(4) + mode(4)，FightWaitPanel.send 发送被邀请方 userID 与对战模式(1=单挑 2=多精灵)
// 向被邀请方推送 NOTE_INVITE_TO_FIGHT(2501)，body: inviterUserID(4)+inviterNick(16)+mode(4)，供其弹窗选择接受/拒绝
func handleInviteToFight(ctx *gameserver.HandlerContext) {
	targetUserID := int64(0)
	mode := uint32(0)
	if len(ctx.Body) >= 8 {
		targetUserID = int64(binary.BigEndian.Uint32(ctx.Body[0:4]))
		mode = binary.BigEndian.Uint32(ctx.Body[4:8])
	}
	inviter := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	nick := inviter.Nick
	if nick == "" {
		nick = fmt.Sprintf("用户%d", ctx.UserID)
	}
	// 响应邀请者：简单回包（可选，客户端可能不依赖）
	bodyAck := make([]byte, 4)
	binary.BigEndian.PutUint32(bodyAck[0:4], 0)
	ctx.GameServer.SendResponse(ctx.ClientData, 2401, ctx.UserID, ctx.SeqID, bodyAck)

	targetClient := ctx.GameServer.GetClientByUserID(targetUserID)
	if targetClient == nil {
		return // 被邀请方不在线，不推送
	}
	noteBody := make([]byte, 4+16+4)
	binary.BigEndian.PutUint32(noteBody[0:4], uint32(ctx.UserID))
	putFixedString(noteBody, 4, nick, 16)
	binary.BigEndian.PutUint32(noteBody[20:24], mode)
	ctx.GameServer.SendResponse(targetClient, 2501, ctx.UserID, 0, noteBody)
}

// handleHandleFightInvite CMD 2403 接受/拒绝对战邀请（HANDLE_FIGHT_INVITE）
// 请求: inviterUserID(4) + result(4) + type(4)，result=1 接受、0 拒绝；type 为对战模式
// 向邀请方推送 NOTE_HANDLE_FIGHT_INVITE(2502)，body: responderUserID(4)+responderNick(16)+result(4)
func handleHandleFightInvite(ctx *gameserver.HandlerContext) {
	inviterUserID := int64(0)
	result := uint32(0)
	if len(ctx.Body) >= 12 {
		inviterUserID = int64(binary.BigEndian.Uint32(ctx.Body[0:4]))
		result = binary.BigEndian.Uint32(ctx.Body[4:8])
	}
	responder := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	nick := responder.Nick
	if nick == "" {
		nick = fmt.Sprintf("用户%d", ctx.UserID)
	}
	bodyAck := make([]byte, 4)
	binary.BigEndian.PutUint32(bodyAck[0:4], 0)
	ctx.GameServer.SendResponse(ctx.ClientData, 2403, ctx.UserID, ctx.SeqID, bodyAck)

	inviterClient := ctx.GameServer.GetClientByUserID(inviterUserID)
	if inviterClient == nil {
		return
	}
	noteBody := make([]byte, 4+16+4)
	binary.BigEndian.PutUint32(noteBody[0:4], uint32(ctx.UserID))
	putFixedString(noteBody, 4, nick, 16)
	binary.BigEndian.PutUint32(noteBody[20:24], result)
	ctx.GameServer.SendResponse(inviterClient, 2502, ctx.UserID, 0, noteBody)

	// 接受对战后：向双方推送 2503（准备对战）和 2504（开始对战），才能进入对战界面
	// PvP 2503 按接收方分别发送：邀请方收 [邀请方,接受方]，接受方收 [接受方,邀请方]，保证各方 userInfoArray[0]=自己，客户端用其加载“我方/对方”模型，避免双方显示同一精灵模型
	if result == 1 {
		inviterClient := ctx.GameServer.GetClientByUserID(inviterUserID)
		responderClient := ctx.ClientData
		if inviterClient != nil && responderClient != nil {
			// 2503：DLL 用 userInfoArray[0]=我方（左）、[1]=对方（右）。我方在前：邀请方收 [邀请方,接受方]、接受方收 [接受方,邀请方]
			body2503Inviter, body2503Responder := buildNoteReadyToFightInfoPvPPerClient(ctx.GameServer, inviterUserID, ctx.UserID)
			ctx.GameServer.SendResponse(inviterClient, 2503, inviterUserID, 0, body2503Inviter)
			ctx.GameServer.SendResponse(responderClient, 2503, ctx.UserID, 0, body2503Responder)
			// 2504：DLL 按包顺序“第一项→我方位、第二项→对方位”绑定 3D 模型，必须发 [我方,对方]；FightStartInfo 按 userID 区分 myInfo/otherInfo（血条/技能/日志）
			body2504Inviter, body2504Responder := buildNoteStartFightPvP(ctx.GameServer, inviterUserID, ctx.UserID)
			if len(body2504Inviter) > 0 {
				ctx.GameServer.SendResponse(inviterClient, 2504, inviterUserID, 0, body2504Inviter) // 邀请方收 [邀请方,接受方]=[我方,对方]
			}
			if len(body2504Responder) > 0 {
				ctx.GameServer.SendResponse(responderClient, 2504, ctx.UserID, 0, body2504Responder) // 接受方收 [接受方,邀请方]=[我方,对方]
			}
			// PvP 初始化双方 BattleState
			setPvPBattleStates(ctx.GameServer, inviterUserID, ctx.UserID)
			inviterPetID, responderPetID := 7, 7
			if u1 := ctx.GameServer.GetOrCreateUser(inviterUserID); len(u1.Pets) > 0 {
				inviterPetID = u1.Pets[0].ID
			}
			if u2 := ctx.GameServer.GetOrCreateUser(ctx.UserID); len(u2.Pets) > 0 {
				responderPetID = u2.Pets[0].ID
			}
			logger.Info(fmt.Sprintf("[2403] PvP 接受: UID=%d(PetID=%d) vs UID=%d(PetID=%d)，2503/2504 包序 [我方,对方]", inviterUserID, inviterPetID, ctx.UserID, responderPetID))
		}
	}
}

// setPvPBattleStates 为 PvP 双方初始化 BattleState，使 2405 有状态、战斗能正常结算并发送 2506
func setPvPBattleStates(gs *gameserver.GameServer, inviterUID, responderUID int64) {
	petMgr := gamepets.GetInstance()
	u1 := gs.GetOrCreateUser(inviterUID)
	u2 := gs.GetOrCreateUser(responderUID)
	petID1, lv1, hp1, maxHp1 := 7, 5, 0, 0
	if len(u1.Pets) > 0 {
		petID1 = u1.Pets[0].ID
		if u1.Pets[0].Level > 0 {
			lv1 = u1.Pets[0].Level
		}
		ev := gamepets.EVStats{}
		ev = u1.Pets[0].GetEVStats()
		st := petMgr.GetStats(petID1, lv1, 31, ev, 0)
		hp1, maxHp1 = st.HP, st.MaxHP
	} else {
		st := petMgr.GetStats(petID1, lv1, 31, gamepets.EVStats{}, 0)
		hp1, maxHp1 = st.HP, st.MaxHP
	}
	petID2, lv2, hp2, maxHp2 := 7, 5, 0, 0
	if len(u2.Pets) > 0 {
		petID2 = u2.Pets[0].ID
		if u2.Pets[0].Level > 0 {
			lv2 = u2.Pets[0].Level
		}
		ev := gamepets.EVStats{}
		ev = u2.Pets[0].GetEVStats()
		st := petMgr.GetStats(petID2, lv2, 31, ev, 0)
		hp2, maxHp2 = st.HP, st.MaxHP
	} else {
		st := petMgr.GetStats(petID2, lv2, 31, gamepets.EVStats{}, 0)
		hp2, maxHp2 = st.HP, st.MaxHP
	}
	if maxHp1 <= 0 {
		maxHp1 = 1
	}
	if maxHp2 <= 0 {
		maxHp2 = 1
	}
	gs.BattleMu.Lock()
	defer gs.BattleMu.Unlock()
	gs.BattleStates[inviterUID] = &gameserver.BattleState{
		PlayerHP:       uint32(hp1),
		PlayerMaxHP:    uint32(maxHp1),
		EnemyHP:        uint32(hp2),
		EnemyMaxHP:     uint32(maxHp2),
		EnemyID:        petID2,
		EnemyLevel:     lv2,
		IsActive:       true,
		OpponentUserID: responderUID,
	}
	gs.BattleStates[responderUID] = &gameserver.BattleState{
		PlayerHP:       uint32(hp2),
		PlayerMaxHP:    uint32(maxHp2),
		EnemyHP:        uint32(hp1),
		EnemyMaxHP:     uint32(maxHp1),
		EnemyID:        petID1,
		EnemyLevel:     lv1,
		IsActive:       true,
		OpponentUserID: inviterUID,
	}
}

// buildNoteReadyToFightInfoPvP 构建 PvP 的 2503 包体：userCount(4) + [FighetUserInfo(20) + petCount(4) + SimplePetInfo(72)] * 2，与 NoteReadyToFightInfo 解析一致
func buildNoteReadyToFightInfoPvP(gs *gameserver.GameServer, inviterUID, responderUID int64) []byte {
	petMgr := gamepets.GetInstance()
	skillMgr := gameskills.GetInstance()
	buildFightUserInfo := func(uid uint32, nick string) []byte {
		b := make([]byte, 20)
		binary.BigEndian.PutUint32(b[0:4], uid)
		nb := []byte(nick)
		if len(nb) > 16 {
			nb = nb[:16]
		}
		copy(b[4:20], nb)
		return b
	}
	buildSimplePetInfo := func(petID uint32, level uint32, hp uint32, maxHp uint32, catchTime uint32, skills [][2]uint32) []byte {
		b := make([]byte, 72)
		binary.BigEndian.PutUint32(b[0:4], petID)
		binary.BigEndian.PutUint32(b[4:8], level)
		binary.BigEndian.PutUint32(b[8:12], hp)
		binary.BigEndian.PutUint32(b[12:16], maxHp)
		valid := uint32(0)
		for _, s := range skills {
			if s[0] != 0 {
				valid++
			}
		}
		binary.BigEndian.PutUint32(b[16:20], valid)
		off := 20
		for i := 0; i < 4; i++ {
			var sid, pp uint32
			if i < len(skills) {
				sid, pp = skills[i][0], skills[i][1]
			}
			binary.BigEndian.PutUint32(b[off:off+4], sid)
			binary.BigEndian.PutUint32(b[off+4:off+8], pp)
			off += 8
		}
		binary.BigEndian.PutUint32(b[52:56], catchTime)
		binary.BigEndian.PutUint32(b[56:60], 0)
		binary.BigEndian.PutUint32(b[60:64], 0)
		binary.BigEndian.PutUint32(b[64:68], 0)
		binary.BigEndian.PutUint32(b[68:72], petID) // skinID：客户端用此加载精灵模型/图标，0 会导致蓝格占位
		return b
	}
	getUserFirstPet := func(uid int64) (petID int, level int, catchTime uint32, hp, maxHp int, skills [][2]uint32, nick string) {
		u := gs.GetOrCreateUser(uid)
		nick = u.Nick
		if nick == "" {
			nick = fmt.Sprintf("用户%d", uid)
		}
		petID = 7
		level = 5
		catchTime = 0x69686700 + uint32(7)
		ev := gamepets.EVStats{}
		nature := 0
		if len(u.Pets) > 0 {
			petID = u.Pets[0].ID
			if u.Pets[0].Level > 0 {
				level = u.Pets[0].Level
			}
			catchTime = uint32(u.Pets[0].CatchTime)
			nature = u.Pets[0].Nature
			ev = u.Pets[0].GetEVStats()
			if catchTime == 0 {
				catchTime = 0x69686700 + uint32(petID)
			}
		}
		stats := petMgr.GetStats(petID, level, 31, ev, nature)
		hp, maxHp = stats.HP, stats.MaxHP
		raw := petMgr.GetSkillsForLevel(petID, level)
		for _, sid := range raw {
			if sid <= 0 {
				continue
			}
			pp := uint32(20)
			if sk := skillMgr.Get(sid); sk != nil {
				if sk.PP > 0 {
					pp = uint32(sk.PP)
				} else if sk.MaxPP > 0 {
					pp = uint32(sk.MaxPP)
				}
			}
			skills = append(skills, [2]uint32{uint32(sid), pp})
			if len(skills) >= 4 {
				break
			}
		}
		if len(skills) == 0 {
			skills = append(skills, [2]uint32{10001, 20})
		}
		return
	}
	// User1: 邀请方
	petID1, lv1, ct1, hp1, maxHp1, sk1, nick1 := getUserFirstPet(inviterUID)
	// User2: 接受方
	petID2, lv2, ct2, hp2, maxHp2, sk2, nick2 := getUserFirstPet(responderUID)
	out := make([]byte, 0, 4+96*2)
	tmp4 := make([]byte, 4)
	binary.BigEndian.PutUint32(tmp4, 2)
	out = append(out, tmp4...)
	out = append(out, buildFightUserInfo(uint32(inviterUID), nick1)...)
	binary.BigEndian.PutUint32(tmp4, 1)
	out = append(out, tmp4...)
	out = append(out, buildSimplePetInfo(uint32(petID1), uint32(lv1), uint32(hp1), uint32(maxHp1), ct1, sk1)...)
	out = append(out, buildFightUserInfo(uint32(responderUID), nick2)...)
	binary.BigEndian.PutUint32(tmp4, 1)
	out = append(out, tmp4...)
	out = append(out, buildSimplePetInfo(uint32(petID2), uint32(lv2), uint32(hp2), uint32(maxHp2), ct2, sk2)...)
	return out
}

// buildNoteReadyToFightInfoPvPPerClient 构建 PvP 的 2503 包体，按接收方分别返回：邀请方收 [邀请方,接受方]，接受方收 [接受方,邀请方]
// 保证各方 userInfoArray[0]=自己，客户端用其区分“我方/对方”并加载对应精灵模型（petArray/skinID），避免双方都显示同一模型
func buildNoteReadyToFightInfoPvPPerClient(gs *gameserver.GameServer, inviterUID, responderUID int64) (inviterBody, responderBody []byte) {
	bodyInviterFirst := buildNoteReadyToFightInfoPvP(gs, inviterUID, responderUID) // [邀请方, 接受方]
	// 接受方收 [接受方, 邀请方]：交换两段 FighetUserInfo(20)+petCount(4)+SimplePetInfo(72)
	const blockSize = 20 + 4 + 72 // 96
	if len(bodyInviterFirst) < 4+blockSize*2 {
		return bodyInviterFirst, bodyInviterFirst
	}
	inviterBody = bodyInviterFirst
	responderBody = make([]byte, len(bodyInviterFirst))
	copy(responderBody[0:4], bodyInviterFirst[0:4])                                 // userCount
	copy(responderBody[4:4+blockSize], bodyInviterFirst[4+blockSize:4+blockSize*2]) // 第二块 -> 第一块
	copy(responderBody[4+blockSize:4+blockSize*2], bodyInviterFirst[4:4+blockSize]) // 第一块 -> 第二块
	// 日志：验证 2503 userInfoArray 顺序，确保各方 userInfoArray[0]=自己
	// FighetUserInfo: userID(4) + nickName(16)，userID 在每块的开头
	logger.Info(fmt.Sprintf("[2503-PvP] 邀请方(UID=%d)包: userInfoArray[0] userID=%d, userInfoArray[1] userID=%d",
		inviterUID,
		binary.BigEndian.Uint32(inviterBody[4:8]), binary.BigEndian.Uint32(inviterBody[4+blockSize:4+blockSize+4])))
	logger.Info(fmt.Sprintf("[2503-PvP] 接受方(UID=%d)包: userInfoArray[0] userID=%d, userInfoArray[1] userID=%d",
		responderUID,
		binary.BigEndian.Uint32(responderBody[4:8]), binary.BigEndian.Uint32(responderBody[4+blockSize:4+blockSize+4])))
	return inviterBody, responderBody
}

// buildNoteStartFightPvP 构建 PvP 的 2504 包体：isCanAuto(4) + FightPetInfo(50)*2；首条为当前客户端的“我方”精灵，与 FightStartInfo 解析一致
// 返回 (inviter 的 2504 body, responder 的 2504 body)
func buildNoteStartFightPvP(gs *gameserver.GameServer, inviterUID, responderUID int64) (inviterBody, responderBody []byte) {
	petMgr := gamepets.GetInstance()
	// FightPetInfo 固定 50 字节，与客户端 FightPetInfo.as 解析一致：userID(4)+petID(4)+petName(16)+catchTime(4)+hp(4)+maxHP(4)+lv(4)+catchable(4)+battleLv(6)
	const fightPetInfoSize = 50
	buildFightPetInfo := func(uid uint32, petID int, name string, ct uint32, hp, maxHp, lv int, catchable uint32) []byte {
		if petID <= 0 {
			petID = 7
		}
		if maxHp <= 0 {
			maxHp = 1
		}
		if hp < 0 {
			hp = 0
		}
		if hp > maxHp {
			hp = maxHp
		}
		buf := make([]byte, fightPetInfoSize)
		binary.BigEndian.PutUint32(buf[0:4], uid)
		binary.BigEndian.PutUint32(buf[4:8], uint32(petID))
		nb := []byte(name)
		if len(nb) > 16 {
			nb = nb[:16]
		}
		copy(buf[8:24], nb) // 未写满的字节保持为 0
		binary.BigEndian.PutUint32(buf[24:28], ct)
		binary.BigEndian.PutUint32(buf[28:32], uint32(hp))
		binary.BigEndian.PutUint32(buf[32:36], uint32(maxHp))
		binary.BigEndian.PutUint32(buf[36:40], uint32(lv))
		binary.BigEndian.PutUint32(buf[40:44], catchable)
		for i := 44; i < 50; i++ {
			buf[i] = 0
		}
		return buf
	}
	u1 := gs.GetOrCreateUser(inviterUID)
	u2 := gs.GetOrCreateUser(responderUID)
	petID1, lv1, ct1, hp1, maxHp1 := 7, 5, uint32(0), 0, 0
	if len(u1.Pets) > 0 {
		petID1 = u1.Pets[0].ID
		if u1.Pets[0].Level > 0 {
			lv1 = u1.Pets[0].Level
		}
		ct1 = uint32(u1.Pets[0].CatchTime)
		if ct1 == 0 {
			ct1 = 0x69686700 + uint32(petID1)
		}
	}
	ev1 := gamepets.EVStats{}
	if len(u1.Pets) > 0 {
		ev1 = u1.Pets[0].GetEVStats()
	}
	st1 := petMgr.GetStats(petID1, lv1, 31, ev1, 0)
	hp1, maxHp1 = st1.HP, st1.MaxHP
	name1 := petMgr.GetName(petID1)
	if name1 == "" {
		name1 = "精灵"
	}
	petID2, lv2, ct2, hp2, maxHp2 := 7, 5, uint32(0), 0, 0
	if len(u2.Pets) > 0 {
		petID2 = u2.Pets[0].ID
		if u2.Pets[0].Level > 0 {
			lv2 = u2.Pets[0].Level
		}
		ct2 = uint32(u2.Pets[0].CatchTime)
		if ct2 == 0 {
			ct2 = 0x69686700 + uint32(petID2)
		}
	}
	ev2 := gamepets.EVStats{}
	if len(u2.Pets) > 0 {
		ev2 = u2.Pets[0].GetEVStats()
	}
	st2 := petMgr.GetStats(petID2, lv2, 31, ev2, 0)
	hp2, maxHp2 = st2.HP, st2.MaxHP
	name2 := petMgr.GetName(petID2)
	if name2 == "" {
		name2 = "精灵"
	}
	info1 := buildFightPetInfo(uint32(inviterUID), petID1, name1, ct1, hp1, maxHp1, lv1, 0)
	info2 := buildFightPetInfo(uint32(responderUID), petID2, name2, ct2, hp2, maxHp2, lv2, 0)
	// 客户端 FightStartInfo 按首条 userID==MainManager.actorInfo.userID 区分 myInfo/otherInfo；包内顺序 [我方,对方]
	inviterBody = make([]byte, 4+len(info1)+len(info2))
	binary.BigEndian.PutUint32(inviterBody[0:4], 0)
	copy(inviterBody[4:4+len(info1)], info1)
	copy(inviterBody[4+len(info1):], info2)
	responderBody = make([]byte, 4+len(info1)+len(info2))
	binary.BigEndian.PutUint32(responderBody[0:4], 0)
	copy(responderBody[4:4+len(info2)], info2)
	copy(responderBody[4+len(info2):], info1)
	// 日志：验证两段 FightPetInfo 的 userID/petID 不同，便于排查“两边都显示对方模型”
	// 注意：客户端 FightStartInfo 用 actorInfo.userID 区分 myInfo/otherInfo，FighterModeFactory 用 actorID 区分 PlayerMode/EnemyMode
	// 若两者不一致，可能导致 myInfo 被误判为 EnemyMode，出现"两边都显示对方模型"
	inviterFirstUID := binary.BigEndian.Uint32(inviterBody[4:8])
	inviterFirstPetID := binary.BigEndian.Uint32(inviterBody[8:12])
	inviterSecondUID := binary.BigEndian.Uint32(inviterBody[54:58])
	inviterSecondPetID := binary.BigEndian.Uint32(inviterBody[58:62])
	responderFirstUID := binary.BigEndian.Uint32(responderBody[4:8])
	responderFirstPetID := binary.BigEndian.Uint32(responderBody[8:12])
	responderSecondUID := binary.BigEndian.Uint32(responderBody[54:58])
	responderSecondPetID := binary.BigEndian.Uint32(responderBody[58:62])

	// 验证：第一条 userID 必须等于接收方 userID
	if inviterFirstUID != uint32(inviterUID) {
		logger.Warning(fmt.Sprintf("[2504-PvP] ⚠️ 邀请方包第1段 userID(%d) != 接收方UID(%d)，可能导致客户端识别错误！", inviterFirstUID, inviterUID))
	}
	if responderFirstUID != uint32(responderUID) {
		logger.Warning(fmt.Sprintf("[2504-PvP] ⚠️ 接受方包第1段 userID(%d) != 接收方UID(%d)，可能导致客户端识别错误！", responderFirstUID, responderUID))
	}

	logger.Info(fmt.Sprintf("[2504-PvP] 邀请方(UID=%d)包: 第1段 userID=%d petID=%d(name=%s), 第2段 userID=%d petID=%d(name=%s)",
		inviterUID, inviterFirstUID, inviterFirstPetID, name1, inviterSecondUID, inviterSecondPetID, name2))
	logger.Info(fmt.Sprintf("[2504-PvP] 接受方(UID=%d)包: 第1段 userID=%d petID=%d(name=%s), 第2段 userID=%d petID=%d(name=%s)",
		responderUID, responderFirstUID, responderFirstPetID, name2, responderSecondUID, responderSecondPetID, name1))
	return
}

// buildPvP2504BodyForUser 为 PvP 下 2404 构建当前用户的 2504 包体：我方 FightPetInfo + 对方 FightPetInfo（不修改 BattleState）
func buildPvP2504BodyForUser(gs *gameserver.GameServer, myUID, opponentUID int64, battle *gameserver.BattleState) []byte {
	petMgr := gamepets.GetInstance()
	const fightPetInfoSize = 50
	buildFightPetInfo := func(uid uint32, petID int, name string, ct uint32, hp, maxHp, lv int, catchable uint32) []byte {
		if petID <= 0 {
			petID = 7
		}
		if maxHp <= 0 {
			maxHp = 1
		}
		if hp < 0 {
			hp = 0
		}
		if hp > maxHp {
			hp = maxHp
		}
		buf := make([]byte, fightPetInfoSize)
		binary.BigEndian.PutUint32(buf[0:4], uid)
		binary.BigEndian.PutUint32(buf[4:8], uint32(petID))
		nb := []byte(name)
		if len(nb) > 16 {
			nb = nb[:16]
		}
		copy(buf[8:24], nb)
		binary.BigEndian.PutUint32(buf[24:28], ct)
		binary.BigEndian.PutUint32(buf[28:32], uint32(hp))
		binary.BigEndian.PutUint32(buf[32:36], uint32(maxHp))
		binary.BigEndian.PutUint32(buf[36:40], uint32(lv))
		binary.BigEndian.PutUint32(buf[40:44], catchable)
		for i := 44; i < 50; i++ {
			buf[i] = 0
		}
		return buf
	}
	// 我方：当前用户
	uMe := gs.GetOrCreateUser(myUID)
	petID1, lv1, ct1, hp1, maxHp1 := 7, 5, uint32(0), int(battle.PlayerHP), int(battle.PlayerMaxHP)
	if len(uMe.Pets) > 0 {
		petID1 = uMe.Pets[0].ID
		if uMe.Pets[0].Level > 0 {
			lv1 = uMe.Pets[0].Level
		}
		ct1 = uint32(uMe.Pets[0].CatchTime)
		if ct1 == 0 {
			ct1 = 0x69686700 + uint32(petID1)
		}
	}
	name1 := petMgr.GetName(petID1)
	if name1 == "" {
		name1 = "精灵"
	}
	// 对方：对手
	uOpp := gs.GetOrCreateUser(opponentUID)
	petID2, lv2, ct2 := battle.EnemyID, battle.EnemyLevel, uint32(0)
	hp2, maxHp2 := int(battle.EnemyHP), int(battle.EnemyMaxHP)
	if len(uOpp.Pets) > 0 {
		ct2 = uint32(uOpp.Pets[0].CatchTime)
		if ct2 == 0 {
			ct2 = 0x69686700 + uint32(petID2)
		}
	}
	name2 := petMgr.GetName(petID2)
	if name2 == "" {
		name2 = "精灵"
	}
	info1 := buildFightPetInfo(uint32(myUID), petID1, name1, ct1, hp1, maxHp1, lv1, 0)
	info2 := buildFightPetInfo(uint32(opponentUID), petID2, name2, ct2, hp2, maxHp2, lv2, 0)
	// 与 2403 推送的 2504 一致：包内顺序 [我方,对方]
	out := make([]byte, 4+len(info1)+len(info2))
	binary.BigEndian.PutUint32(out[0:4], 0)
	copy(out[4:4+len(info1)], info1)
	copy(out[4+len(info1):], info2)
	// 确保第1段 userID 始终为接收方(myUID)，第2段为对方(opponentUID)，便于客户端正确识别"我方/对方"
	firstUID := binary.BigEndian.Uint32(out[4:8])
	firstPetID := binary.BigEndian.Uint32(out[8:12])
	secondUID := binary.BigEndian.Uint32(out[54:58])
	secondPetID := binary.BigEndian.Uint32(out[58:62])

	// 验证：第一条 userID 必须等于接收方 userID
	if firstUID != uint32(myUID) {
		logger.Warning(fmt.Sprintf("[2504-2404] ⚠️ 包第1段 userID(%d) != 接收方UID(%d)，可能导致客户端识别错误！", firstUID, myUID))
	}

	logger.Info(fmt.Sprintf("[2504-2404] UID=%d 包体: 第1段 userID=%d petID=%d(name=%s), 第2段 userID=%d petID=%d(name=%s)",
		myUID, firstUID, firstPetID, name1, secondUID, secondPetID, name2))
	return out
}

// ==================== 新手战斗（2411 -> 2503） ====================

// 克洛斯星密林(12) SPT/脚本战斗：客户端 fightWithBoss 第二个参数 0=蘑菇怪(47)、1=依依(83)
const (
	mapIDKlothForest  = 12
	petIDMushroomBoss = 47 // 蘑菇怪 SPTBOSS
	petIDYiyi         = 83 // 依依（密林脚本 NPC）
)

// handleChallengeBoss CMD 2411 挑战BOSS（新手战斗触发 / SPT / 地图脚本 BOSS）
// 客户端 FightInviteManager.fightWithBoss(name, param2)：只发送 param2(4)，不发送名字。
// 全地图 SPT 按 sptboss 配置：(mapID, param2) → bossPetID、等级；未配置时 body 可为 bossID 或默认 13。
func handleChallengeBoss(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	mapID := user.MapID
	if mapID == 0 {
		mapID = 1
	}

	bossID := uint32(13)
	enemyLevel := 5

	param2 := uint32(0)
	if len(ctx.Body) >= 4 {
		param2 = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	logger.Info(fmt.Sprintf("[2411] 收到挑战BOSS请求: mapID=%d param2=%d bodyLen=%d", mapID, param2, len(ctx.Body)))

	if e, ok := sptboss.GetByMapAndParam(mapID, param2); ok {
		bossID = uint32(e.BossPetID)
		enemyLevel = e.Level
		logger.Info(fmt.Sprintf("[2411] 从SPT配置获取BOSS: mapID=%d param2=%d -> bossID=%d level=%d", mapID, param2, bossID, enemyLevel))
	} else if e, ok := sptboss.GetByMapAndParam(mapID, 0); ok {
		// 该地图在 SPT 中但 param2 不匹配（如客户端误传 param2=1）：按单 BOSS 地图回退到 param2=0，避免把 param2 当 bossID 导致变成布布种子等
		bossID = uint32(e.BossPetID)
		enemyLevel = e.Level
		logger.Info(fmt.Sprintf("[2411] SPT param2 未命中，回退到 mapID=%d param2=0 -> bossID=%d level=%d", mapID, bossID, enemyLevel))
	} else {
		logger.Info(fmt.Sprintf("[2411] SPT配置未找到: mapID=%d param2=%d，尝试从body读取", mapID, param2))
		if len(ctx.Body) >= 4 {
			// 兼容：body 直接传 bossID（如从 SPT 面板发起时）
			if v := binary.BigEndian.Uint32(ctx.Body[0:4]); v != 0 {
				bossID = v
				enemyLevel = 50
				logger.Info(fmt.Sprintf("[2411] 从body读取BOSS ID: bossID=%d", bossID))
			}
		}
	}

	// 写入 BattleStates，供 2503/2504 使用正确的敌方等级
	ctx.GameServer.BattleMu.Lock()
	battle, ok := ctx.GameServer.BattleStates[ctx.UserID]
	if !ok || battle == nil {
		battle = &gameserver.BattleState{}
	}
	battle.EnemyID = int(bossID)
	battle.EnemyLevel = enemyLevel
	battle.IsActive = true
	ctx.GameServer.BattleStates[ctx.UserID] = battle
	ctx.GameServer.BattleMu.Unlock()

	body := buildNoteReadyToFightInfo(ctx, bossID)
	ctx.GameServer.SendResponse(ctx.ClientData, 2503, ctx.UserID, 0, body)
}

// buildNoteReadyToFightInfo 构建 2503 回包（最小可用版本）
// body: userCount(4) + [FighetUserInfo(20) + petCount(4) + SimplePetInfo] * 2
// 客户端用 2503 的 petArray（来自 SimplePetInfo 的 petId）预加载对战模型，petID 必须与 2504 一致且非 0
func buildNoteReadyToFightInfo(ctx *gameserver.HandlerContext, enemyID uint32) []byte {
	if enemyID == 0 {
		enemyID = 13
	}
	userID := uint32(ctx.UserID)
	petMgr := gamepets.GetInstance()
	skillMgr := gameskills.GetInstance()

	// 玩家使用实际第一只出战精灵，与 2504 一致，否则客户端预加载错误模型导致对战无模型
	playerPetID := 7
	playerLevel := 5
	playerCatch := uint32(0x69686700 + uint32(playerPetID))
	playerNature := 0
	playerEV := gamepets.EVStats{}
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if len(user.Pets) > 0 {
		playerPetID = user.Pets[0].ID
		if user.Pets[0].Level > 0 {
			playerLevel = user.Pets[0].Level
		}
		playerCatch = uint32(user.Pets[0].CatchTime)
		playerNature = user.Pets[0].Nature
		playerEV = user.Pets[0].GetEVStats()
	}
	if playerCatch == 0 {
		playerCatch = 0x69686700 + uint32(playerPetID)
	}
	logger.Info(fmt.Sprintf("[2503] NoteReadyToFight: playerPetID=%d playerLevel=%d enemyID=%d (与2504一致才能正确显示对战)", playerPetID, playerLevel, enemyID))

	playerStats := petMgr.GetStats(playerPetID, playerLevel, 31, playerEV, playerNature)
	playerSkillsRaw := petMgr.GetSkillsForLevel(playerPetID, playerLevel)
	playerSkills := make([][2]uint32, 0, 4)
	for _, sid := range playerSkillsRaw {
		if sid <= 0 {
			continue
		}
		pp := uint32(20)
		if sk := skillMgr.Get(sid); sk != nil {
			if sk.PP > 0 {
				pp = uint32(sk.PP)
			} else if sk.MaxPP > 0 {
				pp = uint32(sk.MaxPP)
			}
		}
		playerSkills = append(playerSkills, [2]uint32{uint32(sid), pp})
		if len(playerSkills) >= 4 {
			break
		}
	}
	if len(playerSkills) == 0 {
		playerSkills = append(playerSkills, [2]uint32{10001, 20})
	}

	// 敌人属性（敌人默认性格0，EV 为 0）；2411 已写入 BattleStates.EnemyLevel（如密林蘑菇怪10级、依依5级）
	enemyLevel := 5
	ctx.GameServer.BattleMu.RLock()
	if battle, ok := ctx.GameServer.BattleStates[ctx.UserID]; ok && battle.IsActive && battle.EnemyLevel > 0 {
		enemyLevel = battle.EnemyLevel
	}
	ctx.GameServer.BattleMu.RUnlock()
	enemyEV := gamepets.EVStats{} // 敌人 EV 默认为 0
	enemyStats := petMgr.GetStats(int(enemyID), enemyLevel, 15, enemyEV, 0)
	// 地图 BOSS 使用固定血量（只影响敌方战斗体力，不改种族值与玩家拥有的同名精灵）
	enemyStats.HP = applyBossHPOverride(int(enemyID), enemyStats.HP)
	enemyStats.MaxHP = applyBossHPOverride(int(enemyID), enemyStats.MaxHP)
	enemySkillsRaw := petMgr.GetSkillsForLevel(int(enemyID), enemyLevel)
	enemySkills := make([][2]uint32, 0, 4)
	for _, sid := range enemySkillsRaw {
		if sid <= 0 {
			continue
		}
		pp := uint32(20)
		if sk := skillMgr.Get(sid); sk != nil {
			if sk.PP > 0 {
				pp = uint32(sk.PP)
			} else if sk.MaxPP > 0 {
				pp = uint32(sk.MaxPP)
			}
		}
		enemySkills = append(enemySkills, [2]uint32{uint32(sid), pp})
		if len(enemySkills) >= 4 {
			break
		}
	}
	if len(enemySkills) == 0 {
		enemySkills = append(enemySkills, [2]uint32{10001, 20})
	}

	buildFightUserInfo := func(uid uint32, nick string) []byte {
		b := make([]byte, 20)
		binary.BigEndian.PutUint32(b[0:4], uid)
		nb := []byte(nick)
		if len(nb) > 16 {
			nb = nb[:16]
		}
		copy(b[4:20], nb)
		return b
	}

	buildSimplePetInfo := func(petID uint32, level uint32, hp uint32, maxHp uint32, catchTime uint32, skills [][2]uint32) []byte {
		// 结构对齐 Lua buildSimplePetInfo:
		// petId(4)+level(4)+hp(4)+maxHp(4)+skillNum(4)+[id(4)+pp(4)]*4+catchTime(4)+catchMap(4)+catchRect(4)+catchLevel(4)+skinID(4)
		b := make([]byte, 72)
		binary.BigEndian.PutUint32(b[0:4], petID)
		binary.BigEndian.PutUint32(b[4:8], level)
		binary.BigEndian.PutUint32(b[8:12], hp)
		binary.BigEndian.PutUint32(b[12:16], maxHp)
		// skillNum = 有效技能数
		valid := uint32(0)
		for _, s := range skills {
			if s[0] != 0 {
				valid++
			}
		}
		binary.BigEndian.PutUint32(b[16:20], valid)
		off := 20
		for i := 0; i < 4; i++ {
			var sid, pp uint32
			if i < len(skills) {
				sid, pp = skills[i][0], skills[i][1]
			}
			binary.BigEndian.PutUint32(b[off:off+4], sid)
			binary.BigEndian.PutUint32(b[off+4:off+8], pp)
			off += 8
		}
		binary.BigEndian.PutUint32(b[52:56], catchTime)
		binary.BigEndian.PutUint32(b[56:60], 0) // catchMap = 0（Lua 注释：官服为0）
		binary.BigEndian.PutUint32(b[60:64], 0) // catchRect
		binary.BigEndian.PutUint32(b[64:68], 0) // catchLevel = 0（官服为0）
		binary.BigEndian.PutUint32(b[68:72], 0) // skinID
		return b
	}

	// 拼装 body
	// CRITICAL FIX: 发送玩家所有精灵的信息，而不仅仅是第一只
	// 这样 _petInfoMap 中会包含所有精灵，切换时不会出现空指针异常
	playerPetCount := len(user.Pets)
	if playerPetCount == 0 {
		playerPetCount = 1 // 至少发送一只默认精灵
	}
	out := make([]byte, 0, 4+20+4+72*playerPetCount+20+4+72)
	tmp4 := make([]byte, 4)
	binary.BigEndian.PutUint32(tmp4, 2)
	out = append(out, tmp4...)

	// Player - 发送所有精灵
	out = append(out, buildFightUserInfo(userID, "Seer")...)
	binary.BigEndian.PutUint32(tmp4, uint32(playerPetCount))
	out = append(out, tmp4...)

	if len(user.Pets) > 0 {
		for _, pet := range user.Pets {
			petID := pet.ID
			if petID <= 0 {
				petID = 7
			}
			petLevel := pet.Level
			if petLevel <= 0 {
				petLevel = 5
			}
			petCatch := uint32(pet.CatchTime)
			if petCatch == 0 {
				petCatch = 0x69686700 + uint32(petID)
			}
			petEV := pet.GetEVStats()
			petStats := petMgr.GetStats(petID, petLevel, pet.DV, petEV, pet.Nature)

			// 获取精灵技能
			var petSkillsRaw []int
			if len(pet.Skills) > 0 {
				petSkillsRaw = pet.Skills
			} else {
				petSkillsRaw = petMgr.GetSkillsForLevel(petID, petLevel)
			}
			petSkills := make([][2]uint32, 0, 4)
			for _, sid := range petSkillsRaw {
				if sid <= 0 {
					continue
				}
				pp := uint32(20)
				if sk := skillMgr.Get(sid); sk != nil {
					if sk.PP > 0 {
						pp = uint32(sk.PP)
					} else if sk.MaxPP > 0 {
						pp = uint32(sk.MaxPP)
					}
				}
				petSkills = append(petSkills, [2]uint32{uint32(sid), pp})
				if len(petSkills) >= 4 {
					break
				}
			}
			if len(petSkills) == 0 {
				petSkills = append(petSkills, [2]uint32{10001, 20})
			}

			out = append(out, buildSimplePetInfo(uint32(petID), uint32(petLevel), uint32(petStats.HP), uint32(petStats.MaxHP), petCatch, petSkills)...)
		}
	} else {
		// 没有精灵时发送默认精灵
		out = append(out, buildSimplePetInfo(uint32(playerPetID), uint32(playerLevel), uint32(playerStats.HP), uint32(playerStats.MaxHP), playerCatch, playerSkills)...)
	}

	// Enemy
	out = append(out, buildFightUserInfo(0, "")...)
	binary.BigEndian.PutUint32(tmp4, 1)
	out = append(out, tmp4...)
	out = append(out, buildSimplePetInfo(enemyID, uint32(enemyLevel), uint32(enemyStats.HP), uint32(enemyStats.MaxHP), 0, enemySkills)...)

	logger.Info(fmt.Sprintf("[2503] NoteReadyToFight: 发送玩家精灵数=%d 敌人ID=%d", playerPetCount, enemyID))
	return out
}

// ==================== READY_TO_FIGHT (2404) ====================

// handleReadyToFight CMD 2404 战斗初始化
// 对齐 Lua: fight_handlers.handleReadyToFight
// PvP：若已有 BattleState 且 OpponentUserID != 0，仅回 2504（我方/对方顺序）+ 2301，不覆盖状态，否则 2505/2506 无法发给对方。
// PvE：在服务端记录战斗状态，向客户端发送 2504 + 2301。
func handleReadyToFight(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	// PvP 已由 2403 推送 2503+2504 并 setPvPBattleStates；客户端仍会发 2404 确认。此时不可覆盖 BattleState，否则 OpponentUserID 丢失，2505/2506 无法发给对方。
	ctx.GameServer.BattleMu.RLock()
	battle, pvpExists := ctx.GameServer.BattleStates[ctx.UserID]
	if pvpExists && battle.IsActive && battle.OpponentUserID != 0 {
		opponentUID := battle.OpponentUserID
		ctx.GameServer.BattleMu.RUnlock()
		// 仅回 2504（我方第一条、对方第二条）+ 2301，不写 BattleState
		body2504 := buildPvP2504BodyForUser(ctx.GameServer, ctx.UserID, opponentUID, battle)
		if len(body2504) > 0 {
			ctx.GameServer.SendResponse(ctx.ClientData, 2504, ctx.UserID, ctx.SeqID, body2504)
		}
		if len(user.Pets) > 0 {
			petInfoBody := buildFullPetInfo(user.Pets[0])
			ctx.GameServer.SendResponse(ctx.ClientData, 2301, ctx.UserID, ctx.SeqID, petInfoBody)
		}
		logger.Info(fmt.Sprintf("[2404] PvP 已就绪: UID=%d 仅回 2504+2301，不覆盖 BattleState", ctx.UserID))
		return
	}
	ctx.GameServer.BattleMu.RUnlock()

	// 选择玩家出战精灵：优先第一只
	playerPetID := 7
	playerLevel := 5
	var catchTime uint32
	if len(user.Pets) > 0 {
		playerPetID = user.Pets[0].ID
		if user.Pets[0].Level > 0 {
			playerLevel = user.Pets[0].Level
		}
		catchTime = uint32(user.Pets[0].CatchTime)
	}
	if catchTime == 0 {
		catchTime = 0x69686700 + uint32(playerPetID)
	}

	// 玩家属性（获取玩家精灵的性格，默认0）
	petMgr := gamepets.GetInstance()
	playerNature := 0
	playerEV := gamepets.EVStats{}
	if len(user.Pets) > 0 {
		playerNature = user.Pets[0].Nature
		playerEV = user.Pets[0].GetEVStats()
	}
	playerStats := petMgr.GetStats(playerPetID, playerLevel, 31, playerEV, playerNature)

	// 敌人 ID/等级：优先取上一次 2408 战斗初始化时记录在 BattleStates 里的 EnemyID，
	// 如果还没有（例如新手 2411 战斗），则回退到默认比比鼠。
	bossID := uint32(13)
	enemyLevel := 5
	enemyEV := gamepets.EVStats{} // 敌人 EV 默认为 0

	ctx.GameServer.BattleMu.RLock()
	if battle, ok := ctx.GameServer.BattleStates[ctx.UserID]; ok && battle.IsActive && battle.EnemyID > 0 {
		bossID = uint32(battle.EnemyID)
		if battle.EnemyLevel > 0 {
			enemyLevel = battle.EnemyLevel
		}
	}
	ctx.GameServer.BattleMu.RUnlock()

	// 兜底：若客户端未先发 2411/2408（或 BattleState 未写入），在“有地图 BOSS 配置”的地图上自动选择该地图默认 BOSS（param2=0）
	// 典型场景：哈莫雷特等 SPT BOSS 地图，客户端直接发 2404，导致落到默认比比鼠(13)。
	mapID := user.MapID
	if mapID == 0 {
		mapID = 1
	}
	if bossID == 13 {
		if e, ok := sptboss.GetByMapAndParam(mapID, 0); ok && e.BossPetID > 0 {
			bossID = uint32(e.BossPetID)
			enemyLevel = e.Level
			logger.Info(fmt.Sprintf("[2404] 未找到 BattleState 敌人信息，回退到地图BOSS: mapID=%d param2=0 -> bossID=%d level=%d", mapID, bossID, enemyLevel))
		}
	}

	// 确保敌方 petID 非 0，否则客户端无法加载模型（PetAssetsManager 依赖非零 ID）
	if bossID == 0 {
		bossID = 13
	}
	enemyStats := petMgr.GetStats(int(bossID), enemyLevel, 15, enemyEV, 0)

	// 地图 BOSS 固定血量：只影响敌方战斗体力，不改种族值与玩家拥有的同名精灵
	enemyStats.HP = applyBossHPOverride(int(bossID), enemyStats.HP)
	enemyStats.MaxHP = applyBossHPOverride(int(bossID), enemyStats.MaxHP)

	// 特殊：克洛斯星 BOSS 闪光波克尔（mapID=10, petID=166）固定血量 2000（沿用原逻辑）
	if int(bossID) == 166 && user.MapID == 10 {
		enemyStats.HP = 2000
		enemyStats.MaxHP = 2000
	}

	// SPTBOSS 开局自带强化：攻击等级 +2（仅强化不影响弱化）
	// 这里同时写入 2504 的 battleLv 和 BattleState.EnemyBattleLv，保证客户端显示与服务端计算一致。
	initialEnemyBattleLv := [6]int8{}
	if _, ok := sptboss.GetByPetID(int(bossID)); ok {
		initialEnemyBattleLv[0] = 2
	}

	// FightPetInfo: userID(4)+petID(4)+petName(16)+catchTime(4)+hp(4)+maxHP(4)+lv(4)+catchable(4)+battleLv(6)
	// 客户端用 petID 从 PetAssetsManager.getAssetsByID(petID) 取对战模型，petID 必须与 2503 中一致且非 0
	buildFightPetInfo := func(uid uint32, petID int, name string, ct uint32, hp, maxHP, lv int, catchable uint32, battleLv [6]int8) []byte {
		if petID <= 0 {
			petID = 7
		}
		if maxHP <= 0 {
			maxHP = 1
		}
		if hp < 0 {
			hp = 0
		}
		if hp > maxHP {
			hp = maxHP
		}
		buf := make([]byte, 4+4+16+4+4+4+4+4+6)
		off := 0
		binary.BigEndian.PutUint32(buf[off:off+4], uid)
		off += 4
		binary.BigEndian.PutUint32(buf[off:off+4], uint32(petID))
		off += 4
		nb := []byte(name)
		if len(nb) > 16 {
			nb = nb[:16]
		}
		copy(buf[off:off+16], nb)
		off += 16
		binary.BigEndian.PutUint32(buf[off:off+4], ct)
		off += 4
		binary.BigEndian.PutUint32(buf[off:off+4], uint32(hp))
		off += 4
		binary.BigEndian.PutUint32(buf[off:off+4], uint32(maxHP))
		off += 4
		binary.BigEndian.PutUint32(buf[off:off+4], uint32(lv))
		off += 4
		binary.BigEndian.PutUint32(buf[off:off+4], catchable)
		off += 4
		for i := 0; i < 6; i++ {
			buf[off+i] = byte(uint8(battleLv[i]))
		}
		off += 6
		return buf[:off]
	}

	// 使用 gamepets 中的精灵中文名，便于客户端显示；客户端也会用 petID 加载模型
	playerName := petMgr.GetName(playerPetID)
	if playerName == "" {
		playerName = "精灵"
	}
	enemyName := petMgr.GetName(int(bossID))
	if enemyName == "" {
		enemyName = "野生精灵"
	}

	playerInfo := buildFightPetInfo(uint32(ctx.UserID), playerPetID, playerName, catchTime, playerStats.HP, playerStats.MaxHP, playerLevel, 0, [6]int8{})
	enemyInfo := buildFightPetInfo(0, int(bossID), enemyName, 0, enemyStats.HP, enemyStats.MaxHP, enemyLevel, 1, initialEnemyBattleLv)

	body := make([]byte, 4+len(playerInfo)+len(enemyInfo))
	binary.BigEndian.PutUint32(body[0:4], 0) // isCanAuto = 0
	copy(body[4:4+len(playerInfo)], playerInfo)
	copy(body[4+len(playerInfo):], enemyInfo)

	ctx.GameServer.SendResponse(ctx.ClientData, 2504, ctx.UserID, ctx.SeqID, body)

	// 初始化战斗状态
	ctx.GameServer.BattleMu.Lock()
	battleState := &gameserver.BattleState{
		EnemyHP:        uint32(enemyStats.HP),
		EnemyMaxHP:     uint32(enemyStats.MaxHP),
		PlayerHP:       uint32(playerStats.HP),
		PlayerMaxHP:    uint32(playerStats.MaxHP),
		EnemyID:        int(bossID),
		EnemyLevel:     enemyLevel,
		ActivePetIndex: 0,
		IsActive:       true,
		EnemyBattleLv:  initialEnemyBattleLv,
	}
	ctx.GameServer.BattleStates[ctx.UserID] = battleState
	ctx.GameServer.BattleMu.Unlock()
	logger.Info(fmt.Sprintf("[2404] 战斗状态初始化: PlayerHP=%d/%d EnemyHP=%d/%d EnemyID=%d EnemyLevel=%d",
		battleState.PlayerHP, battleState.PlayerMaxHP, battleState.EnemyHP, battleState.EnemyMaxHP, battleState.EnemyID, battleState.EnemyLevel))

	// 对齐 Lua：确保客户端 PetManager 有当前精灵信息（技能面板依赖）
	// 发送完整宠物信息（2301），这样客户端才能显示技能列表
	if len(user.Pets) > 0 {
		petInfoBody := buildFullPetInfo(user.Pets[0])
		ctx.GameServer.SendResponse(ctx.ClientData, 2301, ctx.UserID, ctx.SeqID, petInfoBody)
	}
}

// ==================== FIGHT_NPC_MONSTER (2408) ====================

// handleFightNpcMonster CMD 2408 地图野怪战斗
// 对齐 Lua: fight_handlers.handleFightNpcMonster
// 请求体: monsterSlot(4) — 槽位 0~8，客户端点哪只怪就发哪一格
// 行为: 根据当前地图与槽位，选出一个怪物ID，然后调用 buildNoteReadyToFightInfo 回推 2503。
func handleFightNpcMonster(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	// 解析请求中的槽位索引
	var slotIndex int
	if len(ctx.Body) >= 4 {
		slotIndex = int(binary.BigEndian.Uint32(ctx.Body[0:4]))
	}

	mapID := user.MapID
	if mapID == 0 {
		mapID = 1
	}

	// 重要：确保使用与地图显示相同的精灵列表
	// 使用缓存的槽位，确保对战精灵与地图显示一致
	slots := gameogres.GetCachedSlots(mapID)
	enemyID := 0
	enemyLevel := 5

	// 验证槽位索引的有效性
	if slotIndex < 0 || slotIndex >= len(slots) {
		logger.Error(fmt.Sprintf("[2408] 无效的槽位索引: mapID=%d slotIndex=%d slotsCount=%d", mapID, slotIndex, len(slots)))
		// 使用第一个有效的精灵作为回退
		for i, s := range slots {
			if s.PetID > 0 {
				slotIndex = i
				break
			}
		}
	}

	// 按槽位取怪物ID与等级
	if slotIndex >= 0 && slotIndex < len(slots) && slots[slotIndex].PetID > 0 {
		enemyID = slots[slotIndex].PetID
		if slots[slotIndex].Level > 0 {
			enemyLevel = slots[slotIndex].Level
		}
		logger.Info(fmt.Sprintf("[2408] 使用槽位 %d 的精灵: PetID=%d Level=%d Shiny=%v", slotIndex, enemyID, enemyLevel, slots[slotIndex].Shiny))
	} else {
		// 如果指定槽位无效，找第一个有效的槽位
		for i, s := range slots {
			if s.PetID > 0 {
				enemyID = s.PetID
				if s.Level > 0 {
					enemyLevel = s.Level
				}
				logger.Info(fmt.Sprintf("[2408] 回退到槽位 %d 的精灵: PetID=%d Level=%d", i, enemyID, enemyLevel))
				break
			}
		}
	}

	if enemyID == 0 {
		// 回退到新手 BOSS（比比鼠），避免客户端卡死
		enemyID = 13
		enemyLevel = 5
		logger.Warning(fmt.Sprintf("[2408] 未找到有效精灵，回退到比比鼠: mapID=%d", mapID))
	}

	// 预先在 BattleStates 中记录这次点击对应的敌人ID/等级，
	// 方便后续 2404 READY_TO_FIGHT 使用同一个敌人（对齐 Lua: getOgresForMap → FIGHT_NPC_MONSTER）。
	ctx.GameServer.BattleMu.Lock()
	battle, ok := ctx.GameServer.BattleStates[ctx.UserID]
	if !ok || battle == nil {
		battle = &gameserver.BattleState{}
	}
	battle.EnemyID = enemyID
	battle.EnemyLevel = enemyLevel
	battle.IsActive = true
	ctx.GameServer.BattleStates[ctx.UserID] = battle
	ctx.GameServer.BattleMu.Unlock()

	logger.Info(fmt.Sprintf("[2408] FIGHT_NPC_MONSTER: mapId=%d slot=%d enemyID=%d level=%d", mapID, slotIndex, enemyID, enemyLevel))

	body := buildNoteReadyToFightInfo(ctx, uint32(enemyID))
	ctx.GameServer.SendResponse(ctx.ClientData, 2503, ctx.UserID, ctx.SeqID, body)
}

// ==================== ATTACK_BOSS (2412) ====================

// handleAttackBoss CMD 2412 攻击 SPT BOSS（破除防护罩）
// 客户端 BossModel.aimatState 在玩家用火焰喷射器等击中 BOSS 后发送 region(4)。
// 服务端扣减该 BOSS 防护罩血量并推送 2021 更新显示；响应 2412 返回当前 hp(4)。
// 克洛斯星密林(12) region=0 为蘑菇怪，每次命中扣约 25% 满血，hp 归零后可点击进入战斗。
func handleAttackBoss(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	mapID := user.MapID
	if mapID == 0 {
		mapID = 1
	}
	var region uint32
	if len(ctx.Body) >= 4 {
		region = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	// 仅处理有防护罩的 SPT BOSS（如克洛斯星密林 12 蘑菇怪）
	e, ok := sptboss.GetByMapAndParam(mapID, region)
	if !ok || !e.HasShield {
		ctx.GameServer.SendResponse(ctx.ClientData, 2412, ctx.UserID, ctx.SeqID, make([]byte, 4))
		return
	}

	petMgr := gamepets.GetInstance()
	stats := petMgr.GetStats(e.BossPetID, e.Level, 15, gamepets.EVStats{}, 0)
	maxHP := stats.MaxHP
	currentHP := getBossHp(ctx.UserID, mapID, region)
	if currentHP <= 0 {
		currentHP = maxHP
	}
	// 每次命中扣约 25% 满血，至少扣 1
	damage := maxHP / 4
	if damage <= 0 {
		damage = 1
	}
	newHP := currentHP - damage
	if newHP < 0 {
		newHP = 0
	}
	setBossHp(ctx.UserID, mapID, region, newHP)

	// 响应 2412：返回当前 BOSS 血量(4)，供客户端更新显示
	respBody := make([]byte, 4)
	binary.BigEndian.PutUint32(respBody, uint32(newHP))
	ctx.GameServer.SendResponse(ctx.ClientData, 2412, ctx.UserID, ctx.SeqID, respBody)

	// 推送 2021 更新 BOSS；hp 归零时先移除再重加，客户端才会真正去掉防护罩（FungusBoss 需重新 add 且 show(0) 才不加载 film）
	if newHP == 0 {
		removeBody := buildMapBossRemoveRegion(mapID, region)
		if len(removeBody) > 0 {
			ctx.GameServer.SendResponse(ctx.ClientData, cmdMapBoss, ctx.UserID, 0, removeBody)
		}
	}
	bossBody := buildMapBossList(mapID, uint32(newHP))
	if len(bossBody) > 0 {
		ctx.GameServer.SendResponse(ctx.ClientData, cmdMapBoss, ctx.UserID, 0, bossBody)
		logger.Info(fmt.Sprintf("[2412] ATTACK_BOSS: UID=%d MapID=%d region=%d hp %d->%d", ctx.UserID, mapID, region, currentHP, newHP))
	}
}

// hasCompletedTutorial 检查玩家是否完成新手任务（任务85-88）
// 参考 Lua: hasCompletedTutorial(user) in seer_login_response.lua
func hasCompletedTutorial(gameData *userdb.GameData) bool {
	if gameData == nil || gameData.Tasks == nil {
		return false
	}
	for id := 85; id <= 88; id++ {
		key := strconv.Itoa(id)
		task, ok := gameData.Tasks[key]
		if !ok {
			return false
		}
		status := task.Status
		if status == "" {
			return false
		}
		// 数值 3 或字符串 "completed" 视为已完成
		if status == "completed" || status == "3" {
			continue
		}
		return false
	}
	return true
}

// handleLogin 处理登录命令
func handleLogin(ctx *gameserver.HandlerContext) {
	// 同一账户只允许一个在线会话：若该 UID 已在其他连接登录，踢掉旧连接
	ctx.GameServer.KickOtherSessionsOfUser(ctx.ClientData, ctx.UserID)

	// 获取用户游戏数据
	gameData := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	// 所有用户上线时地图ID固定为1（传送舱）
	gameData.MapID = 1

	// 获取账号基础数据（用于 userId / regTime 等字段）
	var account *userdb.User
	if ctx.GameServer.UserDB != nil {
		account = ctx.GameServer.UserDB.FindByUserID(ctx.UserID)
	}

	// 处理登录请求包体
	if len(ctx.Body) > 0 {
		// 这里可以添加对登录请求包体的处理逻辑
		// 例如解密、验证会话等
		logger.Info("处理登录请求包体")
	}

	// 构建登录响应包（严格对齐 Lua 版 SeerLoginResponse.makeLoginResponse）
	body := buildLoginResponse(ctx.UserID, account, gameData)

	// 记录登录响应关键字段与长度，便于和 Lua 抓包对比
	logger.Info(fmt.Sprintf(
		"登录响应数据: UID=%d Nick=%s MapID=%d Pets=%d Clothes=%d Tasks=%d BodyLen=%d",
		ctx.UserID,
		gameData.Nick,
		gameData.MapID,
		len(gameData.Pets),
		len(gameData.Clothes),
		len(gameData.Tasks),
		len(body),
	))

	// 标记用户已登录
	ctx.ClientData.LoggedIn = true

	// 发送响应
	ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, body)

	// 启动心跳
	ctx.GameServer.StartHeartbeat(ctx.ClientData, ctx.UserID)
}

// pushChannelList 推送频道列表
func pushChannelList(ctx *gameserver.HandlerContext) {
	// 构建频道列表响应
	// 这里可以根据实际情况构建频道列表
	channelList := make([]byte, 2048) // 增加容量到2048
	index := 0

	// 频道数量
	binary.BigEndian.PutUint32(channelList[index:], 29) // 29个频道
	index += 4

	// 填充频道数据
	for i := 1; i <= 29; i++ {
		// 频道ID
		binary.BigEndian.PutUint32(channelList[index:], uint32(i))
		index += 4
		// 频道名称
		channelName := fmt.Sprintf("频道%d", i)
		nameBytes := []byte(channelName)
		copy(channelList[index:index+32], nameBytes)
		index += 32
		// 在线人数
		binary.BigEndian.PutUint32(channelList[index:], 100) // 模拟在线人数
		index += 4
	}

	// 发送频道列表响应
	logger.Info(fmt.Sprintf("推送频道列表: 命令ID=80001, 频道数量=29, 数据长度=%d", index))
	ctx.GameServer.SendResponse(ctx.ClientData, 80001, ctx.UserID, 0, channelList[:index])
}

// pushServerList 推送服务器列表
func pushServerList(ctx *gameserver.HandlerContext) {
	// 构建服务器列表响应
	// 这里可以根据实际情况构建服务器列表
	serverList := make([]byte, 2048) // 增加容量到2048
	index := 0

	// 服务器数量
	binary.BigEndian.PutUint32(serverList[index:], 29) // 29个服务器
	index += 4

	// 填充服务器数据
	for i := 1; i <= 29; i++ {
		// 服务器ID
		binary.BigEndian.PutUint32(serverList[index:], uint32(i))
		index += 4
		// 服务器名称
		serverName := fmt.Sprintf("服务器%d", i)
		nameBytes := []byte(serverName)
		copy(serverList[index:index+32], nameBytes)
		index += 32
		// 在线人数
		binary.BigEndian.PutUint32(serverList[index:], 1000) // 模拟在线人数
		index += 4
		// 服务器状态
		binary.BigEndian.PutUint32(serverList[index:], 1) // 1表示正常
		index += 4
	}

	// 发送服务器列表响应
	ctx.GameServer.SendResponse(ctx.ClientData, 80002, ctx.UserID, 0, serverList[:index])
}

// buildLoginResponse 构建登录响应包（对齐 Lua 版 SeerLoginResponse.makeLoginResponse）
func buildLoginResponse(userID int64, account *userdb.User, gameData *userdb.GameData) []byte {
	// 为避免频繁分配，预留一个大概的容量，最终长度由实际写入决定
	buffer := make([]byte, 0, 2048)

	writeU32 := func(v uint32) {
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, v)
		buffer = append(buffer, tmp...)
	}
	writeU8 := func(v byte) {
		buffer = append(buffer, v)
	}
	writeFixedString := func(s string, n int) {
		b := []byte(s)
		if len(b) > n {
			b = b[:n]
		}
		buffer = append(buffer, b...)
		if len(b) < n {
			buffer = append(buffer, make([]byte, n-len(b))...)
		}
	}

	// ---- 1. 账号基本信息 ----
	regTime := time.Now().Unix() - 86400*365
	if account != nil && account.RegisterTime > 0 {
		regTime = account.RegisterTime
	}
	writeU32(uint32(userID))            // userID
	writeU32(uint32(regTime))           // regTime
	writeFixedString(gameData.Nick, 16) // nick

	// ---- 2. VIP Flags ----
	vipFlags := uint32(0)
	if gameData.Nono.SuperNono > 0 {
		vipFlags = 3 // 1 | 2
	}
	writeU32(vipFlags)

	// ---- 3. 基础属性 ----
	writeU32(uint32(gameData.DsFlag))  // dsFlag
	writeU32(uint32(gameData.Color))   // color
	writeU32(uint32(gameData.Texture)) // texture

	energy := gameData.Energy
	if energy == 0 && gameData.Nono.Energy > 0 {
		energy = gameData.Nono.Energy
	}
	if energy == 0 {
		energy = 100
	}
	writeU32(uint32(energy))         // energy
	writeU32(uint32(gameData.Coins)) // coins
	writeU32(uint32(gameData.FightBadge))

	// 地图/出生逻辑：默认进入 ID=1 传送舱（用户要求“玩家登录默认进入地址位置在ID=1的传送舱”）
	gameData.MapID = 1 // 所有用户上线时地图ID固定为1
	if gameData.PosX == 0 {
		gameData.PosX = 300
	}
	if gameData.PosY == 0 {
		gameData.PosY = 270
	}
	writeU32(uint32(gameData.MapID))
	writeU32(uint32(gameData.PosX))
	writeU32(uint32(gameData.PosY))
	writeU32(uint32(gameData.TimeToday))
	if gameData.TimeLimit == 0 {
		gameData.TimeLimit = 86400
	}
	writeU32(uint32(gameData.TimeLimit))

	// ---- 4. Flags （4 个 Byte）----
	writeU8(0) // isClothHalfDay
	writeU8(0) // isRoomHalfDay
	writeU8(0) // iFortressHalfDay
	writeU8(0) // isHQHalfDay

	// ---- 5. 统计信息 ----
	writeU32(uint32(gameData.LoginCnt))
	writeU32(uint32(gameData.Inviter))
	writeU32(uint32(gameData.NewInviteeCnt))
	writeU32(uint32(gameData.Nono.VipLevel))
	writeU32(uint32(gameData.Nono.VipValue))
	writeU32(uint32(gameData.Nono.VipStage))
	writeU32(uint32(gameData.Nono.AutoCharge))

	endTime := uint32(gameData.Nono.VipEndTime)
	isSuper := gameData.Nono.SuperNono > 0
	if isSuper && endTime == 0 {
		endTime = 0x7FFFFFFF
	}
	writeU32(endTime)
	writeU32(uint32(gameData.Nono.FreshManBonus))

	// ---- 6. 固定长度列表 ----
	writeFixedString("", 80) // nonoChipList
	writeFixedString("", 50) // dailyResArr

	// ---- 7. 更多统计字段 ----
	writeU32(uint32(gameData.TeacherID))
	writeU32(uint32(gameData.StudentID))
	writeU32(uint32(gameData.GraduationCount))
	writeU32(uint32(gameData.MaxPuniLv))
	writeU32(uint32(gameData.PetMaxLev))
	writeU32(uint32(gameData.PetAllNum))
	writeU32(uint32(gameData.MonKingWin))
	writeU32(uint32(gameData.CurStage))
	writeU32(uint32(gameData.MaxStage))
	writeU32(uint32(gameData.CurFreshStage))
	writeU32(uint32(gameData.MaxFreshStage))
	writeU32(uint32(gameData.MaxArenaWins))
	writeU32(uint32(gameData.TwoTimes))
	writeU32(uint32(gameData.ThreeTimes))
	writeU32(uint32(gameData.AutoFight))
	writeU32(uint32(gameData.AutoFightTimes))
	writeU32(uint32(gameData.EnergyTimes))
	writeU32(uint32(gameData.LearnTimes))
	writeU32(uint32(gameData.MonBtlMedal))

	// 这些字段在 GameData 中没有单独字段，用 0 填充即可，对应：
	// recordCnt, obtainTm, soulBeadItemID, expireTm, fuseTimes
	writeU32(0)
	writeU32(0)
	writeU32(0)
	writeU32(0)
	writeU32(0)

	// ---- 8. NoNo 详细信息 ----
	hasNono := gameData.Nono.HasNono > 0
	superNono := gameData.Nono.SuperNono

	if hasNono {
		writeU32(1)
	} else {
		writeU32(0)
	}
	if superNono > 0 {
		writeU32(1)
	} else {
		writeU32(0)
	}

	// nonoState / nonoColor / nonoNick
	flag := gameData.Nono.Flag
	if flag == 0 {
		flag = -1 // 0xFFFFFFFF
	}
	writeU32(uint32(flag))
	writeU32(uint32(gameData.Nono.Color))
	writeFixedString(gameData.Nono.Nick, 16)

	// ---- 9. TeamInfo (24 bytes) ----
	for i := 0; i < 6; i++ {
		writeU32(0)
	}

	// ---- 10. TeamPKInfo (8 bytes) ----
	writeU32(0)
	writeU32(0)

	// ---- 11. Badge & Reserved ----
	writeU8(0) // padding/flag
	writeU32(uint32(gameData.Badge))
	writeFixedString("", 27)

	// ---- 12. Task List (500 bytes, 每个任务 1 字节状态) ----
	taskCount := 0
	if gameData.Tasks != nil {
		for i := 1; i <= 500; i++ {
			key := strconv.Itoa(i)
			statusByte := byte(0)
			if t, ok := gameData.Tasks[key]; ok {
				switch t.Status {
				case "completed", "3":
					statusByte = 3
				case "accepted", "doing", "in_progress", "1":
					statusByte = 1
				default:
					if n, err := strconv.Atoi(t.Status); err == nil {
						if n < 0 {
							n = 0
						} else if n > 255 {
							n = 255
						}
						statusByte = byte(n)
					}
				}
				if statusByte != 0 {
					taskCount++
				}
			}
			writeU8(statusByte)
		}
	} else {
		for i := 0; i < 500; i++ {
			writeU8(0)
		}
	}
	logger.Info(fmt.Sprintf("登录任务状态编码完成: totalTasks=%d", taskCount))

	// ---- 13. Pet List ----
	writeU32(uint32(len(gameData.Pets)))
	if len(gameData.Pets) > 0 {
		for _, pet := range gameData.Pets {
			petBody := buildFullPetInfo(pet)
			buffer = append(buffer, petBody...)
		}
	}

	// ---- 14. Clothes ----
	writeU32(uint32(len(gameData.Clothes)))
	for _, clothID := range gameData.Clothes {
		// Lua: 每件服装写入 (clothId, level)，我们只有 ID，默认等级为 1
		writeU32(uint32(clothID))
		writeU32(1)
	}

	// ---- 15. Title & Achievements ----
	writeU32(uint32(gameData.CurTitle))
	buffer = append(buffer, sptboss.BuildBossAchievement(gameData.DefeatedSPTBossIds)...) // bossAchievement 200 字节

	return buffer
}

// buildFullPetInfo 构建完整版 PetInfo
// 对齐 Lua 版 PetHandlers.buildFullPetInfo / UserInfo.setForLoginInfo 的读取结构
func buildFullPetInfo(p userdb.Pet) []byte {
	buf := make([]byte, 0, 200)

	writeU32 := func(v uint32) {
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, v)
		buf = append(buf, tmp...)
	}
	writeU16 := func(v uint16) {
		tmp := make([]byte, 2)
		binary.BigEndian.PutUint16(tmp, v)
		buf = append(buf, tmp...)
	}
	writeFixedString := func(s string, n int) {
		b := []byte(s)
		if len(b) > n {
			b = b[:n]
		}
		buf = append(buf, b...)
		if len(b) < n {
			buf = append(buf, make([]byte, n-len(b))...)
		}
	}

	petID := p.ID
	if petID <= 0 {
		petID = 1
	}
	level := p.Level
	if level <= 0 {
		level = 5
	}
	dv := p.DV
	if dv <= 0 {
		dv = 31
	}
	nature := p.Nature
	exp := p.Exp
	name := p.Name

	petMgr := gamepets.GetInstance()
	skillMgr := gameskills.GetInstance()

	// 从 Pet 结构体中获取 EV（学习力）
	ev := p.GetEVStats()

	// 基础属性 & 战斗属性（使用精灵的性格）
	stats := petMgr.GetStats(petID, level, dv, ev, nature)
	expInfo := petMgr.GetExpInfo(petID, level, exp)

	// 技能列表：最多 4 个；优先使用技能唤醒仪保存的自定义技能
	var rawSkills []int
	if len(p.Skills) > 0 {
		rawSkills = make([]int, 4)
		for i := 0; i < 4 && i < len(p.Skills); i++ {
			rawSkills[i] = p.Skills[i]
		}
	} else {
		rawSkills = petMgr.GetSkillsForLevel(petID, level)
	}
	skillIDs := make([]int, 4)
	skillPPs := make([]int, 4)
	validCount := 0

	// 确保至少有一个技能（默认技能 10001 = 撞击）
	hasAnySkill := false
	for i := 0; i < len(rawSkills) && i < 4; i++ {
		if rawSkills[i] > 0 {
			hasAnySkill = true
			break
		}
	}
	if !hasAnySkill {
		// 如果没有技能，添加默认技能 10001（撞击）
		rawSkills = []int{10001, 0, 0, 0}
	}

	for i := 0; i < 4; i++ {
		sid := 0
		if i < len(rawSkills) {
			sid = rawSkills[i]
		}
		pp := 0
		if sid > 0 {
			if sk := skillMgr.Get(sid); sk != nil {
				pp = sk.PP
				if pp == 0 {
					pp = sk.MaxPP
				}
			}
			if pp == 0 {
				pp = 20
			}
			validCount++
		}
		skillIDs[i] = sid
		skillPPs[i] = pp
	}
	// 调试日志：输出技能信息
	logger.Info(fmt.Sprintf("[buildFullPetInfo] PetID=%d Level=%d Skills: validCount=%d", petID, level, validCount))
	for i := 0; i < 4; i++ {
		if skillIDs[i] > 0 {
			logger.Info(fmt.Sprintf("  Skill[%d]: ID=%d PP=%d", i, skillIDs[i], skillPPs[i]))
		}
	}

	// 1. 基础信息
	writeU32(uint32(petID))    // id
	writeFixedString(name, 16) // name
	writeU32(uint32(dv))       // dv
	writeU32(uint32(nature))   // nature
	writeU32(uint32(level))    // level
	// 对齐前端语义（经验分配器“升级所需经验值”= nextLvExp - exp，须非负）：
	// - exp: 当前等级已获得经验，客户端用 nextLvExp - exp 显示“升级所需经验值”
	// - lvExp: 同上，当前等级经验（与 exp 一致）
	// - nextLvExp: 当前等级升到下一等级所需经验
	writeU32(uint32(expInfo.CurrentLevelExp)) // exp（当前等级经验，避免显示负数）
	writeU32(uint32(expInfo.CurrentLevelExp)) // lvExp（当前等级经验）
	writeU32(uint32(expInfo.NextLevelExp))    // nextLvExp

	// 2. 战斗属性
	writeU32(uint32(stats.HP))      // hp
	writeU32(uint32(stats.MaxHP))   // maxHp
	writeU32(uint32(stats.Attack))  // atk
	writeU32(uint32(stats.Defence)) // def
	writeU32(uint32(stats.SpAtk))   // sa
	writeU32(uint32(stats.SpDef))   // sd
	writeU32(uint32(stats.Speed))   // spd

	// 3. 努力值（当前全部 0）
	writeU32(uint32(ev.HP))
	writeU32(uint32(ev.Atk))
	writeU32(uint32(ev.Def))
	writeU32(uint32(ev.SpAtk))
	writeU32(uint32(ev.SpDef))
	writeU32(uint32(ev.Spd))

	// 4. 技能列表
	writeU32(uint32(validCount))
	for i := 0; i < 4; i++ {
		writeU32(uint32(skillIDs[i]))
		writeU32(uint32(skillPPs[i]))
	}

	// 5. 捕获信息
	writeU32(uint32(p.CatchTime)) // catchTime
	writeU32(uint32(301))         // catchMap，默认 301
	writeU32(0)                   // catchRect
	writeU32(uint32(level))       // catchLevel

	// 6. 特效列表
	writeU16(0) // effectCount

	// 7. Skin
	writeU32(0) // skinID

	return buf
}

// handleEnterMap 处理进入地图命令
func handleEnterMap(ctx *gameserver.HandlerContext) {
	// 获取用户数据
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	// 解析请求参数
	mapId := uint32(0)
	x := uint32(500)
	y := uint32(300)

	if len(ctx.Body) >= 16 {
		// 解析地图类型、地图ID和坐标
		// 暂时忽略mapType，因为GameData结构中没有对应的字段
		// mapType = binary.BigEndian.Uint32(ctx.Body[0:4])
		mapId = binary.BigEndian.Uint32(ctx.Body[4:8])
		x = binary.BigEndian.Uint32(ctx.Body[8:12])
		y = binary.BigEndian.Uint32(ctx.Body[12:16])
	}

	logger.Info(fmt.Sprintf(
		"进入地图请求: UID=%d ReqMapID=%d CurMapID=%d X=%d Y=%d BodyLen=%d",
		ctx.UserID,
		mapId,
		user.MapID,
		x,
		y,
		len(ctx.Body),
	))

	// 验证与设置默认地图（默认 ID=1 传送舱，新号也可进入）
	if mapId == 0 {
		mapId = uint32(user.MapID)
		if mapId == 0 {
			mapId = 1
		}
	}

	oldMapID := user.MapID
	// 更新用户状态
	user.MapID = int(mapId)
	user.PosX = int(x)
	user.PosY = int(y)

	// 地图玩家追踪：从旧地图移除、加入新地图，并推送/广播 2003 使同图玩家互相可见
	ctx.GameServer.RemoveUserFromMap(oldMapID, ctx.UserID)
	if oldMapID > 0 {
		oldListBody := buildMapPlayerListForMap(ctx.GameServer, oldMapID)
		ctx.GameServer.BroadcastToMap(oldMapID, 0, 2003, oldListBody)
	}
	ctx.GameServer.AddUserToMap(int(mapId), ctx.UserID, ctx.ClientData)

	// 构建用户信息响应（格式对齐 UserInfo.setForPeoleInfo / Lua map_handlers.buildPeopleInfo）
	body := buildPeopleInfo(ctx.UserID, user, time.Now().Unix(), int(x), int(y))

	logger.Info(fmt.Sprintf(
		"进入地图响应2001: UID=%d MapID=%d BodyLen=%d",
		ctx.UserID,
		user.MapID,
		len(body),
	))

	// 发送进入地图响应
	ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, body)

	// 推送地图玩家列表（同地图所有玩家含自己），使客户端能显示其他玩家
	listBody := buildMapPlayerListForMap(ctx.GameServer, int(mapId))
	ctx.GameServer.SendResponse(ctx.ClientData, 2003, ctx.UserID, ctx.SeqID, listBody)
	ctx.GameServer.BroadcastToMap(int(mapId), ctx.UserID, 2003, listBody)
	logger.Info(fmt.Sprintf(
		"推送地图玩家列表2003: UID=%d MapID=%d Count=%d",
		ctx.UserID,
		user.MapID,
		binary.BigEndian.Uint32(listBody[0:4]),
	))

	// 推送地图怪物列表
	ogreBody := buildMapOgreList(int(mapId))
	ctx.GameServer.SendResponse(ctx.ClientData, 2004, ctx.UserID, ctx.SeqID, ogreBody)

	logger.Info(fmt.Sprintf(
		"推送地图怪物列表2004: UID=%d MapID=%d BodyLen=%d",
		ctx.UserID,
		user.MapID,
		len(ogreBody),
	))

	// 有防护罩的 SPT 地图：重置 BOSS 防护罩满血并推送 MAP_BOSS(2021)
	// 推送两次 2021：第二次时客户端 BOSS 已存在会调用 show()，BossModel 会执行 _walk.execute 从而启动每 3 秒走动
	if e, ok := sptboss.GetByMapAndParam(int(mapId), 0); ok && e.HasShield {
		petMgr := gamepets.GetInstance()
		stats := petMgr.GetStats(e.BossPetID, e.Level, 15, gamepets.EVStats{}, 0)
		setBossHp(ctx.UserID, int(mapId), 0, stats.MaxHP)
		bossBody := buildMapBossList(int(mapId), uint32(stats.MaxHP))
		if len(bossBody) > 0 {
			ctx.GameServer.SendResponse(ctx.ClientData, cmdMapBoss, ctx.UserID, ctx.SeqID, bossBody)
			ctx.GameServer.SendResponse(ctx.ClientData, cmdMapBoss, ctx.UserID, 0, bossBody)
			logger.Info(fmt.Sprintf("[2021] 推送地图 BOSS 列表: UID=%d MapID=%d PetID=%d hp=%d (x2 触发走动)", ctx.UserID, user.MapID, e.BossPetID, stats.MaxHP))
		}
	}

	// 家园地图特殊处理
	if mapId > 10000 || mapId == uint32(ctx.UserID) {
		// 发送NoNo信息
		nonoBody := buildNonoInfo(ctx.UserID, user)
		ctx.GameServer.SendResponse(ctx.ClientData, 9003, ctx.UserID, ctx.SeqID, nonoBody)
	}
}

// pushInitialMapEnter 在登录完成后主动推送一次进入默认地图/房间的相关封包
// 相当于模拟客户端发了一次 CMD=2001，然后服务器按同样逻辑回复 2001/2003/2004/9003
func pushInitialMapEnter(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	// 使用与 1001 一致的地图：默认 ID=1 传送舱
	mapId := uint32(user.MapID)
	x := uint32(user.PosX)
	y := uint32(user.PosY)
	if mapId == 0 {
		mapId = 1
	}

	if x == 0 {
		x = 500
	}
	if y == 0 {
		y = 300
	}

	logger.Info(fmt.Sprintf(
		"自动进入默认地图: UID=%d MapID=%d X=%d Y=%d",
		ctx.UserID,
		mapId,
		x,
		y,
	))

	// 更新用户状态（与 handleEnterMap 一致）
	user.MapID = int(mapId)
	user.PosX = int(x)
	user.PosY = int(y)
	ctx.GameServer.AddUserToMap(int(mapId), ctx.UserID, ctx.ClientData)

	// 构建并发送 2001 / 2003 / 2004 / 9003；2003 含同地图所有人使其他玩家可见
	body := buildPeopleInfo(ctx.UserID, user, time.Now().Unix(), int(x), int(y))
	ctx.GameServer.SendResponse(ctx.ClientData, 2001, ctx.UserID, 0, body)
	listBody := buildMapPlayerListForMap(ctx.GameServer, int(mapId))
	ctx.GameServer.SendResponse(ctx.ClientData, 2003, ctx.UserID, 0, listBody)
	ctx.GameServer.BroadcastToMap(int(mapId), ctx.UserID, 2003, listBody)

	ogreBody := buildMapOgreList(int(mapId))
	ctx.GameServer.SendResponse(ctx.ClientData, 2004, ctx.UserID, 0, ogreBody)

	if mapId > 10000 || mapId == uint32(ctx.UserID) {
		nonoBody := buildNonoInfo(ctx.UserID, user)
		ctx.GameServer.SendResponse(ctx.ClientData, 9003, ctx.UserID, 0, nonoBody)
	}
}

// buildPeopleInfo 构建 2001/2003 用的用户信息体，严格对齐
// 前端 UserInfo.setForPeoleInfo 与 Lua map_handlers.buildPeopleInfo 的读写顺序
func buildPeopleInfo(userID int64, user *userdb.GameData, sysTime int64, posX, posY int) []byte {
	buf := make([]byte, 0, 256)
	writeU32 := func(v uint32) {
		t := make([]byte, 4)
		binary.BigEndian.PutUint32(t, v)
		buf = append(buf, t...)
	}
	writeI32 := func(v int32) {
		writeU32(uint32(v))
	}
	writeU16 := func(v uint16) {
		t := make([]byte, 2)
		binary.BigEndian.PutUint16(t, v)
		buf = append(buf, t...)
	}
	writeFixed := func(s string, n int) {
		b := []byte(s)
		if len(b) > n {
			b = b[:n]
		}
		buf = append(buf, b...)
		for i := len(b); i < n; i++ {
			buf = append(buf, 0)
		}
	}

	if posX == 0 {
		posX = 500
	}
	if posY == 0 {
		posY = 300
	}

	// 1. 基本信息
	writeI32(int32(sysTime))
	writeU32(uint32(userID))
	nick := user.Nick
	if nick == "" {
		nick = fmt.Sprintf("Seer%d", userID)
	}
	writeFixed(nick, 16)
	writeU32(uint32(user.Color))
	if user.Texture == 0 {
		writeU32(0)
	} else {
		writeU32(uint32(user.Texture))
	}

	// 2. VIP (bit0=vip, bit1=viped)
	vipFlags := uint32(0)
	if user.Nono.SuperNono > 0 {
		vipFlags = 3
	}
	writeU32(vipFlags)
	writeU32(uint32(user.Nono.VipStage))

	// 3. 动作与坐标
	actionType := uint32(0) // flyMode 未在 GameData，固定 0
	writeU32(actionType)
	writeU32(uint32(posX))
	writeU32(uint32(posY))
	writeU32(0) // action
	writeU32(0) // direction
	writeU32(0) // changeShape

	// 4. 精灵（spiritTime=catchTime, spiritID=petId）— 使用当前跟随精灵，其他玩家可见一致
	var petID, catchTime, petDV uint32 = 0, 0, 31
	if user.FollowPetCatchTime > 0 {
		for _, p := range user.Pets {
			if p.CatchTime == user.FollowPetCatchTime {
				petID = uint32(p.ID)
				catchTime = uint32(p.CatchTime)
				if p.DV > 0 {
					petDV = uint32(p.DV)
				}
				break
			}
		}
		if petID == 0 && user.StoragePets != nil {
			for _, p := range user.StoragePets {
				if p.CatchTime == user.FollowPetCatchTime {
					petID = uint32(p.ID)
					catchTime = uint32(p.CatchTime)
					if p.DV > 0 {
						petDV = uint32(p.DV)
					}
					break
				}
			}
		}
	}
	if petID == 0 && len(user.Pets) > 0 {
		p := user.Pets[0]
		petID = uint32(p.ID)
		catchTime = uint32(p.CatchTime)
		if p.DV > 0 {
			petDV = uint32(p.DV)
		}
	}
	writeU32(catchTime)
	writeU32(petID)
	writeU32(petDV)
	writeU32(0) // petSkin
	writeU32(0) // fightFlag

	// 5. 师徒
	writeU32(uint32(user.TeacherID))
	writeU32(uint32(user.StudentID))

	// 6. NoNo
	nonoFlag := user.Nono.Flag
	writeU32(uint32(nonoFlag))
	writeU32(uint32(user.Nono.Color))
	if user.Nono.SuperNono > 0 {
		writeU32(1)
	} else {
		writeU32(0)
	}
	writeU32(0) // playerForm
	writeU32(0) // transTime

	// 7. TeamInfo：id, coreCount, isShow, logoBg, logoIcon, logoColor, txtColor, logoWord(4)
	writeU32(0)
	writeU32(0)
	writeU32(0)
	writeU16(0)
	writeU16(0)
	writeU16(0)
	writeU16(0)
	writeFixed("", 4)

	// 8. Clothes：count + [id,level]
	writeU32(uint32(len(user.Clothes)))
	for _, cid := range user.Clothes {
		writeU32(uint32(cid))
		writeU32(0) // level，无则 0，与 Lua 一致
	}

	// 9. curTitle
	writeU32(uint32(user.CurTitle))
	return buf
}

// buildMapPlayerList 构建地图玩家列表响应（单条 peopleInfo，兼容旧调用）
func buildMapPlayerList(peopleInfo []byte) []byte {
	buffer := make([]byte, 4+len(peopleInfo))
	binary.BigEndian.PutUint32(buffer[0:4], 1)
	copy(buffer[4:], peopleInfo)
	return buffer
}

// buildMapPlayerListForMap 构建当前地图上所有玩家的 2003 列表（含自己），用于同地图其他玩家可见
func buildMapPlayerListForMap(gs *gameserver.GameServer, mapID int) []byte {
	clients := gs.GetClientsOnMap(mapID)
	if len(clients) == 0 {
		return make([]byte, 4) // count=0
	}
	var parts [][]byte
	now := time.Now().Unix()
	for _, c := range clients {
		user := gs.GetOrCreateUser(c.UserID)
		x, y := user.PosX, user.PosY
		if x == 0 {
			x = 500
		}
		if y == 0 {
			y = 300
		}
		parts = append(parts, buildPeopleInfo(c.UserID, user, now, x, y))
	}
	total := 0
	for _, p := range parts {
		total += len(p)
	}
	buffer := make([]byte, 4+total)
	binary.BigEndian.PutUint32(buffer[0:4], uint32(len(parts)))
	off := 4
	for _, p := range parts {
		copy(buffer[off:], p)
		off += len(p)
	}
	return buffer
}

// CMD 2021 MAP_BOSS：客户端用此包在地图上显示 SPT BOSS（如蘑菇怪），BossCmdListener 解析后调用 BossController.add
const cmdMapBoss = 2021

// bossHpKey 返回 BOSS 血量缓存的 key
func bossHpKey(mapID int, region uint32) string {
	return fmt.Sprintf("%d_%d", mapID, region)
}

func getBossHp(userID int64, mapID int, region uint32) int {
	bossHpCacheMu.RLock()
	defer bossHpCacheMu.RUnlock()
	if m, ok := bossHpCache[userID]; ok {
		if hp, ok := m[bossHpKey(mapID, region)]; ok {
			return hp
		}
	}
	return 0 // 0 表示使用满血
}

func setBossHp(userID int64, mapID int, region uint32, hp int) {
	bossHpCacheMu.Lock()
	defer bossHpCacheMu.Unlock()
	if bossHpCache[userID] == nil {
		bossHpCache[userID] = make(map[string]int)
	}
	bossHpCache[userID][bossHpKey(mapID, region)] = hp
}

// pos=200 时客户端会移除该 region 的 BOSS（BossCmdListener）
const mapBossPosRemove = 200

// buildMapBossRemoveRegion 构建 2021 包体：移除指定 region 的 BOSS（pos=200）
func buildMapBossRemoveRegion(mapID int, region uint32) []byte {
	e, ok := sptboss.GetByMapAndParam(mapID, region)
	if !ok || !e.HasShield {
		return nil
	}
	body := make([]byte, 4+16)
	binary.BigEndian.PutUint32(body[0:4], 1)
	binary.BigEndian.PutUint32(body[4:8], uint32(e.BossPetID))
	binary.BigEndian.PutUint32(body[8:12], region)
	binary.BigEndian.PutUint32(body[12:16], 0)
	binary.BigEndian.PutUint32(body[16:20], mapBossPosRemove)
	return body
}

// buildMapBossList 构建 MAP_BOSS(2021) 响应体，用于在地图上显示 SPT BOSS
// 格式：len(4) + [id(4)+region(4)+hp(4)+pos(4)]*len；pos=200 表示移除该 region
// hp=0 表示无防护罩。仅对 OgreXMLInfo 有 boss 配置的地图推送（如克洛斯星密林 12 蘑菇怪）
func buildMapBossList(mapID int, hp uint32) []byte {
	e, ok := sptboss.GetByMapAndParam(mapID, 0)
	if !ok {
		return nil
	}
	// 仅有防护罩的 BOSS 需要推送 MAP_BOSS；无防护罩的由地图脚本直接触发战斗
	if !e.HasShield {
		return nil
	}
	body := make([]byte, 4+16)
	binary.BigEndian.PutUint32(body[0:4], 1)
	binary.BigEndian.PutUint32(body[4:8], uint32(e.BossPetID))
	binary.BigEndian.PutUint32(body[8:12], 0)   // region=0
	binary.BigEndian.PutUint32(body[12:16], hp) // 当前血量（0=无防护罩）
	binary.BigEndian.PutUint32(body[16:20], 0)  // pos=0
	return body
}

// buildMapOgreList 构建地图怪物列表响应
func buildMapOgreList(mapId int) []byte {
	// 结构：9 个槽位 * [petId(4) + shiny(4)] = 72 字节
	body := make([]byte, 72)
	index := 0

	slots := gameogres.GetSlots(mapId)

	for i := 0; i < 9; i++ {
		var petID uint32
		var shiny uint32
		if i < len(slots) && slots[i].PetID > 0 {
			petID = uint32(slots[i].PetID)
			if slots[i].Shiny {
				shiny = 1
			}
		}
		binary.BigEndian.PutUint32(body[index:], petID)
		index += 4
		binary.BigEndian.PutUint32(body[index:], shiny)
		index += 4
	}

	logger.Info(fmt.Sprintf("[2004] MapOgreList: mapId=%d slots=%v", mapId, slots))
	return body
}

// buildNonoInfo 构建NoNo信息响应
func buildNonoInfo(userID int64, user *userdb.GameData) []byte {
	// 创建响应缓冲区
	buffer := make([]byte, 128)
	index := 0

	// 写入用户ID
	binary.BigEndian.PutUint32(buffer[index:], uint32(userID))
	index += 4

	// 写入NoNo标志
	binary.BigEndian.PutUint32(buffer[index:], uint32(user.Nono.Flag))
	index += 4

	// 写入NoNo状态
	binary.BigEndian.PutUint32(buffer[index:], 1) // 在家状态
	index += 4

	// 写入NoNo昵称
	nonoNameBytes := []byte(user.Nono.Nick)
	copy(buffer[index:index+16], nonoNameBytes)
	index += 16

	// 写入SuperNoNo标志
	binary.BigEndian.PutUint32(buffer[index:], uint32(user.Nono.SuperNono))
	index += 4

	// 写入颜色
	binary.BigEndian.PutUint32(buffer[index:], uint32(user.Nono.Color))
	index += 4

	// 写入能量
	binary.BigEndian.PutUint32(buffer[index:], uint32(user.Nono.Power))
	index += 4

	// 写入亲密度
	binary.BigEndian.PutUint32(buffer[index:], uint32(user.Nono.Mate))
	index += 4

	// 写入IQ
	binary.BigEndian.PutUint32(buffer[index:], uint32(user.Nono.IQ))
	index += 4

	// 写入AI
	binary.BigEndian.PutUint16(buffer[index:], uint16(user.Nono.AI))
	index += 2

	// 填充剩余空间为0
	for i := index; i < 128; i++ {
		buffer[i] = 0
	}

	return buffer
}

// handleLeaveMap 处理离开地图命令
// 对齐 Lua: map_handlers.handleLeaveMap
// 响应: userId(4)；并从地图玩家中移除，向同地图其他玩家广播更新后的 2003
func handleLeaveMap(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	mapID := user.MapID
	ctx.GameServer.RemoveUserFromMap(mapID, ctx.UserID)

	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
	ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[2002] 离开地图: UID=%d MapID=%d", ctx.UserID, mapID))

	if mapID > 0 {
		listBody := buildMapPlayerListForMap(ctx.GameServer, mapID)
		ctx.GameServer.BroadcastToMap(mapID, 0, 2003, listBody)
	}
}

// handleListMapPlayer 处理地图玩家列表命令
func handleListMapPlayer(ctx *gameserver.HandlerContext) {
	// 客户端在地图初始化后会主动请求 LIST_MAP_PLAYER(2003)；返回同地图所有玩家（含自己）
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.MapID == 0 {
		user.MapID = 1
	}
	body := buildMapPlayerListForMap(ctx.GameServer, user.MapID)
	ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, body)
}

// handleMapHot CMD 1004 地图热点（宇宙地图热点数据）
// 客户端 MapHotInfo: count(4) + [id(4)+value(4)]*count；空热点则 count=0
func handleMapHot(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body, 0) // 热点数量 0，客户端不显示热点
	ctx.GameServer.SendResponse(ctx.ClientData, 1004, ctx.UserID, ctx.SeqID, body)
}

// handleMapOgreList 处理地图怪物列表命令
func handleMapOgreList(ctx *gameserver.HandlerContext) {
	// 客户端可能会主动请求 MAP_OGRE_LIST(2004)，返回当前地图的怪物列表（允许为空但结构要对）。
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	mapID := user.MapID
	if mapID == 0 {
		mapID = 1
	}
	body := buildMapOgreList(mapID)
	ctx.GameServer.SendResponse(ctx.ClientData, ctx.CmdID, ctx.UserID, ctx.SeqID, body)
}

// handleChat CMD 2102 聊天
// 请求: toID(4) + msgLen(4) + msg(msgLen 字节，UTF-8)
// 响应: ChatInfo = senderID(4) + senderNickName(16) + toID(4) + msgLen(4) + msg(msgLen)
func handleChat(ctx *gameserver.HandlerContext) {
	toID := uint32(0)
	msgLen := uint32(0)
	msgBytes := []byte(nil)
	if len(ctx.Body) >= 8 {
		toID = binary.BigEndian.Uint32(ctx.Body[0:4])
		msgLen = binary.BigEndian.Uint32(ctx.Body[4:8])
		if msgLen > 0 && len(ctx.Body) >= 8+int(msgLen) {
			msgBytes = ctx.Body[8 : 8+msgLen]
		} else if len(ctx.Body) > 8 {
			msgBytes = ctx.Body[8:]
			msgLen = uint32(len(msgBytes))
		}
	}
	// 客户端 ChatAction.as 会在每条消息末尾主动写入字符 "0"，回显时去掉避免显示成 "Bye0"
	if len(msgBytes) > 0 && msgBytes[len(msgBytes)-1] == '0' {
		msgBytes = msgBytes[:len(msgBytes)-1]
		msgLen = uint32(len(msgBytes))
	}
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	nick := user.Nick
	if nick == "" {
		nick = "赛尔"
	}
	nickBytes := []byte(nick)
	if len(nickBytes) > 16 {
		nickBytes = nickBytes[:16]
	}
	// ChatInfo: senderID(4) + senderNickName(16) + toID(4) + msgLen(4) + msg
	body := make([]byte, 0, 4+16+4+4+len(msgBytes))
	buf4 := make([]byte, 4)
	binary.BigEndian.PutUint32(buf4, uint32(ctx.UserID))
	body = append(body, buf4...)
	nickPad := make([]byte, 16)
	copy(nickPad, nickBytes)
	body = append(body, nickPad...)
	binary.BigEndian.PutUint32(buf4, toID)
	body = append(body, buf4...)
	binary.BigEndian.PutUint32(buf4, msgLen)
	body = append(body, buf4...)
	body = append(body, msgBytes...)
	ctx.GameServer.SendResponse(ctx.ClientData, 2102, ctx.UserID, ctx.SeqID, body)
}

// handleAimat CMD 2104 射击/瞄准（AIMAT）
// 对齐 AS3: BasePeoleModel.aimatAction 发送 itemID, type, x, y；AimatCmdListener.onAimat 期望响应 userID(4)+itemID(4)+type(4)+x(4)+y(4)
// 响应并广播给同地图其他玩家，使其他玩家能看到射击动作
func handleAimat(ctx *gameserver.HandlerContext) {
	itemID := uint32(0)
	aimType := uint32(0)
	x := uint32(0)
	y := uint32(0)
	if len(ctx.Body) >= 16 {
		itemID = binary.BigEndian.Uint32(ctx.Body[0:4])
		aimType = binary.BigEndian.Uint32(ctx.Body[4:8])
		x = binary.BigEndian.Uint32(ctx.Body[8:12])
		y = binary.BigEndian.Uint32(ctx.Body[12:16])
	}
	// 响应: userID(4) + itemID(4) + type(4) + x(4) + y(4)，供客户端 dispatchAction 显示射击
	body := make([]byte, 20)
	binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
	binary.BigEndian.PutUint32(body[4:8], itemID)
	binary.BigEndian.PutUint32(body[8:12], aimType)
	binary.BigEndian.PutUint32(body[12:16], x)
	binary.BigEndian.PutUint32(body[16:20], y)
	ctx.GameServer.SendResponse(ctx.ClientData, 2104, ctx.UserID, ctx.SeqID, body)
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.MapID > 0 {
		ctx.GameServer.BroadcastToMap(user.MapID, ctx.UserID, 2104, body)
	}
}

// handleTransformUser CMD 2107 射击命中后变身（TRANSFORM_USER）
// 请求: targetUserID(4) + transformId(4) = 8 字节（AimatCmdListener.send(TRANSFORM_USER, _loc2_.info.userID, uint(_loc3_[0]))）
// 响应: 回显相同 8 字节；并向同地图广播 CMD 2108 NOTE_TRANSFORM_USER，body 为 targetUserID(4)+transformId(4)+0(4)，供其他客户端显示变身
func handleTransformUser(ctx *gameserver.HandlerContext) {
	targetUserID := uint32(0)
	transformId := uint32(0)
	if len(ctx.Body) >= 8 {
		targetUserID = binary.BigEndian.Uint32(ctx.Body[0:4])
		transformId = binary.BigEndian.Uint32(ctx.Body[4:8])
	}
	body := make([]byte, 8)
	binary.BigEndian.PutUint32(body[0:4], targetUserID)
	binary.BigEndian.PutUint32(body[4:8], transformId)
	ctx.GameServer.SendResponse(ctx.ClientData, 2107, ctx.UserID, ctx.SeqID, body)
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.MapID > 0 {
		noteBody := make([]byte, 12)
		binary.BigEndian.PutUint32(noteBody[0:4], targetUserID)
		binary.BigEndian.PutUint32(noteBody[4:8], transformId)
		binary.BigEndian.PutUint32(noteBody[8:12], 0)
		ctx.GameServer.BroadcastToMap(user.MapID, 0, 2108, noteBody)
	}
}

// handleHeartbeat 处理心跳包
func handleHeartbeat(ctx *gameserver.HandlerContext) {
	// 实现心跳包逻辑
}

// ==================== 战斗命令（最小可用版本）====================

// buildAttackValue 构建攻击值（CMD 2505）
// 对齐客户端 AttackValue：userId(4)+skillId(4)+atkTimes(4)+lostHP(4)+gainHP(4)+remainHp(4)+maxHp(4)+state(4)+
// skillListCount(4)+[PetSkillInfo]*N+isCrit(4)+status(20)+battleLv(6)+maxShield(4)+curShield(4)+petType(4)，N=0 时共 82 字节
// status/battleLv 用于技能附加效果（烧伤、中毒、属性升降等），与 Lua buildAttackValue 一致
func buildAttackValue(userID uint32, skillID uint32, atkTimes uint32, lostHP uint32, gainHP int32, remainHP int32, maxHP uint32, state uint32, isCrit uint32, petType uint32, status [20]byte, battleLv [6]int8) []byte {
	if maxHP == 0 {
		maxHP = 1
	}
	maxHP32 := int32(maxHP)
	if remainHP < 0 {
		remainHP = 0
	}
	if remainHP > maxHP32 {
		remainHP = maxHP32
	}
	// 回血时客户端会 hp += gainHP 再钳位，限制 gainHP 使 (remainHP+gainHP) 不超过 maxHP，血条到顶只显示加血数值
	if gainHP > 0 {
		if remainHP >= maxHP32 {
			gainHP = 0
		} else if int64(remainHP)+int64(gainHP) > int64(maxHP32) {
			gainHP = maxHP32 - remainHP
		}
	}
	const attackValueSize = 82 // 9*4 + skillListCount(4) + isCrit(4) + status(20) + battleLv(6) + maxShield(4) + curShield(4) + petType(4)
	buf := make([]byte, attackValueSize)
	off := 0
	binary.BigEndian.PutUint32(buf[off:off+4], userID)
	off += 4
	binary.BigEndian.PutUint32(buf[off:off+4], skillID)
	off += 4
	binary.BigEndian.PutUint32(buf[off:off+4], atkTimes)
	off += 4
	binary.BigEndian.PutUint32(buf[off:off+4], lostHP)
	off += 4
	// gainHP 和 remainHP 是有符号整数，需要正确转换
	if gainHP < 0 {
		binary.BigEndian.PutUint32(buf[off:off+4], uint32(math.MaxUint32+int64(gainHP)+1))
	} else {
		binary.BigEndian.PutUint32(buf[off:off+4], uint32(gainHP))
	}
	off += 4
	if remainHP < 0 {
		binary.BigEndian.PutUint32(buf[off:off+4], uint32(math.MaxUint32+int64(remainHP)+1))
	} else {
		binary.BigEndian.PutUint32(buf[off:off+4], uint32(remainHP))
	}
	off += 4
	binary.BigEndian.PutUint32(buf[off:off+4], maxHP)
	off += 4
	binary.BigEndian.PutUint32(buf[off:off+4], state)
	off += 4
	binary.BigEndian.PutUint32(buf[off:off+4], 0) // skillListCount = 0
	off += 4
	binary.BigEndian.PutUint32(buf[off:off+4], isCrit)
	off += 4
	// status 20 bytes（异常状态：0=无 1=中毒 2=烧伤等）
	copy(buf[off:off+20], status[:])
	off += 20
	// battleLv 6 bytes 有符号（攻击/防御/特攻/特防/速度/命中 等级 -6~+6）
	for i := 0; i < 6; i++ {
		buf[off] = byte(uint8(battleLv[i]))
		off++
	}
	binary.BigEndian.PutUint32(buf[off:off+4], 0) // maxShield
	off += 4
	binary.BigEndian.PutUint32(buf[off:off+4], 0) // curShield
	off += 4
	binary.BigEndian.PutUint32(buf[off:off+4], petType)
	off += 4
	return buf[:off]
}

// buildFightOverInfo 构建战斗结束信息（CMD 2506）
// 对齐 Lua: buildFightOverInfo
// reason(4) + winnerId(4) + twoTimes(4) + threeTimes(4) + autoFightTimes(4) + energyTimes(4) + learnTimes(4) = 28 bytes
func buildFightOverInfo(reason uint32, winnerID uint32) []byte {
	buf := make([]byte, 28)
	binary.BigEndian.PutUint32(buf[0:4], reason)
	binary.BigEndian.PutUint32(buf[4:8], winnerID)
	binary.BigEndian.PutUint32(buf[8:12], 0)  // twoTimes
	binary.BigEndian.PutUint32(buf[12:16], 0) // threeTimes
	binary.BigEndian.PutUint32(buf[16:20], 0) // autoFightTimes
	binary.BigEndian.PutUint32(buf[20:24], 0) // energyTimes
	binary.BigEndian.PutUint32(buf[24:28], 0) // learnTimes
	return buf
}

// pushMapOgreListAfterFightOver 对战/捕捉/逃跑结束后推送地图精灵列表（CMD 2004），解决地图不再刷新精灵的问题
func pushMapOgreListAfterFightOver(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	mapID := user.MapID
	if mapID == 0 {
		mapID = 1
	}
	gameogres.InvalidateMap(mapID)
	ogreBody := buildMapOgreList(mapID)
	ctx.GameServer.SendResponse(ctx.ClientData, 2004, ctx.UserID, 0, ogreBody)
	logger.Info(fmt.Sprintf("[2004] 对战结束推送地图精灵列表: UID=%d MapID=%d", ctx.UserID, mapID))
}

// handleUseSkill CMD 2405 使用技能（带战斗状态管理）
// 对齐 Lua: fight_handlers.handleUseSkill
func handleUseSkill(ctx *gameserver.HandlerContext) {
	var skillID uint32
	if len(ctx.Body) >= 4 {
		skillID = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	// ACK
	ctx.GameServer.SendResponse(ctx.ClientData, 2405, ctx.UserID, ctx.SeqID, []byte{})

	// 获取战斗状态
	ctx.GameServer.BattleMu.Lock()
	battle, exists := ctx.GameServer.BattleStates[ctx.UserID]
	if !exists || !battle.IsActive {
		ctx.GameServer.BattleMu.Unlock()
		logger.Warning(fmt.Sprintf("[2405] 战斗状态不存在或已结束，无法使用技能"))
		// 返回错误或结束战斗
		overBody := buildFightOverInfo(0, 0)
		ctx.GameServer.SendResponse(ctx.ClientData, 2506, ctx.UserID, ctx.SeqID, overBody)
		pushMapOgreListAfterFightOver(ctx)
		return
	}
	// 注意：保持锁定直到更新完战斗状态

	logger.Info(fmt.Sprintf("[2405] 使用技能前: PlayerHP=%d/%d EnemyHP=%d/%d",
		battle.PlayerHP, battle.PlayerMaxHP, battle.EnemyHP, battle.EnemyMaxHP))

	// 回合开始：结算异常状态伤害（烧伤/中毒每回合扣 1/8 最大HP，对齐 Lua processStatusEffects）
	gameskills.ProcessStatusEffects(
		&battle.PlayerHP, &battle.EnemyHP,
		battle.PlayerMaxHP, battle.EnemyMaxHP,
		&battle.PlayerStatus, &battle.EnemyStatus)

	// 疲惫 / 睡眠 / 麻痹：可以同时存在，图标各自显示，本回合是否能行动由三者“或”决定
	skipPlayerAction := false
	// 疲惫（status[7]）：使用后若持续>0，每回合结算一次“无法行动”，并递减回合数
	if battle.PlayerStatus[gameskills.StatusIndexFatigue] > 0 {
		skipPlayerAction = true
		battle.PlayerStatus[gameskills.StatusIndexFatigue]--
	}
	// 睡眠（status[8]）：效果与麻痹类似，本回合无法行动，并递减回合数
	if battle.PlayerStatus[gameskills.StatusIndexSleep] > 0 {
		skipPlayerAction = true
		battle.PlayerStatus[gameskills.StatusIndexSleep]--
	}
	// 麻痹（status[0]）：本回合无法行动，并递减回合数
	if battle.PlayerStatus[gameskills.StatusIndexParalysis] > 0 {
		skipPlayerAction = true
		battle.PlayerStatus[gameskills.StatusIndexParalysis]--
	}

	// 玩家攻击：计算伤害（完整版）
	petMgr := gamepets.GetInstance()
	skillMgr := gameskills.GetInstance()
	// 当前出战精灵索引：优先使用 BattleState.ActivePetIndex，保证切换精灵后仍然使用正确的出战精灵，
	// 同时不改变 user.Pets 的顺序，这样战斗结束后背包首发与客户端一致。
	activeIdx := 0
	if battle.ActivePetIndex > 0 && battle.ActivePetIndex < len(user.Pets) {
		activeIdx = battle.ActivePetIndex
	}
	playerPetID := 7
	playerLevel := 5
	playerDV := 31
	if len(user.Pets) > 0 {
		playerPetID = user.Pets[activeIdx].ID
		if user.Pets[activeIdx].Level > 0 {
			playerLevel = user.Pets[activeIdx].Level
		}
		playerDV = user.Pets[activeIdx].DV
	}
	// 获取玩家精灵的性格和 EV
	playerNature := 0
	playerEV := gamepets.EVStats{}
	if len(user.Pets) > 0 {
		playerNature = user.Pets[activeIdx].Nature
		playerEV = user.Pets[activeIdx].GetEVStats()
	}
	playerStats := petMgr.GetStats(playerPetID, playerLevel, playerDV, playerEV, playerNature)

	// 获取技能数据
	skill := skillMgr.Get(int(skillID))
	if skill == nil {
		skill = skillMgr.Get(10001) // 默认技能：撞击
	}

	// 获取敌人精灵数据（敌人 EV 默认为 0）
	enemyPet := petMgr.Get(battle.EnemyID)
	enemyEV := gamepets.EVStats{}
	enemyStats := petMgr.GetStats(battle.EnemyID, battle.EnemyLevel, 15, enemyEV, 0)

	// 伤害计算（对齐你的规则）：
	// Category 4 = 变化/状态技能，无威力，不造成伤害；其余 [(Lv*0.4+2)*Power*Atk/Def/50+2] * STAB * TypeMod * Rand
	attackerPet := petMgr.Get(playerPetID)
	power := uint32(skill.Power)
	if power == 0 && skill.Category != 4 {
		power = 40 // 非状态技能缺威力时默认 40
	}

	// damageCalc 为公式计算得到的理论伤害（不考虑“血量上限”这一物理限制）
	// damage      为实际扣掉的 HP（不会超过目标当前 HP，且考虑“手下留情”等效果）
	damageCalc := uint32(0)
	damage := uint32(0)
	isCritPlayer := false
	if skill.Category != 4 {
		// 选择物理/特殊攻防，并应用强化弱化倍率（battleLv 跟随精灵）
		atk := float64(playerStats.Attack)
		def := float64(enemyStats.Defence)
		atkStage, defStage := 0, 1 // 物理：攻击/防御
		if skill.Category == 2 {
			atk = float64(playerStats.SpAtk)
			def = float64(enemyStats.SpDef)
			atkStage, defStage = 2, 3 // 特殊：特攻/特防
		}
		atk *= gamebattle.GetStatMultiplier(int(battle.PlayerBattleLv[atkStage]))
		def *= gamebattle.GetStatMultiplier(int(battle.EnemyBattleLv[defStage]))
		if def < 1 {
			def = 1
		}
		// 基础伤害（向下取整）
		baseDamage := math.Floor(((float64(playerLevel)*0.4 + 2.0) * float64(power) * atk / def / 50.0) + 2.0)

		// STAB（同属性加成，1.5倍）
		stab := 1.0
		if attackerPet != nil && (skill.Type == attackerPet.Type || (attackerPet.Type2 > 0 && skill.Type == attackerPet.Type2)) {
			stab = 1.5
		}

		// 属性克制
		typeMod := 1.0
		if enemyPet != nil {
			typeMod = gamebattle.GetTypeMultiplierDual(skill.Type, enemyPet.Type, enemyPet.Type2)
		}

		// 随机（217~255）
		randomMod := float64(rand.Intn(255-217+1)+217) / 255.0

		// 暴击：1/16 基础概率（CritRate 表示几分之十六，默认 1）
		critRate := skill.CritRate
		if critRate == 0 {
			critRate = 1
		}
		isCritPlayer := rand.Intn(16) < critRate
		critMod := 1.0
		if isCritPlayer {
			critMod = 1.5
		}

		// 理论伤害（包含各种加成与随机，但还未考虑“血量上限”等裁剪）
		damageCalc = uint32(baseDamage * stab * typeMod * randomMod * critMod)

		// 多段攻击（effect 31）：按参数随机命中次数，直接折算为单次伤害倍数
		// SideEffectArg: minHits maxHits（默认 2~5；示例“连续进行5~8次攻击”）
		if skill.EffectID == 31 {
			effArgs := gameskills.ParseSideEffectArg(skill.SideEffectArg)
			minHits, maxHits := 2, 5
			if len(effArgs) >= 1 {
				minHits = effArgs[0]
			}
			if len(effArgs) >= 2 {
				maxHits = effArgs[1]
			}
			if minHits < 1 {
				minHits = 1
			}
			if maxHits < minHits {
				maxHits = minHits
			}
			hits := rand.Intn(maxHits-minHits+1) + minHits
			// 折算倍数，避免溢出
			if hits > 1 {
				mul := uint64(damageCalc) * uint64(hits)
				if mul > math.MaxUint32 {
					damageCalc = math.MaxUint32
				} else {
					damageCalc = uint32(mul)
				}
			}
		}

		// effect 36 秒杀：命中时 n% 概率秒杀对方
		instantKill := false
		if skill.EffectID == 36 {
			effArgs := gameskills.ParseSideEffectArg(skill.SideEffectArg)
			chance := 5
			if len(effArgs) >= 1 {
				chance = effArgs[0]
			}
			if rand.Intn(100) < chance && battle.EnemyHP > 0 {
				damageCalc = battle.EnemyHP
				instantKill = true
			}
		}

		// 从理论伤害得到实际扣血值
		finalDamage := damageCalc
		if instantKill {
			finalDamage = battle.EnemyHP
		} else {
		// 惩罚（effect 35）：对方能力等级越高伤害越高，附加 sum(正能力等级)*20
		if skill.EffectID == 35 {
			bonus := 0
			for i := 0; i < 6; i++ {
				if battle.EnemyBattleLv[i] > 0 {
					bonus += int(battle.EnemyBattleLv[i]) * 20
				}
			}
			finalDamage += uint32(bonus)
		}
		// 烧伤效果：被烧伤方造成的伤害减半
		if battle.PlayerStatus[gameskills.StatusIndexBurn] > 0 {
			finalDamage = finalDamage / 2
			if finalDamage < 1 {
				finalDamage = 1
			}
		}
		if finalDamage < 1 {
			finalDamage = 1
		}
		// 实际扣血不能超过目标当前 HP
		if finalDamage > battle.EnemyHP {
			finalDamage = battle.EnemyHP
		}
		// 手下留情（effect 8）：不使对方HP低于1
		if skill.EffectID == 8 && finalDamage >= battle.EnemyHP && battle.EnemyHP > 0 {
			finalDamage = battle.EnemyHP - 1
		}
		}
		damage = finalDamage
	}
	// 疲惫时本回合不攻击
	if skipPlayerAction {
		damageCalc = 0
		damage = 0
	}

	// 非疲惫时才扣血并应用技能效果
	effectGainHP := int32(0)
	if !skipPlayerAction {
		battle.EnemyHP -= damage
		if battle.EnemyHP > battle.EnemyMaxHP {
			battle.EnemyHP = 0 // uint 下溢时变为极大值，统一置 0
		}
		var effectRecoil uint32
		effectGainHP, effectRecoil = gameskills.ApplyEffect(skill, damage,
			&battle.PlayerHP, &battle.EnemyHP,
			battle.PlayerMaxHP, battle.EnemyMaxHP,
			&battle.PlayerBattleLv, &battle.EnemyBattleLv,
			&battle.PlayerStatus, &battle.EnemyStatus)
		_ = effectRecoil
	}

	// 敌人反击（如果敌人还活着）；畏缩/睡眠/麻痹 时本回合无法行动
	enemyFlinched := false
	// 害怕（status[6]）：本回合无法行动，并递减回合数
	if battle.EnemyStatus[gameskills.StatusIndexFear] > 0 {
		enemyFlinched = true
		battle.EnemyStatus[gameskills.StatusIndexFear]--
	}
	// 敌方睡眠（status[8]）：效果与麻痹一致，本回合无法行动，并递减回合数
	if battle.EnemyStatus[gameskills.StatusIndexSleep] > 0 {
		enemyFlinched = true
		battle.EnemyStatus[gameskills.StatusIndexSleep]--
	}
	// 敌方麻痹（status[0]）：本回合无法行动，并递减回合数
	enemyParalyzed := false
	if battle.EnemyStatus[gameskills.StatusIndexParalysis] > 0 {
		enemyParalyzed = true
		battle.EnemyStatus[gameskills.StatusIndexParalysis]--
	}

	// 敌人反击（如果敌人还活着且未畏缩、未因麻痹无法行动）
	enemyDamage := uint32(0)     // 实际扣血（不超过我方当前血量，用于结算）
	enemyDamageCalc := uint32(0) // 理论伤害，用于客户端显示 lostHP（与玩家打对方时 damageCalc 一致）
	enemySkillID := uint32(0)
	if battle.EnemyHP > 0 && !enemyFlinched && !enemyParalyzed {
		enemySkill, enemySkillIDSelected := pickEnemySkill(skillMgr, battle.EnemyID, battle.EnemyLevel)
		if enemySkill != nil && enemySkillIDSelected != 0 {
			enemySkillID = enemySkillIDSelected

			// 敌人伤害计算
			enemyPower := uint32(enemySkill.Power)
			if enemyPower == 0 {
				enemyPower = 40
			}
			// 敌方攻防（按技能类别），并应用强化弱化倍率
			enemyAtk := float64(enemyStats.Attack)
			enemyDef := float64(playerStats.Defence)
			enemyAtkStage, enemyDefStage := 0, 1 // 物理：攻击/防御
			if enemySkill.Category == 2 {
				enemyAtk = float64(enemyStats.SpAtk)
				enemyDef = float64(playerStats.SpDef)
				enemyAtkStage, enemyDefStage = 2, 3 // 特殊：特攻/特防
			}
			enemyAtk *= gamebattle.GetStatMultiplier(int(battle.EnemyBattleLv[enemyAtkStage]))
			enemyDef *= gamebattle.GetStatMultiplier(int(battle.PlayerBattleLv[enemyDefStage]))
			if enemyDef < 1 {
				enemyDef = 1
			}
			enemyBaseDamage := math.Floor(((float64(battle.EnemyLevel)*0.4 + 2.0) * float64(enemyPower) * enemyAtk / enemyDef / 50.0) + 2.0)
			enemyStab := 1.0
			if enemyPet != nil && (enemySkill.Type == enemyPet.Type || (enemyPet.Type2 > 0 && enemySkill.Type == enemyPet.Type2)) {
				enemyStab = 1.5
			}
			enemyTypeMod := 1.0
			if attackerPet != nil {
				enemyTypeMod = gamebattle.GetTypeMultiplierDual(enemySkill.Type, attackerPet.Type, attackerPet.Type2)
			}
			enemyRandomMod := float64(rand.Intn(255-217+1)+217) / 255.0
			// 敌人暴击：1/16 基础概率
			enemyCritRate := enemySkill.CritRate
			if enemyCritRate == 0 {
				enemyCritRate = 1
			}
			enemyCritMod := 1.0
			if rand.Intn(16) < enemyCritRate {
				enemyCritMod = 1.5
			}
			enemyFinalDamage := uint32(enemyBaseDamage * enemyStab * enemyTypeMod * enemyRandomMod * enemyCritMod)
			// 敌人多段攻击（effect 31），同样折算为单次伤害倍数
			if enemySkill.EffectID == 31 {
				effArgs := gameskills.ParseSideEffectArg(enemySkill.SideEffectArg)
				minHits, maxHits := 2, 5
				if len(effArgs) >= 1 {
					minHits = effArgs[0]
				}
				if len(effArgs) >= 2 {
					maxHits = effArgs[1]
				}
				if minHits < 1 {
					minHits = 1
				}
				if maxHits < minHits {
					maxHits = minHits
				}
				hits := rand.Intn(maxHits-minHits+1) + minHits
				if hits > 1 {
					mul := uint64(enemyFinalDamage) * uint64(hits)
					if mul > math.MaxUint32 {
						enemyFinalDamage = math.MaxUint32
					} else {
						enemyFinalDamage = uint32(mul)
					}
				}
			}
			// 烧伤效果：被烧伤方（敌人）造成的伤害减半
			if battle.EnemyStatus[gameskills.StatusIndexBurn] > 0 {
				enemyFinalDamage = enemyFinalDamage / 2
				if enemyFinalDamage < 1 {
					enemyFinalDamage = 1
				}
			}
			if enemyFinalDamage < 1 {
				enemyFinalDamage = 1
			}
			// 理论伤害用于客户端显示（对方打我方时显示实际受到的伤害数字，而非仅剩余血量）
			enemyDamageCalc = enemyFinalDamage
			if enemyFinalDamage > battle.PlayerHP {
				enemyFinalDamage = battle.PlayerHP
			}

			enemyDamage = enemyFinalDamage
			battle.PlayerHP -= enemyDamage
			if battle.PlayerHP > battle.PlayerMaxHP {
				battle.PlayerHP = 0 // uint 下溢时置 0
			}
		}
	}

	// 保存敌人反击后的玩家HP（用于 2505 的 remainHP，buildAttackValue 内会再钳位到 [0,maxHP]）
	playerHPAfterCounter := battle.PlayerHP

	// PvP 时需用对方 userID 填第二个 AttackValue，客户端才能正确匹配"对方"血条与图标
	opponentUID := battle.OpponentUserID
	ctx.GameServer.BattleMu.Unlock()

	// 构建 2505 响应：两个 AttackValue（玩家攻击 + 敌人反击）
	// 对齐 Lua / 2407 的约定：
	// - AttackValue.userID 表示“出手方”
	// - lostHP 表示“被攻击方本次损失的血量”
	// - remainHP/maxHP 表示“被攻击方当前血量/最大血量”（用于客户端更新血条）
	enemyUserID := uint32(0)
	if opponentUID != 0 {
		enemyUserID = uint32(opponentUID)
	}
	body := make([]byte, 0, 160)
	// 第一条：玩家攻击敌人
	// - userID = 玩家
	// - lostHP = 敌方本回合“理论伤害”（damageCalc），用于显示大数字
	// - remainHP/maxHP = 玩家当前血量（用于更新己方血条）
	isCritU32 := uint32(0)
	if isCritPlayer {
		isCritU32 = 1
	}
	body = append(body, buildAttackValue(
		uint32(ctx.UserID), skillID, 1,
		damageCalc, effectGainHP,
		int32(playerHPAfterCounter), battle.PlayerMaxHP,
		0, isCritU32, 0,
		battle.PlayerStatus, battle.PlayerBattleLv,
	)...)
	// 第二条：敌人反击玩家
	// - userID = 敌人
	// - lostHP = 对玩家的理论伤害（enemyDamageCalc），用于客户端显示实际受到的伤害数字
	// - remainHP/maxHP = 敌人当前血量（用于更新敌方血条）
	if battle.PlayerHP > 0 {
		body = append(body, buildAttackValue(
			enemyUserID, enemySkillID, 1,
			enemyDamageCalc, 0,
			int32(battle.EnemyHP), battle.EnemyMaxHP,
			0, 0, 0,
			battle.EnemyStatus, battle.EnemyBattleLv,
		)...)
	} else {
		body = append(body, buildAttackValue(
			enemyUserID, enemySkillID, 1,
			enemyDamageCalc, 0,
			int32(battle.EnemyHP), battle.EnemyMaxHP,
			0, 0, 0,
			battle.EnemyStatus, battle.EnemyBattleLv,
		)...)
	}

	ctx.GameServer.SendResponse(ctx.ClientData, 2505, ctx.UserID, ctx.SeqID, body)
	// PvP：向对方也发送 2505（同一 body：first=攻击方，second=对方），对方客户端用 userID 匹配更新我方/对方血条
	if opponentUID != 0 {
		if otherClient := ctx.GameServer.GetClientByUserID(opponentUID); otherClient != nil {
			ctx.GameServer.SendResponse(otherClient, 2505, opponentUID, 0, body)
		}
	}

	logger.Info(fmt.Sprintf("[2405] 使用技能后: PlayerHP=%d/%d EnemyHP=%d/%d Damage=%d EnemyDamage=%d",
		battle.PlayerHP, battle.PlayerMaxHP, battle.EnemyHP, battle.EnemyMaxHP, damage, enemyDamage))

	// 检查战斗是否结束
	isOver := false
	winnerID := uint32(0)

	// 敌方 HP 为 0：直接判定玩家获胜
	if battle.EnemyHP == 0 {
		isOver = true
		winnerID = uint32(ctx.UserID)
		logger.Info(fmt.Sprintf("[2405] 战斗结束: 玩家获胜"))
	} else if battle.PlayerHP == 0 {
		// 我方当前出战精灵 HP 为 0：
		// 如果背包里只剩这一只精灵，则整场战斗失败；
		// 如果还有其它精灵存活，则不立刻结束，交给前端弹出“换宠”面板。
		if len(user.Pets) <= 1 {
			isOver = true
			winnerID = 0 // 敌人获胜
			logger.Info(fmt.Sprintf("[2405] 战斗结束: 敌人获胜（无可用后备精灵）"))
		} else {
			logger.Info("[2405] 当前精灵被击败，但玩家还有其它精灵可用，等待 2407 切换精灵")
		}
	}

	if isOver {
		// 如果玩家获胜，给予经验奖励
		if winnerID == uint32(ctx.UserID) && len(user.Pets) > 0 {
			petMgr := gamepets.GetInstance()
			enemyPet := petMgr.Get(battle.EnemyID)
			// 给予经验（从敌人精灵数据获取，或使用默认值）
			expGain := 50 // 默认经验（当敌人配置里没有 YieldingExp 时）
			if enemyPet != nil && enemyPet.YieldingExp > 0 {
				expGain = enemyPet.YieldingExp
			}
			active := &user.Pets[0]

			// Pet.Exp 语义：当前等级已获得经验（不是总经验）
			// 这里复用 2318（经验池分配）里的自动升级逻辑，避免经验始终为 0 的问题
			if active.Level <= 0 {
				active.Level = 1
			}
			if active.Level > 100 {
				active.Level = 100
				active.Exp = 0
			}

			oldLevel := active.Level
			oldExp := active.Exp

			remain := expGain
			for remain > 0 && active.Level < 100 {
				expInfo := petMgr.GetExpInfo(active.ID, active.Level, active.Exp)

				// 防御：如果 nextLevelExp 计算异常为 0，避免死循环，直接把剩余经验累加到当前等级
				if expInfo.NextLevelExp <= 0 {
					active.Exp += remain
					remain = 0
					break
				}

				need := expInfo.NextLevelExp - active.Exp
				if need > remain {
					// 本级别升不了级，只增加当前等级经验
					active.Exp += remain
					remain = 0
				} else {
					// 升级：扣除当前等级所需经验，等级+1，当前等级经验清零
					active.Exp = 0
					active.Level++
					remain -= need
					if active.Level >= 100 {
						active.Level = 100
						active.Exp = 0
						break
					}
				}
			}

			// 检查是否可以进化（只处理“直接进化”场景：配置里有 EvolvesTo，且不需要道具/进化舱）
			canEvolve, _, evolveTo := petMgr.CanEvolve(active.ID, active.Level, false)
			if canEvolve && evolveTo > 0 {
				logger.Info(fmt.Sprintf("[2405] 精灵进化触发: PetID %d -> %d (Level=%d)", active.ID, evolveTo, active.Level))
				active.ID = evolveTo
				// 进化后当前等级经验清零，重新开始积累
				active.Exp = 0
			}

			logger.Info(fmt.Sprintf(
				"[2405] 战斗胜利: 获得经验 %d (Level %d->%d, Exp %d->%d, PetID=%d)",
				expGain, oldLevel, active.Level, oldExp, active.Exp, active.ID,
			))

			// 首次击败 SPT BOSS 奖励：按 sptboss 配置发放对应精灵（如蘑菇怪→小蘑菇、里奥斯→胡里亚等）
			if entry, ok := sptboss.GetByPetID(battle.EnemyID); ok && entry.RewardPetID > 0 {
				alreadyDefeated := false
				for _, id := range user.DefeatedSPTBossIds {
					if id == battle.EnemyID {
						alreadyDefeated = true
						break
					}
				}
				if !alreadyDefeated {
					user.DefeatedSPTBossIds = append(user.DefeatedSPTBossIds, battle.EnemyID)
					newCatchTime := int(time.Now().Unix())
					rand.Seed(time.Now().UnixNano() + int64(newCatchTime))
					newPet := userdb.Pet{
						ID:        entry.RewardPetID,
						CatchTime: newCatchTime,
						// 闪光波克尔奖励：80 级满个体
						Level: func() int {
							if entry.RewardPetID == 166 {
								return 80
							}
							return 1
						}(),
						DV: func() int {
							if entry.RewardPetID == 166 {
								return 31
							}
							return rand.Intn(32)
						}(),
						Nature: rand.Intn(25),
						Exp:    0,
						Name:   "",
					}
					user.Pets = append(user.Pets, newPet)
					if ctx.GameServer.UserDB != nil {
						ctx.GameServer.UserDB.RecordCatch(ctx.UserID, entry.RewardPetID)
					}
					logger.Info(fmt.Sprintf("[2405] 首次击败 SPT BOSS PetID=%d，奖励精灵 PetID=%d CatchTime=%d", battle.EnemyID, entry.RewardPetID, newCatchTime))
				}
			} else if _, ok := sptboss.GetByPetID(battle.EnemyID); ok {
				// SPT BOSS 无奖励精灵，仅记录击败成就
				alreadyDefeated := false
				for _, id := range user.DefeatedSPTBossIds {
					if id == battle.EnemyID {
						alreadyDefeated = true
						break
					}
				}
				if !alreadyDefeated {
					user.DefeatedSPTBossIds = append(user.DefeatedSPTBossIds, battle.EnemyID)
				}
			}

			// 保存数据
			if ctx.GameServer.UserDB != nil {
				ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
			}

			// 发送 NOTE_UPDATE_PROP(2508)，驱动“战斗结束属性结算面板”
			activePet := user.Pets[0]
			ev := gamepets.ClampAndCapEV(activePet.GetEVStats())
			stats := petMgr.GetStats(activePet.ID, activePet.Level, activePet.DV, ev, activePet.Nature)
			// 这里的 currentLevelExp 直接使用 Pet.Exp（“当前等级已获得经验”），
			// 前端会用 NOTE_UPDATE_PROP 与之前的 PetInfo 做差得到“获得经验”数值
			propBody := buildNoteUpdateProp(uint32(activePet.CatchTime), activePet.ID, activePet.Level, activePet.Exp,
				stats.MaxHP, stats.Attack, stats.Defence, stats.SpAtk, stats.SpDef, stats.Speed, ev)
			ctx.GameServer.SendResponse(ctx.ClientData, 2508, ctx.UserID, ctx.SeqID, propBody)
		}

		overBody := buildFightOverInfo(0, winnerID)
		ctx.GameServer.SendResponse(ctx.ClientData, 2506, ctx.UserID, ctx.SeqID, overBody)
		pushMapOgreListAfterFightOver(ctx)
		// PvP：向对方也发送 2506 并清理状态，否则对方对战不退出
		opponentUID := battle.OpponentUserID
		ctx.GameServer.BattleMu.Lock()
		delete(ctx.GameServer.BattleStates, ctx.UserID)
		if opponentUID != 0 {
			delete(ctx.GameServer.BattleStates, opponentUID)
		}
		ctx.GameServer.BattleMu.Unlock()
		if opponentUID != 0 {
			if otherClient := ctx.GameServer.GetClientByUserID(opponentUID); otherClient != nil {
				ctx.GameServer.SendResponse(otherClient, 2506, opponentUID, 0, overBody)
				userOpp := ctx.GameServer.GetOrCreateUser(opponentUID)
				mapID := userOpp.MapID
				if mapID == 0 {
					mapID = 1
				}
				gameogres.InvalidateMap(mapID)
				ogreBody := buildMapOgreList(mapID)
				ctx.GameServer.SendResponse(otherClient, 2004, opponentUID, 0, ogreBody)
			}
		}
	}
}

// handleUsePetItem CMD 2406 使用道具（最小可用版本）
// 对齐 Lua: fight_handlers.handleUsePetItem
func handleUsePetItem(ctx *gameserver.HandlerContext) {
	var itemID uint32
	if len(ctx.Body) >= 8 {
		_ = binary.BigEndian.Uint32(ctx.Body[0:4]) // catchTime，目前逻辑中未使用
		itemID = binary.BigEndian.Uint32(ctx.Body[4:8])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	// 检查道具是否存在
	itemKey := strconv.FormatUint(uint64(itemID), 10)
	item, hasItem := user.Items[itemKey]
	if !hasItem || item.Count <= 0 {
		// 错误响应：errorCode = 10301（道具不足）
		ctx.GameServer.SendResponse(ctx.ClientData, 2406, ctx.UserID, ctx.SeqID, []byte{})
		return
	}

	// 扣除道具
	item.Count--
	if item.Count <= 0 {
		delete(user.Items, itemKey)
	} else {
		user.Items[itemKey] = item
	}

	// 简化：统一按 30 点固定体力药处理（可按 itemID 精细化）
	healHP := int32(30)

	// 在战斗中优先使用 BattleState 的 HP；否则退回到宠物当前 HP
	currentHP := int32(0)
	maxHP := uint32(0)

	ctx.GameServer.BattleMu.Lock()
	battle, inBattle := ctx.GameServer.BattleStates[ctx.UserID]
	if inBattle && battle.IsActive {
		currentHP = int32(battle.PlayerHP)
		maxHP = battle.PlayerMaxHP
	} else if len(user.Pets) > 0 {
		petMgr := gamepets.GetInstance()
		// 默认使用首发精灵（与战斗外逻辑一致）
		petNature := user.Pets[0].Nature
		petEV := user.Pets[0].GetEVStats()
		petStats := petMgr.GetStats(user.Pets[0].ID, user.Pets[0].Level, user.Pets[0].DV, petEV, petNature)
		currentHP = int32(petStats.HP)
		maxHP = uint32(petStats.MaxHP)
	}

	if maxHP > 0 {
		if currentHP+healHP > int32(maxHP) {
			healHP = int32(maxHP) - currentHP
			currentHP = int32(maxHP)
		} else {
			currentHP += healHP
		}
	}

	// 回写战斗中的 HP
	if inBattle && battle.IsActive {
		if currentHP < 0 {
			currentHP = 0
		}
		battle.PlayerHP = uint32(currentHP)
		battle.PlayerMaxHP = maxHP
	}
	ctx.GameServer.BattleMu.Unlock()

	// 响应：userId(4) + itemId(4) + hp(4) + changeHp(4)
	body := make([]byte, 16)
	binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
	binary.BigEndian.PutUint32(body[4:8], itemID)
	binary.BigEndian.PutUint32(body[8:12], uint32(currentHP))
	// changeHp 是有符号整数，需要转换
	if healHP < 0 {
		binary.BigEndian.PutUint32(body[12:16], uint32(math.MaxUint32+int64(healHP)+1))
	} else {
		binary.BigEndian.PutUint32(body[12:16], uint32(healHP))
	}

	ctx.GameServer.SendResponse(ctx.ClientData, 2406, ctx.UserID, ctx.SeqID, body)

	// 保存数据
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	// 若在战斗中，使用 HP 药也视为本回合行动，立刻结算敌方一次攻击（与 2407 切换精灵一致）
	if inBattle && battle.IsActive {
		petMgr := gamepets.GetInstance()

		ctx.GameServer.BattleMu.Lock()
		curBattle, ok := ctx.GameServer.BattleStates[ctx.UserID]
		if !ok || !curBattle.IsActive {
			ctx.GameServer.BattleMu.Unlock()
			return
		}

		skillMgr := gameskills.GetInstance()
		enemySkill, enemySkillID := pickEnemySkill(skillMgr, curBattle.EnemyID, curBattle.EnemyLevel)
		if enemySkill == nil || enemySkillID == 0 {
			// 敌人本回合不出招
			ctx.GameServer.BattleMu.Unlock()
			return
		}

		// 控制类异常：畏缩/睡眠/麻痹 时敌方本回合无法行动（与 2405 一致）
		enemyFlinched := false
		if curBattle.EnemyStatus[gameskills.StatusIndexFear] > 0 {
			enemyFlinched = true
			curBattle.EnemyStatus[gameskills.StatusIndexFear]--
		}
		if curBattle.EnemyStatus[gameskills.StatusIndexSleep] > 0 {
			enemyFlinched = true
			curBattle.EnemyStatus[gameskills.StatusIndexSleep]--
		}
		enemyParalyzed := false
		if curBattle.EnemyStatus[gameskills.StatusIndexParalysis] > 0 {
			enemyParalyzed = true
			curBattle.EnemyStatus[gameskills.StatusIndexParalysis]--
		}
		if enemyFlinched || enemyParalyzed {
			enemySkillID = 0
		}

		enemyDamageCalc := uint32(0)
		enemyDamage := uint32(0)
		if !enemyFlinched && !enemyParalyzed {
		// 敌人属性
		enemyEV := gamepets.EVStats{}
		enemyStats := petMgr.GetStats(curBattle.EnemyID, curBattle.EnemyLevel, 15, enemyEV, 0)

		// 我方当前出战精灵属性（按 BattleState.PlayerHP/PlayerMaxHP 对应的精灵获取）
		// 这里简化为使用 user.Pets[0] 的属性，仅用于防御端数值计算；真正 HP 以 BattleState 为准
		playerStatsAfterHeal := gamepets.Stats{
			MaxHP: int(curBattle.PlayerMaxHP),
			HP:    int(curBattle.PlayerHP),
		}

		enemyPower := uint32(enemySkill.Power)
		if enemyPower == 0 {
			enemyPower = 40
		}

		// 敌方攻防（按技能类别），并应用强化弱化倍率
		enemyAtk := float64(enemyStats.Attack)
		enemyDef := float64(playerStatsAfterHeal.Defence)
		enemyAtkStage, enemyDefStage := 0, 1
		if enemySkill.Category == 2 {
			enemyAtk = float64(enemyStats.SpAtk)
			enemyDef = float64(playerStatsAfterHeal.SpDef)
			enemyAtkStage, enemyDefStage = 2, 3
		}
		enemyAtk *= gamebattle.GetStatMultiplier(int(curBattle.EnemyBattleLv[enemyAtkStage]))
		enemyDef *= gamebattle.GetStatMultiplier(int(curBattle.PlayerBattleLv[enemyDefStage]))
		if enemyDef < 1 {
			enemyDef = 1
		}

		enemyBaseDamage := math.Floor(((float64(curBattle.EnemyLevel)*0.4 + 2.0) * float64(enemyPower) * enemyAtk / enemyDef / 50.0) + 2.0)

		enemyStab := 1.0
		if enemyPetDef := petMgr.Get(curBattle.EnemyID); enemyPetDef != nil && (enemySkill.Type == enemyPetDef.Type || (enemyPetDef.Type2 > 0 && enemySkill.Type == enemyPetDef.Type2)) {
			enemyStab = 1.5
		}

		enemyTypeMod := 1.0
		if len(user.Pets) > 0 {
			if attackerPetDef := petMgr.Get(user.Pets[0].ID); attackerPetDef != nil {
				enemyTypeMod = gamebattle.GetTypeMultiplierDual(enemySkill.Type, attackerPetDef.Type, attackerPetDef.Type2)
			}
		}

		enemyRandomMod := float64(rand.Intn(255-217+1)+217) / 255.0
		enemyFinalDamage := uint32(enemyBaseDamage * enemyStab * enemyTypeMod * enemyRandomMod)
		if curBattle.EnemyStatus[gameskills.StatusIndexBurn] > 0 {
			enemyFinalDamage = enemyFinalDamage / 2
			if enemyFinalDamage < 1 {
				enemyFinalDamage = 1
			}
		}
		if enemyFinalDamage < 1 {
			enemyFinalDamage = 1
		}
		enemyDamageCalc = enemyFinalDamage // 理论伤害，用于客户端显示
		if enemyFinalDamage > curBattle.PlayerHP {
			enemyFinalDamage = curBattle.PlayerHP
		}

		enemyDamage = enemyFinalDamage

		// 更新玩家 HP
		curBattle.PlayerHP -= enemyDamage
		if curBattle.PlayerHP > curBattle.PlayerMaxHP {
			curBattle.PlayerHP = 0
		}
		}

		opponentUID := curBattle.OpponentUserID
		enemyStatusFor2505 := curBattle.EnemyStatus   // 敌方异常状态和强化弱化跟随精灵，需正确下发
		enemyBattleLvFor2505 := curBattle.EnemyBattleLv
		ctx.GameServer.BattleMu.Unlock()

		// 构造 2505，通知前端敌人攻击一次（status/battleLv 用敌方实际值）
		body2505 := make([]byte, 0, 80)
		enemyUserID := uint32(0)
		if opponentUID != 0 {
			enemyUserID = uint32(opponentUID)
		}

		body2505 = append(body2505, buildAttackValue(
			enemyUserID, enemySkillID, 1,
			enemyDamageCalc, 0,
			int32(curBattle.EnemyHP), curBattle.EnemyMaxHP,
			0, 0, 0,
			enemyStatusFor2505, enemyBattleLvFor2505,
		)...)

		ctx.GameServer.SendResponse(ctx.ClientData, 2505, ctx.UserID, ctx.SeqID, body2505)
		if opponentUID != 0 {
			if otherClient := ctx.GameServer.GetClientByUserID(opponentUID); otherClient != nil {
				ctx.GameServer.SendResponse(otherClient, 2505, opponentUID, 0, body2505)
			}
		}
	}
}

// buildNoteUpdateProp 构建 CMD 2508 NOTE_UPDATE_PROP
// 对齐前端解析：
// PetUpdatePropInfo:
//
//	addition(4) + count(4) + UpdatePropInfo * count
//
// UpdatePropInfo:
//
//	catchTime(4) + id(4) + level(4) +
//	exp(4) + currentLvExp(4) + nextLvExp(4) +   // exp=总经验, currentLvExp=当前等级经验
//	maxHp(4) + atk(4) + def(4) + sa(4) + sd(4) + sp(4) +
//	ev_hp(4) + ev_a(4) + ev_d(4) + ev_sa(4) + ev_sd(4) + ev_sp(4)
func buildNoteUpdateProp(catchTime uint32, petID int, level int, currentLevelExp int, maxHP int, attack, defence, spAtk, spDef, speed int, ev gamepets.EVStats) []byte {
	petMgr := gamepets.GetInstance()
	expInfo := petMgr.GetExpInfo(petID, level, currentLevelExp)

	addition := uint32(0) // /100 为加成倍率，先按 0（无额外加成）
	count := uint32(1)

	body := make([]byte, 0, 8+72)
	putU32 := func(v uint32) {
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, v)
		body = append(body, tmp...)
	}

	// PetUpdatePropInfo header
	putU32(addition)
	putU32(count)

	// UpdatePropInfo
	putU32(catchTime)
	putU32(uint32(petID))
	putU32(uint32(level))
	// 与 2301 保持语义一致：
	// - exp: 当前等级已获得经验（与 2301 一致，避免经验分配器“升级所需经验值”为负）
	// - currentLvExp: 当前等级已获得经验
	// - nextLvExp: 升级到下一等级所需经验
	putU32(uint32(expInfo.CurrentLevelExp)) // exp（当前等级经验）
	putU32(uint32(expInfo.CurrentLevelExp)) // currentLvExp（当前等级经验）
	putU32(uint32(expInfo.NextLevelExp))    // nextLvExp
	putU32(uint32(maxHP))
	putU32(uint32(attack))
	putU32(uint32(defence))
	putU32(uint32(spAtk))
	putU32(uint32(spDef))
	putU32(uint32(speed))
	putU32(uint32(ev.HP))
	putU32(uint32(ev.Atk))
	putU32(uint32(ev.Def))
	putU32(uint32(ev.SpAtk))
	putU32(uint32(ev.SpDef))
	putU32(uint32(ev.Spd))

	return body
}

// buildNoteUpdateSkill 构建 CMD 2507 NOTE_UPDATE_SKILL
// 对齐前端 PetUpdateSkillInfo + UpdateSkillInfo 解析：
//
//	PetUpdateSkillInfo: count(4) + [UpdateSkillInfo]*count
//	UpdateSkillInfo: catchTime(4) + activeCount(4) + unactiveCount(4) + [activeId(4)]*activeCount + [unactiveId(4)]*unactiveCount
//
// activeSkills=当前技能(可被替换)，unactiveSkills=新学会的技能
func buildNoteUpdateSkill(catchTime uint32, petID int, oldLevel int, newSkillIDs []int) []byte {
	petMgr := gamepets.GetInstance()
	currentSkills := petMgr.GetSkillsForLevel(petID, oldLevel)
	var activeIDs []int
	for _, sid := range currentSkills {
		if sid > 0 {
			activeIDs = append(activeIDs, sid)
		}
	}
	body := make([]byte, 0, 20+len(activeIDs)*4+len(newSkillIDs)*4)
	putU32 := func(v uint32) {
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, v)
		body = append(body, tmp...)
	}
	putU32(1) // count=1，一个 UpdateSkillInfo
	putU32(catchTime)
	putU32(uint32(len(activeIDs)))
	putU32(uint32(len(newSkillIDs)))
	for _, id := range activeIDs {
		putU32(uint32(id))
	}
	for _, id := range newSkillIDs {
		putU32(uint32(id))
	}
	return body
}

// handleChangePet CMD 2407 切换精灵
// 对齐 Lua: fight_handlers.handleChangePet
func handleChangePet(ctx *gameserver.HandlerContext) {
	var reqCatchTime uint32
	if len(ctx.Body) >= 4 {
		reqCatchTime = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	logger.Info(fmt.Sprintf("[2407] 收到切换精灵请求: reqCatchTime=%d", reqCatchTime))

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	// 打印所有精灵信息
	logger.Info(fmt.Sprintf("[2407] 玩家精灵列表: 共%d只", len(user.Pets)))
	for i, pet := range user.Pets {
		logger.Info(fmt.Sprintf("[2407]   [%d] PetID=%d CatchTime=%d Level=%d", i, pet.ID, pet.CatchTime, pet.Level))
	}

	// 查找精灵
	var picked *userdb.Pet
	var pickedIndex int = -1
	if reqCatchTime != 0 {
		for i := range user.Pets {
			if uint32(user.Pets[i].CatchTime) == reqCatchTime {
				picked = &user.Pets[i]
				pickedIndex = i
				logger.Info(fmt.Sprintf("[2407] 找到匹配的精灵: index=%d PetID=%d", i, user.Pets[i].ID))
				break
			}
		}
	}
	if picked == nil && len(user.Pets) > 0 {
		picked = &user.Pets[0]
		pickedIndex = 0
		logger.Info(fmt.Sprintf("[2407] 未找到匹配精灵，使用第一只: PetID=%d", user.Pets[0].ID))
	}

	if picked == nil {
		// 错误响应（使用空包）
		logger.Warning("[2407] 没有可用的精灵")
		ctx.GameServer.SendResponse(ctx.ClientData, 2407, ctx.UserID, ctx.SeqID, []byte{})
		return
	}

	petMgr := gamepets.GetInstance()
	petEV := picked.GetEVStats()
	petStats := petMgr.GetStats(picked.ID, picked.Level, picked.DV, petEV, picked.Nature)

	logger.Info(fmt.Sprintf("[2407] 选中精灵: PetID=%d HP=%d/%d", picked.ID, petStats.HP, petStats.MaxHP))

	// 检查精灵是否还有HP
	if petStats.HP <= 0 {
		// 错误响应：精灵已死亡
		logger.Warning(fmt.Sprintf("[2407] 精灵HP为0，无法切换: PetID=%d", picked.ID))
		errorBody := make([]byte, 8)
		binary.BigEndian.PutUint32(errorBody[0:4], uint32(ctx.UserID))
		binary.BigEndian.PutUint32(errorBody[4:8], 1) // 错误码：精灵已死亡
		ctx.GameServer.SendResponse(ctx.ClientData, 2407, ctx.UserID, ctx.SeqID, errorBody)
		return
	}

	// 响应 2407（严格对齐前端 ChangePetInfo 的解析顺序）:
	// userId(4) + petId(4) + petName(16) + level(4) + hp(4) + maxHp(4) + catchTime(4)
	body := make([]byte, 40)
	binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
	binary.BigEndian.PutUint32(body[4:8], uint32(picked.ID))
	nameBytes := []byte(picked.Name)
	if len(nameBytes) > 16 {
		nameBytes = nameBytes[:16]
	}
	copy(body[8:24], nameBytes)
	// 字段顺序必须与 AS3 `ChangePetInfo` 一致，否则前端血条/等级会错乱
	binary.BigEndian.PutUint32(body[24:28], uint32(picked.Level))
	binary.BigEndian.PutUint32(body[28:32], uint32(petStats.HP))
	binary.BigEndian.PutUint32(body[32:36], uint32(petStats.MaxHP))
	binary.BigEndian.PutUint32(body[36:40], uint32(picked.CatchTime))

	// 调试：打印 2407 包体的字段值与十六进制，方便对照前端 ChangePetInfo
	logger.Info(fmt.Sprintf("[2407] RESP body fields: userID=%d petID=%d level=%d hp=%d maxHp=%d catchTime=%d",
		ctx.UserID, picked.ID, picked.Level, petStats.HP, petStats.MaxHP, picked.CatchTime))
	hexStr := ""
	for i, b := range body {
		if i > 0 && i%4 == 0 {
			hexStr += " "
		}
		hexStr += fmt.Sprintf("%02X", b)
	}
	logger.Info(fmt.Sprintf("[2407] RESP raw hex: %s", hexStr))

	// 保存选中的精灵ID和等级（目前仅用于日志调试）
	selectedPetID := picked.ID
	selectedPetLevel := picked.Level

	// 更新战斗状态中的当前出战精灵下标，而不改变 user.Pets 的顺序，
	// 这样战斗结束后背包首发仍然与客户端显示一致。
	playerWasDead := false // 上一只精灵是否被击败（强制切换 vs 主动切换）
	ctx.GameServer.BattleMu.Lock()
	if battle, exists := ctx.GameServer.BattleStates[ctx.UserID]; exists && battle != nil && battle.IsActive {
		playerWasDead = (battle.PlayerHP == 0) // 在更新前保存：被击败后切换视为新战斗开始
		battle.ActivePetIndex = pickedIndex
		// 切换精灵时重置我方异常状态和强化弱化（新精灵上场为干净状态）；敌方/野生精灵的 status 和 battleLv 不重置
		battle.PlayerStatus = [20]byte{}
		battle.PlayerBattleLv = [6]int8{}
		// 同时更新当前血量与最大血量，保证后续 2405 使用正确的 HP
		hp := petStats.HP
		if hp < 0 {
			hp = 0
		}
		if hp > petStats.MaxHP {
			hp = petStats.MaxHP
		}
		battle.PlayerHP = uint32(hp)
		battle.PlayerMaxHP = uint32(petStats.MaxHP)
	}
	ctx.GameServer.BattleMu.Unlock()

	// 发送 2407 响应
	// 注意：不再发送 2301、2508、2504，因为：
	// 1. _petInfoMap 在战斗开始时已经包含了所有精灵信息（通过 buildNoteReadyToFightInfo）
	// 2. 2504 会导致前端重新创建精灵模型，造成精灵重叠
	// 3. 2508 属性更新在切换时不需要
	ctx.GameServer.SendResponse(ctx.ClientData, 2407, ctx.UserID, ctx.SeqID, body)

	// 更新战斗状态，并保存敌方当前 HP 供后续 2505 第二条使用（避免误发“满血”导致客户端显示虚假回血 +N）
	var enemyHPFor2505, enemyMaxHPFor2505 uint32
	ctx.GameServer.BattleMu.Lock()
	battle, exists := ctx.GameServer.BattleStates[ctx.UserID]
	if exists && battle.IsActive {
		enemyHPFor2505 = battle.EnemyHP
		enemyMaxHPFor2505 = battle.EnemyMaxHP
		// 更新玩家HP，钳位到 [0, MaxHP] 保证血条范围有效
		hp := petStats.HP
		if hp < 0 {
			hp = 0
		}
		if hp > petStats.MaxHP {
			hp = petStats.MaxHP
		}
		battle.PlayerHP = uint32(hp)
		battle.PlayerMaxHP = uint32(petStats.MaxHP)
		logger.Info(fmt.Sprintf("[2407] 更新战斗状态: PlayerHP=%d/%d PetID=%d 敌方HP=%d/%d(供2505)", battle.PlayerHP, battle.PlayerMaxHP, selectedPetID, enemyHPFor2505, enemyMaxHPFor2505))
		// PvP 模式：同时更新对方 BattleState 中的 EnemyID（我方切换后的 petID）
		// 谁切换则谁的新精灵为干净状态；对方视角的 Enemy 就是切换方的新精灵，需重置 EnemyStatus/EnemyBattleLv
		if battle.OpponentUserID != 0 {
			if opponentBattle, opponentExists := ctx.GameServer.BattleStates[battle.OpponentUserID]; opponentExists && opponentBattle.IsActive {
				opponentBattle.EnemyID = selectedPetID
				opponentBattle.EnemyLevel = selectedPetLevel
				opponentBattle.EnemyHP = uint32(hp)
				opponentBattle.EnemyMaxHP = uint32(petStats.MaxHP)
				opponentBattle.EnemyStatus = [20]byte{}   // 切换方新精灵上场，重置其异常状态
				opponentBattle.EnemyBattleLv = [6]int8{}  // 重置其强化弱化
				logger.Info(fmt.Sprintf("[2407] 更新对方战斗状态: OpponentUID=%d EnemyID=%d EnemyHP=%d/%d", battle.OpponentUserID, selectedPetID, petStats.HP, petStats.MaxHP))
			}
		}
	}
	ctx.GameServer.BattleMu.Unlock()

	// 如果战斗中，且为主动切换（上一只精灵未死）：敌方立刻行动一回合（换宠消耗回合）
	// 若为强制切换（上一只精灵被击败）：视为新战斗开始，敌方本回合已出招击杀，不再攻击新上场的精灵。
	if playerWasDead && exists && battle.IsActive {
		logger.Info("[2407] 强制切换（上一只精灵被击败），视为新战斗开始，敌方本回合不再攻击")
	}
	// 注意：不再发送 2508 和 2504，因为：
	// 1. 2504 会导致前端重新创建精灵模型，造成精灵重叠
	// 2. 2508 属性更新在切换时不需要
	// 只发送 2505（敌方攻击）
	if exists && battle.IsActive && !playerWasDead {
		petMgr := gamepets.GetInstance()

		// ==================== 敌方立刻行动一回合（换宠消耗回合，Lua 版 2407 也会触发一次 executeTurn）====================
		// 这里只实现 PvE 简化逻辑：敌人使用默认技能 10001 攻击玩家一次，构造 2505。

		// 重新加锁，使用最新的战斗状态并写回本回合结果
		ctx.GameServer.BattleMu.Lock()
		curBattle, ok := ctx.GameServer.BattleStates[ctx.UserID]
		if !ok || !curBattle.IsActive {
			ctx.GameServer.BattleMu.Unlock()
			return
		}

		skillMgr := gameskills.GetInstance()
		enemySkill, enemySkillID := pickEnemySkill(skillMgr, curBattle.EnemyID, curBattle.EnemyLevel)
		if enemySkill == nil || enemySkillID == 0 {
			// 敌人本回合不出招：不做任何反击，直接返回
			ctx.GameServer.BattleMu.Unlock()
			return
		}

		// 控制类异常：畏缩/睡眠/麻痹 时敌方本回合无法行动（与 2405 一致）
		enemyFlinched := false
		if curBattle.EnemyStatus[gameskills.StatusIndexFear] > 0 {
			enemyFlinched = true
			curBattle.EnemyStatus[gameskills.StatusIndexFear]--
		}
		if curBattle.EnemyStatus[gameskills.StatusIndexSleep] > 0 {
			enemyFlinched = true
			curBattle.EnemyStatus[gameskills.StatusIndexSleep]--
		}
		enemyParalyzed := false
		if curBattle.EnemyStatus[gameskills.StatusIndexParalysis] > 0 {
			enemyParalyzed = true
			curBattle.EnemyStatus[gameskills.StatusIndexParalysis]--
		}
		if enemyFlinched || enemyParalyzed {
			enemySkillID = 0 // 受控制未出招，不发送技能 ID
		}

		// 敌人属性（与 2405 中一致）
		enemyEV := gamepets.EVStats{}
		enemyStats := petMgr.GetStats(curBattle.EnemyID, curBattle.EnemyLevel, 15, enemyEV, 0)

		// 玩家属性：使用当前切换后的精灵战斗属性
		playerStatsAfterSwitch := petStats

		enemyDamage := uint32(0)
		enemyDamageCalc := uint32(0)
		if !enemyFlinched && !enemyParalyzed {
		enemyPower := uint32(enemySkill.Power)
		if enemyPower == 0 {
			enemyPower = 40
		}

		// 敌方攻防（按技能类别），并应用强化弱化倍率（切换后我方 battleLv 已重置为 0）
		enemyAtk := float64(enemyStats.Attack)
		enemyDef := float64(playerStatsAfterSwitch.Defence)
		enemyAtkStage, enemyDefStage := 0, 1
		if enemySkill.Category == 2 {
			enemyAtk = float64(enemyStats.SpAtk)
			enemyDef = float64(playerStatsAfterSwitch.SpDef)
			enemyAtkStage, enemyDefStage = 2, 3
		}
		enemyAtk *= gamebattle.GetStatMultiplier(int(curBattle.EnemyBattleLv[enemyAtkStage]))
		enemyDef *= gamebattle.GetStatMultiplier(int(curBattle.PlayerBattleLv[enemyDefStage]))
		if enemyDef < 1 {
			enemyDef = 1
		}

		enemyBaseDamage := math.Floor(((float64(curBattle.EnemyLevel)*0.4 + 2.0) * float64(enemyPower) * enemyAtk / enemyDef / 50.0) + 2.0)

		enemyStab := 1.0
		if enemyPetDef := petMgr.Get(curBattle.EnemyID); enemyPetDef != nil && (enemySkill.Type == enemyPetDef.Type || (enemyPetDef.Type2 > 0 && enemySkill.Type == enemyPetDef.Type2)) {
			enemyStab = 1.5
		}

		enemyTypeMod := 1.0
		if attackerPetDef := petMgr.Get(selectedPetID); attackerPetDef != nil {
			enemyTypeMod = gamebattle.GetTypeMultiplierDual(enemySkill.Type, attackerPetDef.Type, attackerPetDef.Type2)
		}

		enemyRandomMod := float64(rand.Intn(255-217+1)+217) / 255.0
		enemyFinalDamage := uint32(enemyBaseDamage * enemyStab * enemyTypeMod * enemyRandomMod)
		if curBattle.EnemyStatus[gameskills.StatusIndexBurn] > 0 {
			enemyFinalDamage = enemyFinalDamage / 2
			if enemyFinalDamage < 1 {
				enemyFinalDamage = 1
			}
		}
		if enemyFinalDamage < 1 {
			enemyFinalDamage = 1
		}
		enemyDamageCalc = enemyFinalDamage // 理论伤害，用于客户端显示
		if enemyFinalDamage > curBattle.PlayerHP {
			enemyFinalDamage = curBattle.PlayerHP
		}

		enemyDamage = enemyFinalDamage

		// 更新玩家 HP
		curBattle.PlayerHP -= enemyDamage
		if curBattle.PlayerHP > curBattle.PlayerMaxHP {
			curBattle.PlayerHP = 0
		}
		}

		// 记录更新后的 HP、敌方 status/battleLv（用于构造 2505），然后解锁
		opponentUID := curBattle.OpponentUserID
		enemyStatusFor2505 := curBattle.EnemyStatus   // 敌方异常状态和强化弱化跟随精灵，不重置，需正确下发
		enemyBattleLvFor2505 := curBattle.EnemyBattleLv
		ctx.GameServer.BattleMu.Unlock()

		// 构造 2505：第一条为敌人攻击玩家，第二条为占位（使用切换前保存的敌方 HP，避免客户端误显示“+N”回血）
		body2505 := make([]byte, 0, 160)

		// 敌人 userID：PvE 为 0，PvP 为对方 UID
		enemyUserID := uint32(0)
		if opponentUID != 0 {
			enemyUserID = uint32(opponentUID)
		}

		// 第一条：敌人攻击玩家（status/battleLv 用敌方实际值，客户端才能正确显示对方异常与强化弱化）
		body2505 = append(body2505, buildAttackValue(enemyUserID, enemySkillID, 1, enemyDamageCalc, 0, int32(curBattle.EnemyHP), curBattle.EnemyMaxHP, 0, 0, 0, enemyStatusFor2505, enemyBattleLvFor2505)...)

		// 第二条：占位，同步敌方血条。必须用 enemyUserID（敌方），因前端按 attackValue.userID 更新对应方血条；status/battleLv 同样下发敌方实际值
		if enemyMaxHPFor2505 == 0 {
			enemyMaxHPFor2505 = 1
		}
		body2505 = append(body2505, buildAttackValue(enemyUserID, 0, 0, 0, 0, int32(enemyHPFor2505), enemyMaxHPFor2505, 0, 0, 0, enemyStatusFor2505, enemyBattleLvFor2505)...)

		ctx.GameServer.SendResponse(ctx.ClientData, 2505, ctx.UserID, ctx.SeqID, body2505)
		if opponentUID != 0 {
			if otherClient := ctx.GameServer.GetClientByUserID(opponentUID); otherClient != nil {
				ctx.GameServer.SendResponse(otherClient, 2505, opponentUID, 0, body2505)
			}
		}
	}
}

// handleCatchMonster CMD 2409 捕捉精灵
// 对齐 Lua: fight_handlers.handleCatchMonster
func handleCatchMonster(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	ctx.GameServer.BattleMu.Lock()
	battle, exists := ctx.GameServer.BattleStates[ctx.UserID]
	if exists && battle.IsActive && battle.OpponentUserID != 0 {
		ctx.GameServer.BattleMu.Unlock()
		// PvP 模式下不可捕捉对方精灵：返回空/失败，客户端会显示“赛尔间对战无法捕捉”等
		ctx.GameServer.SendResponse(ctx.ClientData, 2409, ctx.UserID, ctx.SeqID, []byte{})
		logger.Info(fmt.Sprintf("[2409] PvP 模式拒绝捕捉: UID=%d", ctx.UserID))
		return
	}
	bossID := 13
	bossLevel := 5
	if exists && battle.IsActive {
		bossID = battle.EnemyID
		bossLevel = battle.EnemyLevel
		logger.Info(fmt.Sprintf("[2409] 从战斗状态获取: EnemyID=%d EnemyLevel=%d", bossID, bossLevel))
	} else {
		logger.Warning(fmt.Sprintf("[2409] 未找到战斗状态，使用默认值: EnemyID=%d EnemyLevel=%d", bossID, bossLevel))
	}
	ctx.GameServer.BattleMu.Unlock()

	// 生成唯一的捕捉时间
	newCatchTime := uint32(time.Now().Unix())

	// 随机化精灵属性（但等级与对战中的敌人等级一致）
	rand.Seed(time.Now().UnixNano() + int64(newCatchTime))
	// 等级与对战中的敌人等级一致
	catchLevel := bossLevel
	// 随机个体值（0-31）
	randomDV := rand.Intn(32)
	// 随机性格（0-24）
	randomNature := rand.Intn(25)

	// 响应 2409: catchTime(4) + petId(4)
	body := make([]byte, 8)
	binary.BigEndian.PutUint32(body[0:4], newCatchTime)
	binary.BigEndian.PutUint32(body[4:8], uint32(bossID))

	ctx.GameServer.SendResponse(ctx.ClientData, 2409, ctx.UserID, ctx.SeqID, body)

	// 添加到背包
	newPet := userdb.Pet{
		ID:        bossID,
		CatchTime: int(newCatchTime),
		Level:     catchLevel, // 等级与对战中的敌人等级一致
		DV:        randomDV,
		Nature:    randomNature,
		Exp:       0,
		Name:      "",
	}
	user.Pets = append(user.Pets, newPet)

	logger.Info(fmt.Sprintf("[2409] 捕捉精灵: PetID=%d Level=%d (与敌人等级一致) DV=%d Nature=%d CatchTime=%d",
		bossID, catchLevel, randomDV, randomNature, newCatchTime))

	// 清理战斗状态
	ctx.GameServer.BattleMu.Lock()
	delete(ctx.GameServer.BattleStates, ctx.UserID)
	ctx.GameServer.BattleMu.Unlock()

	// 结束战斗
	overBody := buildFightOverInfo(0, uint32(ctx.UserID))
	ctx.GameServer.SendResponse(ctx.ClientData, 2506, ctx.UserID, ctx.SeqID, overBody)
	pushMapOgreListAfterFightOver(ctx)

	// 保存数据
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
}

// ==================== NONO系统命令处理器 ====================

// registerNonoHandlers 注册NONO系统命令处理器
func registerNonoHandlers(gs *gameserver.GameServer) {
	gs.RegisterCommandHandler(9001, handleNonoOpen)          // 开启NONO
	gs.RegisterCommandHandler(9002, handleNonoChangeName)    // 修改NONO名称
	gs.RegisterCommandHandler(9003, handleNonoInfo)          // NONO信息
	gs.RegisterCommandHandler(9004, handleNonoChipMixture)   // NONO芯片合成
	gs.RegisterCommandHandler(9007, handleNonoCure)          // NONO治疗
	gs.RegisterCommandHandler(9008, handleNonoExpadm)        // NONO经验管理
	gs.RegisterCommandHandler(9010, handleNonoImplementTool) // 使用NONO道具/芯片
	gs.RegisterCommandHandler(9012, handleNonoChangeColor)   // 修改NONO颜色
	gs.RegisterCommandHandler(9013, handleNonoPlay)          // NONO玩耍
	gs.RegisterCommandHandler(9014, handleNonoCloseOpen)     // NONO开关
	gs.RegisterCommandHandler(9015, handleNonoExeList)       // NONO执行列表
	gs.RegisterCommandHandler(9016, handleNonoCharge)        // NONO充电
	gs.RegisterCommandHandler(9017, handleNonoStartExe)      // 开始执行
	gs.RegisterCommandHandler(9018, handleNonoEndExe)        // 结束执行
	gs.RegisterCommandHandler(9019, handleNonoFollowOrHoom)  // 跟随或回家
	gs.RegisterCommandHandler(9020, handleNonoOpenSuper)     // 开启超级NONO
	gs.RegisterCommandHandler(9021, handleNonoHelpExp)       // NONO帮助经验
	gs.RegisterCommandHandler(9022, handleNonoMateChange)    // NONO心情变化
	gs.RegisterCommandHandler(9023, handleNonoGetChip)       // 获取芯片
	gs.RegisterCommandHandler(9024, handleNonoAddEnergyMate) // 增加能量心情
	gs.RegisterCommandHandler(9025, handleGetDiamond)        // 获取钻石
	gs.RegisterCommandHandler(9026, handleNonoAddExp)        // 增加NONO经验
	gs.RegisterCommandHandler(9027, handleNonoIsInfo)        // NONO是否有信息
	gs.RegisterCommandHandler(80001, handleNieoLogin)        // 超能NONO登录
}

// handleNonoOpen CMD 9001 开启NONO
func handleNonoOpen(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	user.Nono.HasNono = 1
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 9001, ctx.UserID, ctx.SeqID, []byte{})
}

// handleNonoChangeName CMD 9002 修改NONO名称
func handleNonoChangeName(ctx *gameserver.HandlerContext) {
	var name string
	if len(ctx.Body) >= 16 {
		name = string(ctx.Body[:16])
		// 移除末尾的null字符
		for i := len(name) - 1; i >= 0 && name[i] == 0; i-- {
			name = name[:i]
		}
	}
	if name == "" {
		name = "NoNo"
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	user.Nono.Nick = name
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	body := make([]byte, 16)
	copy(body, []byte(name))
	ctx.GameServer.SendResponse(ctx.ClientData, 9002, ctx.UserID, ctx.SeqID, body)
}

// handleNonoChipMixture CMD 9004 NONO芯片合成
func handleNonoChipMixture(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, 9004, ctx.UserID, ctx.SeqID, []byte{})
}

// handleNonoCure CMD 9007 NONO治疗
func handleNonoCure(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	// 恢复所有精灵的HP
	// 注意：当前GameData结构中没有存储HP，所以只发送响应
	// 实际的HP恢复应该在战斗状态中处理
	_ = gamepets.GetInstance() // 确保技能管理器已加载
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 9007, ctx.UserID, ctx.SeqID, []byte{})
}

// handleNonoExpadm CMD 9008 NONO经验管理
func handleNonoExpadm(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, 9008, ctx.UserID, ctx.SeqID, []byte{})
}

// handleNonoImplementTool CMD 9010 使用NONO道具/芯片
func handleNonoImplementTool(ctx *gameserver.HandlerContext) {
	var itemID uint32
	if len(ctx.Body) >= 4 {
		itemID = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	// 消耗背包中的道具
	itemKey := strconv.FormatUint(uint64(itemID), 10)
	if item, hasItem := user.Items[itemKey]; hasItem {
		item.Count--
		if item.Count <= 0 {
			delete(user.Items, itemKey)
		} else {
			user.Items[itemKey] = item
		}
	}

	// 如果是芯片（700001-700060），记录功能解锁
	if itemID >= 700001 && itemID <= 700060 {
		// 这里应该更新NONO的func字段，但当前结构中没有，暂时跳过
	}

	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	// 响应: userId(4) + itemId(4) + power(4, *1000) + ai(2) + mate(4, *1000) + iq(4)
	body := make([]byte, 22)
	binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
	binary.BigEndian.PutUint32(body[4:8], itemID)
	binary.BigEndian.PutUint32(body[8:12], uint32(user.Nono.Power*1000))
	binary.BigEndian.PutUint16(body[12:14], uint16(user.Nono.AI))
	binary.BigEndian.PutUint32(body[14:18], uint32(user.Nono.Mate*1000))
	binary.BigEndian.PutUint32(body[18:22], uint32(user.Nono.IQ))
	ctx.GameServer.SendResponse(ctx.ClientData, 9010, ctx.UserID, ctx.SeqID, body)
}

// handleNonoChangeColor CMD 9012 修改NONO颜色
func handleNonoChangeColor(ctx *gameserver.HandlerContext) {
	var color uint32
	if len(ctx.Body) >= 4 {
		color = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	user.Nono.Color = int(color)
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 9012, ctx.UserID, ctx.SeqID, []byte{})
}

// handleNonoPlay CMD 9013 NONO玩耍
func handleNonoPlay(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	// 玩耍增加心情
	if user.Nono.Mate+5000 > 100000 {
		user.Nono.Mate = 100000
	} else {
		user.Nono.Mate += 5000
	}
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	// 响应: result(4) + itemId(4) + power(4) + ai(2) + mate(4) + iq(4)
	body := make([]byte, 22)
	binary.BigEndian.PutUint32(body[0:4], 0)
	binary.BigEndian.PutUint32(body[4:8], 0)
	binary.BigEndian.PutUint32(body[8:12], uint32(user.Nono.Power))
	binary.BigEndian.PutUint16(body[12:14], uint16(user.Nono.AI))
	binary.BigEndian.PutUint32(body[14:18], uint32(user.Nono.Mate))
	binary.BigEndian.PutUint32(body[18:22], uint32(user.Nono.IQ))
	ctx.GameServer.SendResponse(ctx.ClientData, 9013, ctx.UserID, ctx.SeqID, body)
}

// handleNonoCloseOpen CMD 9014 NONO开关
func handleNonoCloseOpen(ctx *gameserver.HandlerContext) {
	var action uint32
	if len(ctx.Body) >= 4 {
		action = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	user.Nono.State = int(action)
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 9014, ctx.UserID, ctx.SeqID, []byte{})
}

// handleNonoExeList CMD 9015 NONO执行列表
func handleNonoExeList(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], 0) // count = 0
	ctx.GameServer.SendResponse(ctx.ClientData, 9015, ctx.UserID, ctx.SeqID, body)
}

// handleNonoCharge CMD 9016 NONO充电
func handleNonoCharge(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.Nono.SuperEnergy+1000 > 99999 {
		user.Nono.SuperEnergy = 99999
	} else {
		user.Nono.SuperEnergy += 1000
	}
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 9016, ctx.UserID, ctx.SeqID, []byte{})
}

// handleNonoStartExe CMD 9017 开始执行
func handleNonoStartExe(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, 9017, ctx.UserID, ctx.SeqID, []byte{})
}

// handleNonoEndExe CMD 9018 结束执行
func handleNonoEndExe(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, 9018, ctx.UserID, ctx.SeqID, []byte{})
}

// handleNonoFollowOrHoom CMD 9019 跟随或回家
func handleNonoFollowOrHoom(ctx *gameserver.HandlerContext) {
	var action uint32
	if len(ctx.Body) >= 4 {
		action = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	var body []byte
	if action == 1 {
		// 跟随: 返回完整NONO信息 (36 bytes)
		body = make([]byte, 36)
		binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
		binary.BigEndian.PutUint32(body[4:8], 0)  // flag=0
		binary.BigEndian.PutUint32(body[8:12], 1) // state=1 跟随状态
		nickBytes := []byte(user.Nono.Nick)
		if len(nickBytes) > 16 {
			nickBytes = nickBytes[:16]
		}
		copy(body[12:28], nickBytes)
		binary.BigEndian.PutUint32(body[28:32], uint32(user.Nono.Color))
		binary.BigEndian.PutUint32(body[32:36], uint32(user.Nono.Power))
	} else {
		// 回家: 只返回12 bytes
		body = make([]byte, 12)
		binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
		binary.BigEndian.PutUint32(body[4:8], 0)  // flag=0
		binary.BigEndian.PutUint32(body[8:12], 0) // state=0 已回家
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 9019, ctx.UserID, ctx.SeqID, body)
}

// handleNonoOpenSuper CMD 9020 开启超级NONO
func handleNonoOpenSuper(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	user.Nono.SuperNono = 1
	if user.Nono.SuperLevel < 1 {
		user.Nono.SuperLevel = 1
	}
	if user.Nono.SuperStage < 1 {
		user.Nono.SuperStage = 1
	}
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 9020, ctx.UserID, ctx.SeqID, []byte{})
}

// handleNonoHelpExp CMD 9021 NONO帮助经验（NoNo 照顾精灵积累的经验，可在发明室经验接收器领取）
func handleNonoHelpExp(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.ExpPool < 0 {
		user.ExpPool = 0
	}
	const addPerCall = 3000
	user.ExpPool += addPerCall
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 9021, ctx.UserID, ctx.SeqID, []byte{})
	logger.Info(fmt.Sprintf("[9021] NONO帮助经验: 经验池 +%d 当前=%d", addPerCall, user.ExpPool))
}

// handleNonoMateChange CMD 9022 NONO心情变化
func handleNonoMateChange(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, 9022, ctx.UserID, ctx.SeqID, []byte{})
}

// handleNonoGetChip CMD 9023 获取芯片
func handleNonoGetChip(ctx *gameserver.HandlerContext) {
	var chipType uint32
	if len(ctx.Body) >= 4 {
		chipType = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	chipID := chipType
	chipItemID := 700000 + chipID

	// 添加到背包
	itemKey := strconv.FormatUint(uint64(chipItemID), 10)
	if item, hasItem := user.Items[itemKey]; hasItem {
		item.Count++
		user.Items[itemKey] = item
	} else {
		user.Items[itemKey] = userdb.Item{
			Count:      1,
			ExpireTime: 0x057E40,
		}
	}

	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	// 响应: 0(4) + 0(4) + 0(4) + count(4) + [id(4) + count(4)]
	body := make([]byte, 20)
	binary.BigEndian.PutUint32(body[0:4], 0)
	binary.BigEndian.PutUint32(body[4:8], 0)
	binary.BigEndian.PutUint32(body[8:12], 0)
	binary.BigEndian.PutUint32(body[12:16], 1) // count
	binary.BigEndian.PutUint32(body[16:20], chipID)
	ctx.GameServer.SendResponse(ctx.ClientData, 9023, ctx.UserID, ctx.SeqID, body)
}

// handleNonoAddEnergyMate CMD 9024 增加能量心情
func handleNonoAddEnergyMate(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.Nono.Power+10000 > 100000 {
		user.Nono.Power = 100000
	} else {
		user.Nono.Power += 10000
	}
	if user.Nono.Mate+10000 > 100000 {
		user.Nono.Mate = 100000
	} else {
		user.Nono.Mate += 10000
	}
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 9024, ctx.UserID, ctx.SeqID, []byte{})
}

// handleGetDiamond CMD 9025 获取钻石
func handleGetDiamond(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], 9999) // 钻石数量
	ctx.GameServer.SendResponse(ctx.ClientData, 9025, ctx.UserID, ctx.SeqID, body)
}

// handleNonoAddExp CMD 9026 增加NONO经验
func handleNonoAddExp(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, 9026, ctx.UserID, ctx.SeqID, []byte{})
}

// handleNonoIsInfo CMD 9027 NONO是否有信息
func handleNonoIsInfo(ctx *gameserver.HandlerContext) {
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], 1) // 有NONO
	ctx.GameServer.SendResponse(ctx.ClientData, 9027, ctx.UserID, ctx.SeqID, body)
}

// handleNieoLogin CMD 80001 超能NONO登录/状态检查
func handleNieoLogin(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	currentTime := uint32(time.Now().Unix())

	// 检查是否需要激活超能NONO
	needActivate := false
	if user.Nono.SuperNono == 0 {
		needActivate = true
	} else if user.Nono.VipEndTime > 0 && user.Nono.VipEndTime < int64(currentTime) {
		needActivate = true
	}

	if needActivate {
		// 激活超能NONO（默认30天）
		durationDays := 30
		endTime := currentTime + uint32(durationDays*24*60*60)
		user.Nono.SuperNono = 1
		user.Nono.VipEndTime = int64(endTime)
		if user.Nono.SuperLevel < 1 {
			user.Nono.SuperLevel = 1
		}
		if user.Nono.SuperStage < 1 {
			user.Nono.SuperStage = 1
		}
		if ctx.GameServer.UserDB != nil {
			ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
		}

		// 发送80002激活成功通知
		message := fmt.Sprintf("成功激活超能NONO！\n到期时间:%s", time.Unix(int64(endTime), 0).Format("2006-01-02"))
		msgBytes := []byte(message)
		notifyBody := make([]byte, 4+len(msgBytes))
		binary.BigEndian.PutUint32(notifyBody[0:4], uint32(len(msgBytes)))
		copy(notifyBody[4:], msgBytes)
		ctx.GameServer.SendResponse(ctx.ClientData, 80002, ctx.UserID, 0, notifyBody)

		// 发送VIP_CO (8006) 更新
		vipBody := make([]byte, 16)
		binary.BigEndian.PutUint32(vipBody[0:4], uint32(ctx.UserID))
		binary.BigEndian.PutUint32(vipBody[4:8], 2) // vipFlag=2 (激活超能NONO)
		binary.BigEndian.PutUint32(vipBody[8:12], uint32(user.Nono.AutoCharge))
		binary.BigEndian.PutUint32(vipBody[12:16], endTime)
		ctx.GameServer.SendResponse(ctx.ClientData, 8006, ctx.UserID, 0, vipBody)
	}

	// 发送80001状态响应
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], 0) // status=0 正常/已激活
	ctx.GameServer.SendResponse(ctx.ClientData, 80001, ctx.UserID, ctx.SeqID, body)
}

// ==================== 物品/背包系统命令处理器 ====================

// registerItemHandlers 注册物品/背包系统命令处理器
func registerItemHandlers(gs *gameserver.GameServer) {
	gs.RegisterCommandHandler(2601, handleItemBuy)               // 购买物品
	gs.RegisterCommandHandler(2602, handleItemSale)              // 出售物品
	gs.RegisterCommandHandler(2604, handleChangeCloth)           // 更换服装
	gs.RegisterCommandHandler(2605, handleItemList)              // 物品列表
	gs.RegisterCommandHandler(2606, handleMultiItemBuy)          // 批量购买
	gs.RegisterCommandHandler(2607, handleItemExpend)            // 消耗物品
	gs.RegisterCommandHandler(2609, handleEquipUpdate)           // 装备升级
	gs.RegisterCommandHandler(2901, handleExchangeClothComplete) // 兑换服装完成
}

// addClothIfNeeded 若 itemID 为服装/套装（100000-199999），则加入 user.Clothes，避免“我的服装”中不显示
func addClothIfNeeded(user *userdb.GameData, itemID int) {
	if itemID < 100000 || itemID > 199999 {
		return
	}
	for _, cid := range user.Clothes {
		if cid == itemID {
			return
		}
	}
	user.Clothes = append(user.Clothes, itemID)
}

// handleItemBuy CMD 2601 购买物品
func handleItemBuy(ctx *gameserver.HandlerContext) {
	var itemID, count uint32
	if len(ctx.Body) >= 8 {
		itemID = binary.BigEndian.Uint32(ctx.Body[0:4])
		count = binary.BigEndian.Uint32(ctx.Body[4:8])
	}
	if count == 0 {
		count = 1
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	itemKey := strconv.FormatUint(uint64(itemID), 10)

	// 检查唯一性（简化：如果已拥有唯一物品，返回错误）
	// 这里应该检查items.xml中的唯一性配置，暂时简化处理

	// 价格检查（简化：默认价格100）
	unitPrice := 100
	totalCost := unitPrice * int(count)

	if user.Coins < totalCost {
		// 返回错误码 103107 (赛尔豆余额不足)
		ctx.GameServer.SendResponse(ctx.ClientData, 2601, ctx.UserID, ctx.SeqID, []byte{})
		return
	}

	// 扣钱
	user.Coins -= totalCost

	// 添加物品
	if item, hasItem := user.Items[itemKey]; hasItem {
		item.Count += int(count)
		user.Items[itemKey] = item
	} else {
		user.Items[itemKey] = userdb.Item{
			Count:      int(count),
			ExpireTime: 0x057E40,
		}
	}
	// 服装/套装（100000-199999）需同时加入 Clothes，否则“我的服装”中不显示
	addClothIfNeeded(user, int(itemID))
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	// 响应: cash(4) + itemID(4) + itemNum(4) + itemLevel(4)
	body := make([]byte, 16)
	binary.BigEndian.PutUint32(body[0:4], uint32(user.Coins))
	binary.BigEndian.PutUint32(body[4:8], itemID)
	binary.BigEndian.PutUint32(body[8:12], count)
	binary.BigEndian.PutUint32(body[12:16], 0)
	ctx.GameServer.SendResponse(ctx.ClientData, 2601, ctx.UserID, ctx.SeqID, body)
}

// handleItemSale CMD 2602 出售物品
func handleItemSale(ctx *gameserver.HandlerContext) {
	var itemID, count uint32
	if len(ctx.Body) >= 8 {
		itemID = binary.BigEndian.Uint32(ctx.Body[0:4])
		count = binary.BigEndian.Uint32(ctx.Body[4:8])
	}
	if count == 0 {
		count = 1
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	itemKey := strconv.FormatUint(uint64(itemID), 10)

	if item, hasItem := user.Items[itemKey]; hasItem {
		item.Count -= int(count)
		if item.Count <= 0 {
			delete(user.Items, itemKey)
		} else {
			user.Items[itemKey] = item
		}
		// 给予金币（简化：默认价格50）
		user.Coins += int(count) * 50
	}

	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	ctx.GameServer.SendResponse(ctx.ClientData, 2602, ctx.UserID, ctx.SeqID, []byte{})
}

// handleChangeCloth CMD 2604 更换服装
func handleChangeCloth(ctx *gameserver.HandlerContext) {
	var clothCount uint32
	if len(ctx.Body) >= 4 {
		clothCount = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	clothIDs := make([]uint32, 0, clothCount)
	for i := uint32(0); i < clothCount && len(ctx.Body) >= int(4+4*(i+1)); i++ {
		clothID := binary.BigEndian.Uint32(ctx.Body[4+i*4 : 8+i*4])
		clothIDs = append(clothIDs, clothID)
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	user.Clothes = make([]int, len(clothIDs))
	for i, id := range clothIDs {
		user.Clothes[i] = int(id)
	}

	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	// 响应: userID(4) + clothCount(4) + [clothId(4) + clothType(4)]...
	body := make([]byte, 8+len(clothIDs)*8)
	binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
	binary.BigEndian.PutUint32(body[4:8], uint32(len(clothIDs)))
	off := 8
	for _, clothID := range clothIDs {
		binary.BigEndian.PutUint32(body[off:off+4], clothID)
		binary.BigEndian.PutUint32(body[off+4:off+8], 0) // clothType
		off += 8
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 2604, ctx.UserID, ctx.SeqID, body)
}

// handleMultiItemBuy CMD 2606 批量购买
func handleMultiItemBuy(ctx *gameserver.HandlerContext) {
	var itemCount uint32
	if len(ctx.Body) >= 4 {
		itemCount = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	itemIDs := make([]uint32, 0, itemCount)
	for i := uint32(0); i < itemCount && len(ctx.Body) >= int(4+4*(i+1)); i++ {
		itemID := binary.BigEndian.Uint32(ctx.Body[4+i*4 : 8+i*4])
		itemIDs = append(itemIDs, itemID)
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	// 计算总价
	totalCost := 0
	validItems := make([]uint32, 0)
	for _, itemID := range itemIDs {
		itemKey := strconv.FormatUint(uint64(itemID), 10)
		// 唯一性检查（简化）
		if _, hasItem := user.Items[itemKey]; !hasItem {
			totalCost += 100 // 默认价格
			validItems = append(validItems, itemID)
		}
	}

	if user.Coins < totalCost {
		// 返回错误码
		body := make([]byte, 8)
		binary.BigEndian.PutUint32(body[0:4], 10016) // 错误码
		binary.BigEndian.PutUint32(body[4:8], uint32(user.Coins))
		ctx.GameServer.SendResponse(ctx.ClientData, 2606, ctx.UserID, ctx.SeqID, body)
		return
	}

	// 扣钱
	user.Coins -= totalCost

	// 添加物品
	for _, itemID := range validItems {
		itemKey := strconv.FormatUint(uint64(itemID), 10)
		if item, hasItem := user.Items[itemKey]; hasItem {
			item.Count++
			user.Items[itemKey] = item
		} else {
			user.Items[itemKey] = userdb.Item{
				Count:      1,
				ExpireTime: 0x057E40,
			}
		}
		// 服装/套装（100000-199999）需同时加入 Clothes
		addClothIfNeeded(user, int(itemID))
	}
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	// 响应: result(4) + remainCoins(4)
	body := make([]byte, 8)
	binary.BigEndian.PutUint32(body[0:4], 0) // result=0 成功
	binary.BigEndian.PutUint32(body[4:8], uint32(user.Coins))
	ctx.GameServer.SendResponse(ctx.ClientData, 2606, ctx.UserID, ctx.SeqID, body)
}

// handleItemExpend CMD 2607 消耗物品
func handleItemExpend(ctx *gameserver.HandlerContext) {
	var itemID, count uint32
	if len(ctx.Body) >= 8 {
		itemID = binary.BigEndian.Uint32(ctx.Body[0:4])
		count = binary.BigEndian.Uint32(ctx.Body[4:8])
	}
	if count == 0 {
		count = 1
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	itemKey := strconv.FormatUint(uint64(itemID), 10)

	if item, hasItem := user.Items[itemKey]; hasItem {
		item.Count -= int(count)
		if item.Count <= 0 {
			delete(user.Items, itemKey)
		} else {
			user.Items[itemKey] = item
		}
	}

	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	ctx.GameServer.SendResponse(ctx.ClientData, 2607, ctx.UserID, ctx.SeqID, []byte{})
}

// handleEquipUpdate CMD 2609 装备升级
func handleEquipUpdate(ctx *gameserver.HandlerContext) {
	ctx.GameServer.SendResponse(ctx.ClientData, 2609, ctx.UserID, ctx.SeqID, []byte{})
}

// handleExchangeClothComplete CMD 2901 兑换服装完成
func handleExchangeClothComplete(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	// 解析 exchangeID(4) + itemId(4)，将兑换得到的服装加入 Clothes
	itemID := 0
	if len(ctx.Body) >= 4 {
		_ = binary.BigEndian.Uint32(ctx.Body[0:4]) // exchangeID
	}
	if len(ctx.Body) >= 8 {
		itemID = int(binary.BigEndian.Uint32(ctx.Body[4:8]))
	}
	if itemID > 0 {
		addClothIfNeeded(user, itemID)
		// 若为服装则也记入 Items 数量（部分客户端按物品显示）
		if itemID >= 100000 && itemID <= 199999 {
			itemKey := strconv.Itoa(itemID)
			if it, has := user.Items[itemKey]; has {
				it.Count++
				user.Items[itemKey] = it
			} else {
				user.Items[itemKey] = userdb.Item{Count: 1, ExpireTime: 0x057E40}
			}
		}
		if ctx.GameServer.UserDB != nil {
			ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
		}
	}
	// 响应: ret(4) + itemId(4) + count(4)
	body := make([]byte, 12)
	binary.BigEndian.PutUint32(body[0:4], 0)
	binary.BigEndian.PutUint32(body[4:8], uint32(itemID))
	binary.BigEndian.PutUint32(body[8:12], 1)
	ctx.GameServer.SendResponse(ctx.ClientData, 2901, ctx.UserID, ctx.SeqID, body)
}

// handleEscapeFight CMD 2410 逃跑（最小可用版本）
// 对齐 Lua: fight_handlers.handleEscapeFight
func handleEscapeFight(ctx *gameserver.HandlerContext) {
	// 响应 2410: result(4) = 1（成功）
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], 1)

	ctx.GameServer.SendResponse(ctx.ClientData, 2410, ctx.UserID, ctx.SeqID, body)

	// 如果当前没有有效战斗状态，就不要再发 2506/刷新地图，避免重复“退出战斗 → 重进地图”的流程
	ctx.GameServer.BattleMu.RLock()
	battle, exists := ctx.GameServer.BattleStates[ctx.UserID]
	active := exists && battle != nil && battle.IsActive
	ctx.GameServer.BattleMu.RUnlock()
	if !active {
		return
	}

	// 结束战斗
	overBody := buildFightOverInfo(0, 0)
	ctx.GameServer.SendResponse(ctx.ClientData, 2506, ctx.UserID, ctx.SeqID, overBody)
	pushMapOgreListAfterFightOver(ctx)

	// 清理战斗状态（如果有的话）
	ctx.GameServer.BattleMu.Lock()
	delete(ctx.GameServer.BattleStates, ctx.UserID)
	ctx.GameServer.BattleMu.Unlock()

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
}

// handlePeopleWalk CMD 2101 人物移动
// 对齐 Lua: map_handlers.handlePeopleWalk
// 请求: walkType(4) + x(4) + y(4) + amfLen(4) + amfData
// 响应: walkType(4) + userID(4) + x(4) + y(4) + amfLen(4) + amfData
func handlePeopleWalk(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	var walkType, x, y, amfLen uint32
	var amfData []byte

	if len(ctx.Body) >= 16 {
		walkType = binary.BigEndian.Uint32(ctx.Body[0:4])
		x = binary.BigEndian.Uint32(ctx.Body[4:8])
		y = binary.BigEndian.Uint32(ctx.Body[8:12])
		amfLen = binary.BigEndian.Uint32(ctx.Body[12:16])

		if len(ctx.Body) >= 16+int(amfLen) {
			amfData = ctx.Body[16 : 16+int(amfLen)]
		}
	}

	// 更新用户位置
	user.PosX = int(x)
	user.PosY = int(y)
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	// 构建响应
	body := make([]byte, 20+len(amfData))
	binary.BigEndian.PutUint32(body[0:4], walkType)
	binary.BigEndian.PutUint32(body[4:8], uint32(ctx.UserID))
	binary.BigEndian.PutUint32(body[8:12], x)
	binary.BigEndian.PutUint32(body[12:16], y)
	binary.BigEndian.PutUint32(body[16:20], amfLen)
	if len(amfData) > 0 {
		copy(body[20:], amfData)
	}

	// 发送响应给请求者，并广播给同地图其他玩家
	ctx.GameServer.SendResponse(ctx.ClientData, 2101, ctx.UserID, ctx.SeqID, body)
	if user.MapID > 0 {
		ctx.GameServer.BroadcastToMap(user.MapID, ctx.UserID, 2101, body)
	}
	logger.Info(fmt.Sprintf("[2101] 人物移动: UID=%d X=%d Y=%d", ctx.UserID, x, y))
}

// handlePetShow CMD 2305 展示精灵（跟随面板）
// 对齐 Lua: pet_handlers.handlePetShow
// 请求: catchTime(4) + flag(4)
// 响应: userID(4) + catchTime(4) + petID(4) + flag(4) + dv(4) + skinID(4)
func handlePetShow(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	var reqCatchTime, reqFlag uint32
	if len(ctx.Body) >= 8 {
		reqCatchTime = binary.BigEndian.Uint32(ctx.Body[0:4])
		reqFlag = binary.BigEndian.Uint32(ctx.Body[4:8])
	}

	// 确定要展示的精灵
	var petID, catchTime, petDV uint32 = 7, 0, 31

	// 如果指定了 catchTime，查找对应的精灵
	if reqCatchTime > 0 {
		catchTime = reqCatchTime
		// 先从背包查找
		for _, pet := range user.Pets {
			if uint32(pet.CatchTime) == reqCatchTime {
				petID = uint32(pet.ID)
				petDV = uint32(pet.DV)
				if petDV == 0 {
					petDV = 31
				}
				break
			}
		}
		// 如果背包没找到，从仓库查找
		if petID == 7 && user.StoragePets != nil {
			for _, pet := range user.StoragePets {
				if uint32(pet.CatchTime) == reqCatchTime {
					petID = uint32(pet.ID)
					petDV = uint32(pet.DV)
					if petDV == 0 {
						petDV = 31
					}
					break
				}
			}
		}
	} else {
		// 使用已保存的跟随精灵，否则第一只
		if user.FollowPetCatchTime > 0 {
			for _, pet := range user.Pets {
				if pet.CatchTime == user.FollowPetCatchTime {
					petID = uint32(pet.ID)
					catchTime = uint32(pet.CatchTime)
					petDV = uint32(pet.DV)
					if petDV == 0 {
						petDV = 31
					}
					break
				}
			}
			if petID == 7 && user.StoragePets != nil {
				for _, pet := range user.StoragePets {
					if pet.CatchTime == user.FollowPetCatchTime {
						petID = uint32(pet.ID)
						catchTime = uint32(pet.CatchTime)
						petDV = uint32(pet.DV)
						if petDV == 0 {
							petDV = 31
						}
						break
					}
				}
			}
		}
		if catchTime == 0 && len(user.Pets) > 0 {
			petID = uint32(user.Pets[0].ID)
			catchTime = uint32(user.Pets[0].CatchTime)
			petDV = uint32(user.Pets[0].DV)
			if petDV == 0 {
				petDV = 31
			}
		}
		if catchTime == 0 {
			catchTime = 0x69686700 + petID
		}
	}

	// 保存当前跟随精灵，供 buildPeopleInfo 与 2003 同步给其他玩家
	if reqCatchTime > 0 {
		if reqFlag == 1 {
			user.FollowPetCatchTime = int(reqCatchTime)
		} else {
			user.FollowPetCatchTime = 0
		}
		if ctx.GameServer.UserDB != nil {
			ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
		}
	}

	// 构建响应
	body := make([]byte, 24)
	binary.BigEndian.PutUint32(body[0:4], uint32(ctx.UserID))
	binary.BigEndian.PutUint32(body[4:8], catchTime)
	binary.BigEndian.PutUint32(body[8:12], petID)
	binary.BigEndian.PutUint32(body[12:16], reqFlag)
	binary.BigEndian.PutUint32(body[16:20], petDV)
	binary.BigEndian.PutUint32(body[20:24], 0) // skinID = 0

	ctx.GameServer.SendResponse(ctx.ClientData, 2305, ctx.UserID, ctx.SeqID, body)
	if user.MapID > 0 {
		ctx.GameServer.BroadcastToMap(user.MapID, ctx.UserID, 2305, body)
	}
	logger.Info(fmt.Sprintf("[2305] 展示精灵: PetID=%d CatchTime=%d DV=%d (广播同地图)", petID, catchTime, petDV))
}

// handlePetGetExp CMD 2319 获取经验池经验
// 对齐 Lua: pet_advanced_handlers.handlePetGetExp
// 响应: expPool(4)
func handlePetGetExp(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	expPool := user.ExpPool
	if expPool < 0 {
		expPool = 0
	}

	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], uint32(expPool))

	ctx.GameServer.SendResponse(ctx.ClientData, 2319, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[2319] 获取经验池经验: ExpPool=%d", expPool))
}

// handleGetMyExperienceComplete CMD 3011 发明室经验接收器 - 教官查看未领取经验（GetExperienceInfo.getExp）
// 响应: getExp(4) 未领取的经验值
func handleGetMyExperienceComplete(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	expPool := user.ExpPool
	if expPool < 0 {
		expPool = 0
	}
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], uint32(expPool))
	ctx.GameServer.SendResponse(ctx.ClientData, 3011, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[3011] 教官查看未领取经验: ExpPool=%d", expPool))
}

// handleMyExperiencePondComplete CMD 3009 发明室经验接收器 - 学员查询教官积累经验值（MyExperiencePondInfo.getMyExp）
// 响应: getMyExp(4) 教官积累的经验值（简化：当前用户经验池；若为 0 则首次赠送测试经验以便能领取）
func handleMyExperiencePondComplete(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	expPool := user.ExpPool
	if expPool < 0 {
		expPool = 0
	}
	// 经验池为 0 时赠送一次可领取经验，避免玩家点经验接收器永远领不到（NoNo 积累 / 任务奖励未触发时）
	const welcomeExp = 5000
	if expPool == 0 {
		user.ExpPool = welcomeExp
		expPool = welcomeExp
		if ctx.GameServer.UserDB != nil {
			ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
		}
		logger.Info(fmt.Sprintf("[3009] 经验池为空，赠送首次可领取经验: %d", welcomeExp))
	}
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], uint32(expPool))
	ctx.GameServer.SendResponse(ctx.ClientData, 3009, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[3009] 查询经验池可领取: ExpPool=%d", expPool))
}

// handleExperienceSharedComplete CMD 3007 发明室经验接收器 - 领取经验并平均分配给背包所有精灵（ExperienceSharedInfo.getFraction）
// 响应: getFraction(4) 本次共分配给精灵的总经验
func handleExperienceSharedComplete(ctx *gameserver.HandlerContext) {
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	totalPool := user.ExpPool
	if totalPool < 0 {
		totalPool = 0
	}
	n := len(user.Pets)
	if n == 0 {
		user.ExpPool = 0
		if ctx.GameServer.UserDB != nil {
			ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
		}
		body := make([]byte, 4)
		binary.BigEndian.PutUint32(body[0:4], 0)
		ctx.GameServer.SendResponse(ctx.ClientData, 3007, ctx.UserID, ctx.SeqID, body)
		logger.Info("[3007] 领取经验但背包无精灵，已清空经验池")
		return
	}
	perPet := totalPool / n
	user.ExpPool = 0
	petMgr := gamepets.GetInstance()
	for idx := range user.Pets {
		if perPet <= 0 {
			continue
		}
		p := &user.Pets[idx]
		p.Exp += perPet
		if p.Level <= 0 {
			p.Level = 1
		}
		if p.Level > 100 {
			p.Level = 100
			p.Exp = 0
			continue
		}
		oldLevel := p.Level
		for {
			expInfo := petMgr.GetExpInfo(p.ID, p.Level, p.Exp)
			if p.Level >= 100 {
				p.Level = 100
				p.Exp = 0
				break
			}
			if p.Exp < expInfo.NextLevelExp {
				break
			}
			p.Exp -= expInfo.NextLevelExp
			p.Level++
		}
		canEvolve, _, evolveTo := petMgr.CanEvolve(p.ID, p.Level, false)
		if canEvolve && evolveTo > 0 {
			p.ID = evolveTo
			p.Exp = 0
		}
		if p.Level > oldLevel {
			var newSkillIDs []int
			seen := make(map[int]bool)
			for lv := oldLevel + 1; lv <= p.Level; lv++ {
				for _, sid := range petMgr.GetSkillsLearnedAtLevel(p.ID, lv) {
					if sid > 0 && !seen[sid] {
						seen[sid] = true
						newSkillIDs = append(newSkillIDs, sid)
					}
				}
			}
			if len(newSkillIDs) > 0 {
				skillBody := buildNoteUpdateSkill(uint32(p.CatchTime), p.ID, oldLevel, newSkillIDs)
				ctx.GameServer.SendResponse(ctx.ClientData, 2507, ctx.UserID, ctx.SeqID, skillBody)
			}
		}
		ev := gamepets.ClampAndCapEV(p.GetEVStats())
		stats := petMgr.GetStats(p.ID, p.Level, p.DV, ev, p.Nature)
		propBody := buildNoteUpdateProp(uint32(p.CatchTime), p.ID, p.Level, p.Exp,
			stats.MaxHP, stats.Attack, stats.Defence, stats.SpAtk, stats.SpDef, stats.Speed, ev)
		ctx.GameServer.SendResponse(ctx.ClientData, 2508, ctx.UserID, ctx.SeqID, propBody)
		fullBody := buildFullPetInfo(*p)
		ctx.GameServer.SendResponse(ctx.ClientData, 2301, ctx.UserID, ctx.SeqID, fullBody)
	}
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	totalGiven := perPet * n
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], uint32(totalGiven))
	ctx.GameServer.SendResponse(ctx.ClientData, 3007, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[3007] 经验接收器领取: 总分配=%d 每只=%d 精灵数=%d", totalGiven, perPet, n))
}

// handleTalkCount CMD 2701 对话计数（矿物挖掘/气体收集今日次数；发明室经验接收器 CateId=2002）
// 请求: cateId(4)，前端 DayOreCount.sendToServer(_type) 发明室经验接收器发 2002
// 响应: MiningCountInfo 仅 miningCount(4)，0=今日未领 1=今日已领
func handleTalkCount(ctx *gameserver.HandlerContext) {
	var cateId uint32
	if len(ctx.Body) >= 4 {
		cateId = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	count := uint32(0)
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	today := int64(time.Now().Unix() / 86400)
	if user.MiningDate == today && user.MiningCount != nil {
		if c, ok := user.MiningCount[int(cateId)]; ok {
			count = uint32(c)
		}
	}

	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], count)
	ctx.GameServer.SendResponse(ctx.ClientData, 2701, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[2701] 对话计数: CateId=%d Count=%d", cateId, count))
}

// 矿物/气体 cateId 对应物品 ID。bMiningStr "1"=黄晶矿(黄金矿)：map10/21/15/325 对应 1/2/3/17 一律发黄晶矿 400001；bMiningStr "2"=甲烷：4/5/6/18 发甲烷 400002
var miningCateToItemID = map[uint32]uint32{
	1: 400001, 2: 400001, 3: 400001, 4: 400002, 5: 400002, 6: 400002, // 1 2 3 17 黄晶矿(黄金矿) 4 5 6 18 甲烷
	7: 400009, 8: 400009, 9: 400009, 10: 400009, 11: 400009, 12: 400009,
	13: 400001, 14: 400009, 15: 400009, 16: 400009, 17: 400001, 18: 400002,
	19: 400001, 20: 400001, 21: 400001, 22: 400001, // 海洋星二层等黄金矿(黄晶矿 400001)，cateId 19-22 发黄金矿
}

// handleTalkCate CMD 2702 对话分类（发放领取物品 / 矿物挖掘、气体收集结果）
// 请求: cateId(4)。响应: DayTalkInfo = cateCount(4) + cateCount×CateInfo(id,count) + outCount(4) + outCount×CateInfo(id,count)
func handleTalkCate(ctx *gameserver.HandlerContext) {
	var cateId uint32
	if len(ctx.Body) >= 4 {
		cateId = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user.Items == nil {
		user.Items = map[string]userdb.Item{}
	}

	var outItemID, outCount uint32

	// 发明室(107) 经验接收器 CateId=2002：每日一次 10 万经验放入 NoNo 经验存储器(ExpPool)，客户端提示“恭喜你获得了 X 积累经验”
	// 船长室 超能 NONO 赛尔豆领取 CateId=2001：每日一次 10 万赛尔豆
	const captainRoomCoinsCateId = 2001
	const captainRoomCoinsPerDay = 100000
	const inventionRoomExpCateId = 2002
	const inventionRoomExpPerDay = 100000
	if cateId == captainRoomCoinsCateId {
		today := int64(time.Now().Unix() / 86400)
		if user.MiningDate != today {
			user.MiningCount = map[int]int{}
			user.MiningDate = today
		}
		if user.MiningCount == nil {
			user.MiningCount = map[int]int{}
		}
		if user.MiningCount[captainRoomCoinsCateId] >= 1 {
			outItemID = 0
			outCount = 0
			logger.Info("[2702] 船长室每日赛尔豆: 今日已领过，不再发放")
		} else {
			user.MiningCount[captainRoomCoinsCateId] = 1
			user.Coins += captainRoomCoinsPerDay
			// 客户端用 outList[0].id/count 显示；id=1 作为“赛尔豆/金币”类型，count 为数值用于提示
			outItemID = 1
			outCount = uint32(captainRoomCoinsPerDay)
			logger.Info(fmt.Sprintf("[2702] 船长室每日赛尔豆: 发放 %d 当前 Coins=%d", captainRoomCoinsPerDay, user.Coins))
		}
	} else if cateId == inventionRoomExpCateId {
		today := int64(time.Now().Unix() / 86400)
		if user.MiningDate != today {
			user.MiningCount = map[int]int{}
			user.MiningDate = today
		}
		if user.MiningCount == nil {
			user.MiningCount = map[int]int{}
		}
		if user.MiningCount[inventionRoomExpCateId] >= 1 {
			outItemID = 0
			outCount = 0
			logger.Info("[2702] 发明室经验接收器: 今日已领过，不再发放")
		} else {
			user.MiningCount[inventionRoomExpCateId] = 1
			if user.ExpPool < 0 {
				user.ExpPool = 0
			}
			user.ExpPool += inventionRoomExpPerDay
			// 客户端用 outList[0].id/count 显示；id=3 表示“积累经验”，count 为数值用于提示
			outItemID = 3
			outCount = uint32(inventionRoomExpPerDay)
			logger.Info(fmt.Sprintf("[2702] 发明室经验接收器: 发放 %d 经验到 NoNo 经验存储器，当前 ExpPool=%d", inventionRoomExpPerDay, user.ExpPool))
		}
	} else if cateId >= 1 && cateId <= 22 {
		today := int64(time.Now().Unix() / 86400)
		if user.MiningDate != today {
			user.MiningCount = map[int]int{}
			user.MiningDate = today
		}
		if user.MiningCount == nil {
			user.MiningCount = map[int]int{}
		}
		user.MiningCount[int(cateId)]++
		itemID := miningCateToItemID[cateId]
		if itemID == 0 {
			itemID = 400001
		}
		// 每次采集数量随机 2-5
		n := uint32(rand.Intn(4) + 2) // [2,5]
		itemKey := strconv.FormatUint(uint64(itemID), 10)
		if it, ok := user.Items[itemKey]; ok {
			it.Count += int(n)
			user.Items[itemKey] = it
		} else {
			user.Items[itemKey] = userdb.Item{Count: int(n), ExpireTime: 0}
		}
		outItemID = itemID
		outCount = n
		logger.Info(fmt.Sprintf("[2702] 矿物/气体: CateId=%d 今日次数+1 发放 itemId=%d x%d", cateId, itemID, n))
	} else if cateId == 2051 {
		// Map 103: 扭蛋牌 x2
		itemID := uint32(400501)
		itemKey := strconv.FormatUint(uint64(itemID), 10)
		if it, ok := user.Items[itemKey]; ok {
			it.Count += 2
			user.Items[itemKey] = it
		} else {
			user.Items[itemKey] = userdb.Item{Count: 2, ExpireTime: 0x057E40}
		}
		outItemID = itemID
		outCount = 2
		logger.Info("[2702] TALK_CATE 发放物品: itemId=400501 x2")
	}

	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	// DayTalkInfo: cateCount(4) + cateCount×CateInfo(8) + outCount(4) + outCount×CateInfo(8)
	// 客户端 outCount=条目数，每条 CateInfo(id,count) 表示一种物品及数量；采集只发 1 条，count 为 2-5
	body := make([]byte, 0, 24)
	body = append(body, 0, 0, 0, 0) // cateCount = 0
	tmp := make([]byte, 4)
	if outCount > 0 {
		binary.BigEndian.PutUint32(tmp, 1) // outCount=1 条 CateInfo，客户端据此显示完成提示
		body = append(body, tmp...)
		binary.BigEndian.PutUint32(tmp, outItemID)
		body = append(body, tmp...)
		binary.BigEndian.PutUint32(tmp, outCount) // 该条数量 2-5
		body = append(body, tmp...)
	} else {
		binary.BigEndian.PutUint32(tmp, 0)
		body = append(body, tmp...)
	}
	ctx.GameServer.SendResponse(ctx.ClientData, 2702, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[2702] 对话分类: CateId=%d", cateId))
}

// handlePetSetExp CMD 2318 从经验池分配经验给精灵
// 对齐 Lua: pet_advanced_handlers.handlePetSetExp
// 请求: catchTime(4) + expAmount(4)
// 响应: newPoolExp(4)
func handlePetSetExp(ctx *gameserver.HandlerContext) {
	var catchTime, expAmount uint32
	if len(ctx.Body) >= 8 {
		catchTime = binary.BigEndian.Uint32(ctx.Body[0:4])
		expAmount = binary.BigEndian.Uint32(ctx.Body[4:8])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	// 经验池扣减
	currentPool := user.ExpPool
	if currentPool < 0 {
		currentPool = 0
	}
	use := int(expAmount)
	if use < 0 {
		use = 0
	}
	if use > currentPool {
		use = currentPool
	}
	user.ExpPool = currentPool - use

	// 给对应精灵加经验并处理升级 & 进化（Pet.Exp 表示“当前等级已获得经验”，不是总经验）
	if catchTime != 0 && use > 0 {
		petMgr := gamepets.GetInstance()
		for idx := range user.Pets {
			if uint32(user.Pets[idx].CatchTime) != catchTime {
				continue
			}

			p := &user.Pets[idx]
			p.Exp += use
			if p.Level <= 0 {
				p.Level = 1
			}
			if p.Level > 100 {
				p.Level = 100
				p.Exp = 0
				break
			}

			oldLevel := p.Level
			// 自动升级：当当前等级经验 >= nextLevelExp 时升级
			for {
				expInfo := petMgr.GetExpInfo(p.ID, p.Level, p.Exp)
				if p.Level >= 100 {
					p.Level = 100
					p.Exp = 0
					break
				}
				if p.Exp < expInfo.NextLevelExp {
					break
				}
				p.Exp -= expInfo.NextLevelExp
				p.Level++
			}

			// 检查是否可以进化（直接进化型）
			canEvolve, _, evolveTo := petMgr.CanEvolve(p.ID, p.Level, false)
			if canEvolve && evolveTo > 0 {
				logger.Info(fmt.Sprintf("[2318] 精灵进化触发: PetID %d -> %d (Level=%d)", p.ID, evolveTo, p.Level))
				p.ID = evolveTo
				// 进化后当前等级经验清零
				p.Exp = 0
			}

			// 若升级了且精灵有新可学技能，发送 NOTE_UPDATE_SKILL(2507)，驱动更换技能窗口
			if p.Level > oldLevel {
				var newSkillIDs []int
				seen := make(map[int]bool)
				for lv := oldLevel + 1; lv <= p.Level; lv++ {
					for _, sid := range petMgr.GetSkillsLearnedAtLevel(p.ID, lv) {
						if sid > 0 && !seen[sid] {
							seen[sid] = true
							newSkillIDs = append(newSkillIDs, sid)
						}
					}
				}
				if len(newSkillIDs) > 0 {
					skillBody := buildNoteUpdateSkill(uint32(p.CatchTime), p.ID, oldLevel, newSkillIDs)
					ctx.GameServer.SendResponse(ctx.ClientData, 2507, ctx.UserID, ctx.SeqID, skillBody)
					logger.Info(fmt.Sprintf("[2318] 升级触发技能学习: PetID=%d Level=%d->%d 新技能=%v", p.ID, oldLevel, p.Level, newSkillIDs))
				}
			}

			// 发送 NOTE_UPDATE_PROP(2508)，驱动升级/属性变化面板
			ev := gamepets.ClampAndCapEV(p.GetEVStats())
			stats := petMgr.GetStats(p.ID, p.Level, p.DV, ev, p.Nature)
			propBody := buildNoteUpdateProp(uint32(p.CatchTime), p.ID, p.Level, p.Exp,
				stats.MaxHP, stats.Attack, stats.Defence, stats.SpAtk, stats.SpDef, stats.Speed, ev)
			ctx.GameServer.SendResponse(ctx.ClientData, 2508, ctx.UserID, ctx.SeqID, propBody)

			// 同步一次完整精灵信息（2301），方便背包面板立即刷新
			fullBody := buildFullPetInfo(*p)
			ctx.GameServer.SendResponse(ctx.ClientData, 2301, ctx.UserID, ctx.SeqID, fullBody)

			break
		}
	}

	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	resp := make([]byte, 4)
	binary.BigEndian.PutUint32(resp[0:4], uint32(user.ExpPool))
	ctx.GameServer.SendResponse(ctx.ClientData, 2318, ctx.UserID, ctx.SeqID, resp)
	logger.Info(fmt.Sprintf("[2318] 分配经验: catchTime=%d use=%d newPool=%d", catchTime, use, user.ExpPool))
}

// handlePetSkillSwitch CMD 2312 精灵技能切换（技能唤醒仪替换技能）
// 请求体常见格式：
//
//	A) catchTime(4) + count(4) + [slotIndex(4), skillId(4)]*count — 只替换指定槽位，一技能只能带一个
//	B) catchTime(4) + [skillId(4)]*4 — 四槽依次填，会去重（同技能只保留第一次出现）
//
// 响应: ret(4)，0 表示成功，1 表示未找到精灵
func handlePetSkillSwitch(ctx *gameserver.HandlerContext) {
	body := ctx.Body
	bodyLen := len(body)
	logger.Info(fmt.Sprintf("[2312] 收到技能切换请求 bodyLen=%d", bodyLen))
	if bodyLen > 0 {
		dump := packet.HexDump(body, fmt.Sprintf("[PACKET] CMD=2312 包体详情"))
		logger.Info(dump)
	}

	var catchTime uint32
	if bodyLen >= 4 {
		catchTime = binary.BigEndian.Uint32(body[0:4])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	var picked *userdb.Pet
	if catchTime != 0 {
		for i := range user.Pets {
			if uint32(user.Pets[i].CatchTime) == catchTime {
				picked = &user.Pets[i]
				break
			}
		}
		if picked == nil && user.StoragePets != nil {
			for i := range user.StoragePets {
				if uint32(user.StoragePets[i].CatchTime) == catchTime {
					picked = &user.StoragePets[i]
					break
				}
			}
		}
	}
	if picked == nil {
		logger.Info(fmt.Sprintf("[2312] 未找到精灵 catchTime=%d pets=%d", catchTime, len(user.Pets)))
		resp := make([]byte, 4)
		binary.BigEndian.PutUint32(resp[0:4], 1)
		ctx.GameServer.SendResponse(ctx.ClientData, 2312, ctx.UserID, ctx.SeqID, resp)
		return
	}

	petMgr := gamepets.GetInstance()
	skillMgr := gameskills.GetInstance()
	currentSkills := make([]int, 4)
	if len(picked.Skills) > 0 {
		for i := 0; i < 4 && i < len(picked.Skills); i++ {
			currentSkills[i] = picked.Skills[i]
		}
	}
	if currentSkills[0] == 0 && currentSkills[1] == 0 && currentSkills[2] == 0 && currentSkills[3] == 0 {
		defaults := petMgr.GetSkillsForLevel(picked.ID, picked.Level)
		for i := 0; i < 4 && i < len(defaults); i++ {
			currentSkills[i] = defaults[i]
		}
	}

	// 格式 A：catchTime(4) + count(4) + [slotIndex(4), skillId(4)]*count，只替换指定槽
	finalSkills := make([]int, 4)
	for i := 0; i < 4; i++ {
		finalSkills[i] = currentSkills[i]
	}
	if bodyLen >= 12 {
		count := binary.BigEndian.Uint32(body[4:8])
		if count >= 1 && count <= 4 && bodyLen >= 8+int(count)*8 {
			type slotPair struct {
				slot int
				sid  int
			}
			var pairs []slotPair
			for i := 0; i < int(count); i++ {
				slotIdx := int(binary.BigEndian.Uint32(body[8+8*i : 8+8*i+4]))
				sid := int(binary.BigEndian.Uint32(body[8+8*i+4 : 8+8*(i+1)]))
				oldSid := sid
				targetSlot := slotIdx
				// 兼容前端 20 字节格式：单槽时 body[16:20] 为右侧选中的新技能 ID，若有效则用其替换（避免前端误传左侧槽技能 ID）
				if count == 1 && bodyLen >= 20 && i == 0 {
					newSkillId := int(binary.BigEndian.Uint32(body[16:20]))
					if newSkillId > 1 && skillMgr.Exists(newSkillId) {
						logger.Info(fmt.Sprintf("[2312] 格式A 收到槽位/技能对(20字节): slotIndex=%d 原skillId=%d 使用newSkillId=%d", slotIdx, sid, newSkillId))
						sid = newSkillId
					} else {
						logger.Info(fmt.Sprintf("[2312] 格式A 收到槽位/技能对: slotIndex=%d skillId=%d", slotIdx, sid))
					}

					// 进一步兼容：20 字节格式里 body[12:16] 常为“被替换的旧技能ID”。
					// 若 slotIndex 与旧技能所在槽不一致，则优先用旧技能ID定位槽位，避免前端 slotIndex 传错导致换错槽。
					if oldSid > 1 {
						found := -1
						for si := 0; si < 4; si++ {
							if currentSkills[si] == oldSid {
								found = si
								break
							}
						}
						if found >= 0 && found != slotIdx {
							logger.Info(fmt.Sprintf("[2312] 20字节槽位纠正: slotIndex=%d oldSkillId=%d 实际槽=%d", slotIdx, oldSid, found))
							targetSlot = found
						}
					}
				} else {
					logger.Info(fmt.Sprintf("[2312] 格式A 收到槽位/技能对: slotIndex=%d skillId=%d", slotIdx, sid))
				}
				// 客户端传 0-based 槽位(0~3)，直接使用
				if targetSlot >= 0 && targetSlot < 4 && sid > 1 && skillMgr.Exists(sid) {
					pairs = append(pairs, slotPair{targetSlot, sid})
				}
			}
			// 格式 A 解析后若无有效槽位对，直接返回成功且不修改技能，避免误入格式 B 破坏数据
			if len(pairs) == 0 {
				resp := make([]byte, 4)
				binary.BigEndian.PutUint32(resp[0:4], 0)
				ctx.GameServer.SendResponse(ctx.ClientData, 2312, ctx.UserID, ctx.SeqID, resp)
				logger.Info(fmt.Sprintf("[2312] 格式A无有效槽位/技能对，保持原技能: catchTime=%d petID=%d skills=%v", catchTime, picked.ID, picked.Skills))
				return
			}
			// 单槽替换且该槽已是该技能时，不做修改（客户端可能误传了左侧槽技能ID而非右侧选中的新技能ID）
			if len(pairs) == 1 && currentSkills[pairs[0].slot] == pairs[0].sid {
				resp := make([]byte, 4)
				binary.BigEndian.PutUint32(resp[0:4], 0)
				ctx.GameServer.SendResponse(ctx.ClientData, 2312, ctx.UserID, ctx.SeqID, resp)
				logger.Info(fmt.Sprintf("[2312] 槽位已是该技能，无变更(请确认客户端发送的是右侧选中的新技能ID): slot=%d skillId=%d", pairs[0].slot, pairs[0].sid))
				return
			}
			usedSid := make(map[int]bool)
			setByUser := make(map[int]bool) // 记录被用户指定替换的槽位，去重时保留这些槽的新技能
			for _, p := range pairs {
				if usedSid[p.sid] {
					continue
				}
				usedSid[p.sid] = true
				setByUser[p.slot] = true
				finalSkills[p.slot] = p.sid
			}
			// 同一技能只能带一个：若新技能与已有槽重复，重复槽放“被替换槽的原技能”（交换），避免技能丢失
			for i := 0; i < 4; i++ {
				sid := finalSkills[i]
				if sid <= 0 {
					continue
				}
				for j := i + 1; j < 4; j++ {
					if finalSkills[j] != sid {
						continue
					}
					if setByUser[i] {
						finalSkills[j] = currentSkills[i]
					} else if setByUser[j] {
						finalSkills[i] = currentSkills[j]
					} else {
						finalSkills[j] = currentSkills[j]
						if finalSkills[j] == sid {
							finalSkills[j] = 0
						}
					}
				}
			}
			picked.Skills = finalSkills
			if ctx.GameServer.UserDB != nil {
				ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
			}
			resp := make([]byte, 4)
			binary.BigEndian.PutUint32(resp[0:4], 0)
			ctx.GameServer.SendResponse(ctx.ClientData, 2312, ctx.UserID, ctx.SeqID, resp)
			logger.Info(fmt.Sprintf("[2312] 精灵技能切换成功(按槽): catchTime=%d petID=%d skills=%v", catchTime, picked.ID, picked.Skills))
			return
		}
	}

	// 格式 B：catchTime(4) + [skillId(4)]*4，四槽依次填，去重（一技能只能带一个）
	skills := make([]int, 0, 4)
	for i := 0; i < 4 && bodyLen >= 4+4*(i+1); i++ {
		sid := int(binary.BigEndian.Uint32(body[4+4*i : 4+4*(i+1)]))
		skills = append(skills, sid)
	}
	logger.Info(fmt.Sprintf("[2312] 解析 catchTime=%d skills=%v", catchTime, skills))

	for i := 0; i < 4; i++ {
		sid := 0
		if i < len(skills) {
			sid = skills[i]
		}
		if sid > 1 && skillMgr.Exists(sid) {
			finalSkills[i] = sid
		} else {
			finalSkills[i] = currentSkills[i]
		}
	}
	// 去重：同一技能只保留第一次出现的槽位，后面重复的槽位恢复为当前技能
	seen := make(map[int]int)
	for i := 0; i < 4; i++ {
		sid := finalSkills[i]
		if sid <= 0 {
			continue
		}
		if _, ok := seen[sid]; ok {
			finalSkills[i] = currentSkills[i]
			if finalSkills[i] == sid {
				finalSkills[i] = 0
			}
		} else {
			seen[sid] = i
		}
	}
	picked.Skills = finalSkills
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}
	resp := make([]byte, 4)
	binary.BigEndian.PutUint32(resp[0:4], 0)
	ctx.GameServer.SendResponse(ctx.ClientData, 2312, ctx.UserID, ctx.SeqID, resp)
	logger.Info(fmt.Sprintf("[2312] 精灵技能切换成功: catchTime=%d petID=%d skills=%v (已去重)", catchTime, picked.ID, picked.Skills))
}

// handleGetPetSkill CMD 2336 获取精灵技能（技能唤醒仪）
// 请求: catchTime(4)
// 响应: count(4) + [skillId(4)]*4，客户端用于 getCanStudySkill 回调
func handleGetPetSkill(ctx *gameserver.HandlerContext) {
	var catchTime uint32
	if len(ctx.Body) >= 4 {
		catchTime = binary.BigEndian.Uint32(ctx.Body[0:4])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)

	var picked *userdb.Pet
	if catchTime != 0 {
		for i := range user.Pets {
			if uint32(user.Pets[i].CatchTime) == catchTime {
				picked = &user.Pets[i]
				break
			}
		}
		if picked == nil && user.StoragePets != nil {
			for i := range user.StoragePets {
				if uint32(user.StoragePets[i].CatchTime) == catchTime {
					picked = &user.StoragePets[i]
					break
				}
			}
		}
	}
	if picked == nil && len(user.Pets) > 0 {
		picked = &user.Pets[0]
	}

	petID := 7
	level := 5
	if picked != nil {
		petID = picked.ID
		if picked.Level > 0 {
			level = picked.Level
		}
	}

	petMgr := gamepets.GetInstance()
	var rawSkills []int
	if picked != nil && len(picked.Skills) > 0 {
		rawSkills = make([]int, 4)
		for i := 0; i < 4 && i < len(picked.Skills); i++ {
			rawSkills[i] = picked.Skills[i]
		}
	} else {
		rawSkills = petMgr.GetSkillsForLevel(petID, level)
	}

	body := make([]byte, 0, 4+16)
	tmp := make([]byte, 4)
	binary.BigEndian.PutUint32(tmp, 4) // count=4 技能槽
	body = append(body, tmp...)
	for i := 0; i < 4; i++ {
		sid := 0
		if i < len(rawSkills) {
			sid = rawSkills[i]
		}
		binary.BigEndian.PutUint32(tmp, uint32(sid))
		body = append(body, tmp...)
	}

	ctx.GameServer.SendResponse(ctx.ClientData, 2336, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[2336] 精灵技能: catchTime=%d petID=%d lv=%d skills=%v", catchTime, petID, level, rawSkills))
}

// handlePetRoomInfo CMD 2325 精灵房间信息（精灵简略信息面板）
// 对齐 Lua: pet_advanced_handlers.handlePetRoomInfo
// 请求: ownerId(4) + catchTime(4)
// 响应结构（与 Lua 一致）：
// ownerId(4) catchTime(4) petId(4) nature(4) level(4)
// hp(4) atk(4) def(4) spAtk(4) spDef(4) speed(4)
// skillCount(4) + [skillId(4) pp(4)]*N
// ev_hp(4) ev_atk(4) ev_def(4) ev_sa(4) ev_sd(4) ev_sp(4)
// effNum(2)
func handlePetRoomInfo(ctx *gameserver.HandlerContext) {
	var ownerID uint32
	var catchTime uint32
	if len(ctx.Body) >= 4 {
		ownerID = binary.BigEndian.Uint32(ctx.Body[0:4])
	}
	if len(ctx.Body) >= 8 {
		catchTime = binary.BigEndian.Uint32(ctx.Body[4:8])
	}
	if ownerID == 0 {
		ownerID = uint32(ctx.UserID)
	}

	// 当前 Go 服只支持查询自己（ownerID!=自己时先兜底返回自己数据，避免前端面板卡死）
	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	source := user

	if catchTime == 0 && len(source.Pets) > 0 {
		catchTime = uint32(source.Pets[0].CatchTime)
	}

	var picked *userdb.Pet
	if catchTime != 0 {
		for i := range source.Pets {
			if uint32(source.Pets[i].CatchTime) == catchTime {
				picked = &source.Pets[i]
				break
			}
		}
		if picked == nil && source.StoragePets != nil {
			for i := range source.StoragePets {
				if uint32(source.StoragePets[i].CatchTime) == catchTime {
					picked = &source.StoragePets[i]
					break
				}
			}
		}
	}
	if picked == nil && len(source.Pets) > 0 {
		picked = &source.Pets[0]
	}

	// 默认值
	petID := 7
	level := 5
	dv := 31
	nature := 0
	if picked != nil {
		petID = picked.ID
		if picked.Level > 0 {
			level = picked.Level
		}
		if picked.DV > 0 {
			dv = picked.DV
		}
		nature = picked.Nature
	}

	petMgr := gamepets.GetInstance()
	// 获取 EV（如果 Pet 存在则使用其 EV，否则为 0）
	ev := gamepets.EVStats{}
	if picked != nil {
		ev = picked.GetEVStats()
	}
	stats := petMgr.GetStats(petID, level, dv, ev, nature)

	// 技能（最多4个），优先使用技能唤醒仪自定义技能；PP 先用 20 兜底
	var rawSkills []int
	if picked != nil && len(picked.Skills) > 0 {
		rawSkills = make([]int, 4)
		for i := 0; i < 4 && i < len(picked.Skills); i++ {
			rawSkills[i] = picked.Skills[i]
		}
	} else {
		rawSkills = petMgr.GetSkillsForLevel(petID, level)
	}
	type skillEntry struct{ id, pp int }
	entries := make([]skillEntry, 0, 4)
	for i := 0; i < len(rawSkills) && len(entries) < 4; i++ {
		if rawSkills[i] > 0 {
			entries = append(entries, skillEntry{id: rawSkills[i], pp: 20})
		}
	}

	// 组包
	body := make([]byte, 0, 128)
	putU32 := func(v uint32) {
		t := make([]byte, 4)
		binary.BigEndian.PutUint32(t, v)
		body = append(body, t...)
	}
	putU16 := func(v uint16) {
		t := make([]byte, 2)
		binary.BigEndian.PutUint16(t, v)
		body = append(body, t...)
	}

	putU32(ownerID)
	putU32(catchTime)
	putU32(uint32(petID))
	putU32(uint32(nature))
	putU32(uint32(level))
	putU32(uint32(stats.HP))
	putU32(uint32(stats.Attack))
	putU32(uint32(stats.Defence))
	putU32(uint32(stats.SpAtk))
	putU32(uint32(stats.SpDef))
	putU32(uint32(stats.Speed))
	putU32(uint32(len(entries)))
	for _, e := range entries {
		putU32(uint32(e.id))
		putU32(uint32(e.pp))
	}
	// EVs（学习力）
	ev = gamepets.ClampAndCapEV(ev)
	putU32(uint32(ev.HP))
	putU32(uint32(ev.Atk))
	putU32(uint32(ev.Def))
	putU32(uint32(ev.SpAtk))
	putU32(uint32(ev.SpDef))
	putU32(uint32(ev.Spd))
	// effNum
	putU16(0)

	ctx.GameServer.SendResponse(ctx.ClientData, 2325, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[2325] 房间精灵信息: owner=%d catch=%d petID=%d lv=%d", ownerID, catchTime, petID, level))
}

// handleUsePetItemOutOfFight CMD 2326 战斗外使用精灵道具
// 由前端 PetPropsPanel / PetPropClass_* 触发：
// 请求：catchTime(4) + itemId(4)
//
// 目前补齐“学习力清零道具”：
// 300037 atk清零, 300038 def清零, 300039 sa清零, 300040 sd清零, 300041 sp清零, 300042 hp清零
// 响应：uint32(0)（客户端不解析，存在即可）
// 并推送：2508 更新属性 + 2301 完整宠物信息（便于立即刷新面板）
func handleUsePetItemOutOfFight(ctx *gameserver.HandlerContext) {
	var catchTime uint32
	var itemID uint32
	if len(ctx.Body) >= 8 {
		catchTime = binary.BigEndian.Uint32(ctx.Body[0:4])
		itemID = binary.BigEndian.Uint32(ctx.Body[4:8])
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user == nil {
		ctx.GameServer.SendResponse(ctx.ClientData, 2326, ctx.UserID, ctx.SeqID, []byte{})
		return
	}

	// 找精灵（队伍优先，其次仓库）
	var picked *userdb.Pet
	if catchTime != 0 {
		for i := range user.Pets {
			if uint32(user.Pets[i].CatchTime) == catchTime {
				picked = &user.Pets[i]
				break
			}
		}
		if picked == nil && user.StoragePets != nil {
			for i := range user.StoragePets {
				if uint32(user.StoragePets[i].CatchTime) == catchTime {
					picked = &user.StoragePets[i]
					break
				}
			}
		}
	}
	if picked == nil && len(user.Pets) > 0 {
		picked = &user.Pets[0]
		catchTime = uint32(picked.CatchTime)
	}
	if picked == nil {
		ctx.GameServer.SendResponse(ctx.ClientData, 2326, ctx.UserID, ctx.SeqID, []byte{})
		return
	}

	// 扣道具（items map key 是字符串）
	if user.Items == nil {
		user.Items = make(map[string]userdb.Item)
	}
	itemKey := strconv.FormatUint(uint64(itemID), 10)
	it, ok := user.Items[itemKey]
	if !ok || it.Count <= 0 {
		// 道具不足：返回空包即可（前端通常只关心是否触发刷新）
		ctx.GameServer.SendResponse(ctx.ClientData, 2326, ctx.UserID, ctx.SeqID, []byte{})
		return
	}
	it.Count--
	if it.Count <= 0 {
		delete(user.Items, itemKey)
	} else {
		user.Items[itemKey] = it
	}

	// 学习力清零
	switch itemID {
	case 300037: // atk -> 0
		picked.EVAttack = 0
	case 300038: // def -> 0
		picked.EVDefence = 0
	case 300039: // sa -> 0
		picked.EVSpAtk = 0
	case 300040: // sd -> 0
		picked.EVSpDef = 0
	case 300041: // sp -> 0
		picked.EVSpeed = 0
	case 300042: // hp -> 0
		picked.EVHP = 0
	default:
		// 其他道具暂不处理（但仍扣道具并成功返回）
	}

	// 统一裁剪一次，避免出现历史脏数据（总510/单项255）
	ev := picked.GetEVStats()
	ev = gamepets.ClampAndCapEV(ev)
	picked.EVHP = ev.HP
	picked.EVAttack = ev.Atk
	picked.EVDefence = ev.Def
	picked.EVSpAtk = ev.SpAtk
	picked.EVSpDef = ev.SpDef
	picked.EVSpeed = ev.Spd

	// 保存
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	// ACK（前端不读内容，但需要回包）
	ctx.GameServer.SendResponse(ctx.ClientData, 2326, ctx.UserID, ctx.SeqID, make([]byte, 4))

	// 推送属性刷新
	petMgr := gamepets.GetInstance()
	petStats := petMgr.GetStats(picked.ID, picked.Level, picked.DV, ev, picked.Nature)
	propBody := buildNoteUpdateProp(uint32(picked.CatchTime), picked.ID, picked.Level, picked.Exp,
		petStats.MaxHP, petStats.Attack, petStats.Defence, petStats.SpAtk, petStats.SpDef, petStats.Speed, ev)
	ctx.GameServer.SendResponse(ctx.ClientData, 2508, ctx.UserID, ctx.SeqID, propBody)
	ctx.GameServer.SendResponse(ctx.ClientData, 2301, ctx.UserID, ctx.SeqID, buildFullPetInfo(*picked))
}

// handleUsePetItemFullAbilityOfStudy CMD 9278 使用“满学习力/注入”道具
// 前端请求：catchTime(4) + statIndex(4) + itemId(4) + flag(4)
// statIndex 约定（与前端一致）：
// 0=HP, 1=ATK, 2=DEF, 3=SA, 4=SD, 5=SP
// flag 通常为 0（固定注入）或 1（弹窗选择注入项）；服务端统一按“把该项 EV 设为 255”处理。
//
// 响应：uint32(0)（客户端不解析）
// 并推送：2508 更新属性 + 2301 完整宠物信息
func handleUsePetItemFullAbilityOfStudy(ctx *gameserver.HandlerContext) {
	var catchTime uint32
	var statIndex uint32
	var itemID uint32
	if len(ctx.Body) >= 16 {
		catchTime = binary.BigEndian.Uint32(ctx.Body[0:4])
		statIndex = binary.BigEndian.Uint32(ctx.Body[4:8])
		itemID = binary.BigEndian.Uint32(ctx.Body[8:12])
		// flag := binary.BigEndian.Uint32(ctx.Body[12:16]) // 目前无需使用
	}

	user := ctx.GameServer.GetOrCreateUser(ctx.UserID)
	if user == nil {
		ctx.GameServer.SendResponse(ctx.ClientData, 9278, ctx.UserID, ctx.SeqID, []byte{})
		return
	}

	// 找精灵（队伍优先，其次仓库）
	var picked *userdb.Pet
	if catchTime != 0 {
		for i := range user.Pets {
			if uint32(user.Pets[i].CatchTime) == catchTime {
				picked = &user.Pets[i]
				break
			}
		}
		if picked == nil && user.StoragePets != nil {
			for i := range user.StoragePets {
				if uint32(user.StoragePets[i].CatchTime) == catchTime {
					picked = &user.StoragePets[i]
					break
				}
			}
		}
	}
	if picked == nil && len(user.Pets) > 0 {
		picked = &user.Pets[0]
		catchTime = uint32(picked.CatchTime)
	}
	if picked == nil {
		ctx.GameServer.SendResponse(ctx.ClientData, 9278, ctx.UserID, ctx.SeqID, []byte{})
		return
	}

	// 扣道具
	if user.Items == nil {
		user.Items = make(map[string]userdb.Item)
	}
	itemKey := strconv.FormatUint(uint64(itemID), 10)
	it, ok := user.Items[itemKey]
	if !ok || it.Count <= 0 {
		ctx.GameServer.SendResponse(ctx.ClientData, 9278, ctx.UserID, ctx.SeqID, []byte{})
		return
	}
	it.Count--
	if it.Count <= 0 {
		delete(user.Items, itemKey)
	} else {
		user.Items[itemKey] = it
	}

	// 设置单项 EV = 255（总和/单项裁剪在后面统一处理）
	switch statIndex {
	case 0:
		picked.EVHP = 255
	case 1:
		picked.EVAttack = 255
	case 2:
		picked.EVDefence = 255
	case 3:
		picked.EVSpAtk = 255
	case 4:
		picked.EVSpDef = 255
	case 5:
		picked.EVSpeed = 255
	default:
		// 非法 statIndex：不改数据，但仍回包（避免客户端卡死）
	}

	// 统一裁剪（总510/单项255）
	ev := picked.GetEVStats()
	ev = gamepets.ClampAndCapEV(ev)
	picked.EVHP = ev.HP
	picked.EVAttack = ev.Atk
	picked.EVDefence = ev.Def
	picked.EVSpAtk = ev.SpAtk
	picked.EVSpDef = ev.SpDef
	picked.EVSpeed = ev.Spd

	// 保存
	if ctx.GameServer.UserDB != nil {
		ctx.GameServer.UserDB.SaveGameData(ctx.UserID, user)
	}

	// ACK
	ctx.GameServer.SendResponse(ctx.ClientData, 9278, ctx.UserID, ctx.SeqID, make([]byte, 4))

	// 推送属性刷新
	petMgr := gamepets.GetInstance()
	petStats := petMgr.GetStats(picked.ID, picked.Level, picked.DV, ev, picked.Nature)
	propBody := buildNoteUpdateProp(uint32(picked.CatchTime), picked.ID, picked.Level, picked.Exp,
		petStats.MaxHP, petStats.Attack, petStats.Defence, petStats.SpAtk, petStats.SpDef, petStats.Speed, ev)
	ctx.GameServer.SendResponse(ctx.ClientData, 2508, ctx.UserID, ctx.SeqID, propBody)
	ctx.GameServer.SendResponse(ctx.ClientData, 2301, ctx.UserID, ctx.SeqID, buildFullPetInfo(*picked))
}

// handleGetSimUserInfo CMD 2051 获取简单用户信息
// 对齐 Lua: map_handlers.handleGetSimUserInfo
// 请求: targetId(4) (可选，默认使用当前用户)
// 响应: targetId(4) + nick(16) + color(4) + texture(4) + vip(4) + status(4) + mapType(4) + mapId(4) +
//
//	isCanBeTeacher(4) + teacherID(4) + studentID(4) + graduationCount(4) + vipLevel(4) +
//	teamId(4) + teamIsShow(4) + clothCount(4) + [clothId(4) + level(4)]...
func handleGetSimUserInfo(ctx *gameserver.HandlerContext) {
	targetID := ctx.UserID
	if len(ctx.Body) >= 4 {
		targetID = int64(binary.BigEndian.Uint32(ctx.Body[0:4]))
	}

	user := ctx.GameServer.GetOrCreateUser(targetID)
	if user == nil {
		user = ctx.GameServer.GetOrCreateUser(ctx.UserID)
		targetID = ctx.UserID
	}

	nick := user.Nick
	if nick == "" {
		nick = fmt.Sprintf("Seer%d", targetID)
	}

	// 构建响应
	body := make([]byte, 0, 128)
	putU32 := func(v uint32) {
		t := make([]byte, 4)
		binary.BigEndian.PutUint32(t, v)
		body = append(body, t...)
	}
	putFixedString := func(s string, n int) {
		b := []byte(s)
		if len(b) > n {
			b = b[:n]
		}
		body = append(body, b...)
		for i := len(b); i < n; i++ {
			body = append(body, 0)
		}
	}

	putU32(uint32(targetID))
	putFixedString(nick, 16)
	putU32(uint32(user.Color))
	// texture（涂鸦/头像）：客户端用此请求 doodle/prev/{id}.swf，0 表示默认
	putU32(uint32(user.Texture))

	// VIP 标志（根据 SuperNono 判断）
	vipFlag := uint32(0)
	if user.Nono.SuperNono > 0 {
		vipFlag = 1
	}
	putU32(vipFlag)
	putU32(0) // status
	putU32(0) // mapType
	mapID := user.MapID
	if mapID <= 0 {
		mapID = 1 // 客户端 mapID=0 可能异常，回 1
	}
	putU32(uint32(mapID))

	// 师徒相关
	isCanBeTeacher := uint32(0) // 简化：默认不可当老师
	putU32(isCanBeTeacher)
	putU32(uint32(user.TeacherID))
	putU32(uint32(user.StudentID))
	putU32(uint32(user.GraduationCount))
	putU32(uint32(user.Nono.VipLevel))

	// 战队相关（当前未实现）
	putU32(0) // teamId
	putU32(0) // teamIsShow

	// 服装列表
	putU32(uint32(len(user.Clothes)))
	for _, clothID := range user.Clothes {
		putU32(uint32(clothID))
		putU32(0) // level
	}

	ctx.GameServer.SendResponse(ctx.ClientData, 2051, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[2051] 获取简单用户信息: targetID=%d", targetID))
}

// handleGetMoreUserInfo CMD 2052 获取详细用户信息
// 对齐 Lua: map_handlers.handleGetMoreUserInfo
// 请求: targetId(4) (可选，默认使用当前用户)
// 响应: targetId(4) + nick(16) + regTime(4) + petAllNum(4) + petMaxLev(4) + bossAchievement(200) +
//
//	graduationCount(4) + monKingWin(4) + messWin(4) + maxStage(4) + maxArenaWins(4) + curTitle(4)
func handleGetMoreUserInfo(ctx *gameserver.HandlerContext) {
	targetID := ctx.UserID
	if len(ctx.Body) >= 4 {
		targetID = int64(binary.BigEndian.Uint32(ctx.Body[0:4]))
	}

	user := ctx.GameServer.GetOrCreateUser(targetID)
	if user == nil {
		user = ctx.GameServer.GetOrCreateUser(ctx.UserID)
		targetID = ctx.UserID
	}

	nick := user.Nick
	if nick == "" {
		nick = fmt.Sprintf("Seer%d", targetID)
	}

	// 获取注册时间（从 UserDB 或使用默认值）
	regTime := uint32(time.Now().Unix() - 86400*365)
	if ctx.GameServer.UserDB != nil {
		account := ctx.GameServer.UserDB.FindByUserID(targetID)
		if account != nil && account.RegisterTime > 0 {
			regTime = uint32(account.RegisterTime)
		}
	}

	// 构建响应
	body := make([]byte, 0, 256)
	putU32 := func(v uint32) {
		t := make([]byte, 4)
		binary.BigEndian.PutUint32(t, v)
		body = append(body, t...)
	}
	putFixedString := func(s string, n int) {
		b := []byte(s)
		if len(b) > n {
			b = b[:n]
		}
		body = append(body, b...)
		for i := len(b); i < n; i++ {
			body = append(body, 0)
		}
	}

	// petAllNum：无则用队伍+仓库精灵数；petMaxLev：无则用 100，对齐 Lua user.petAllNum or 0 / user.petMaxLev or 100
	petAllNum := user.PetAllNum
	if petAllNum <= 0 {
		petAllNum = len(user.Pets) + len(user.StoragePets)
	}
	petMaxLev := user.PetMaxLev
	if petMaxLev <= 0 {
		petMaxLev = 100
	}

	putU32(uint32(targetID))
	putFixedString(nick, 16)
	putU32(regTime)
	putU32(uint32(petAllNum))
	putU32(uint32(petMaxLev))
	body = append(body, sptboss.BuildBossAchievement(user.DefeatedSPTBossIds)...) // bossAchievement 200 字节
	putU32(uint32(user.GraduationCount))
	putU32(uint32(user.MonKingWin))
	putU32(uint32(user.MessWin))
	putU32(uint32(user.MaxStage))
	putU32(uint32(user.MaxArenaWins))
	putU32(uint32(user.CurTitle))

	ctx.GameServer.SendResponse(ctx.ClientData, 2052, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[2052] 获取详细用户信息: targetID=%d", targetID))
}

// handleFitmentUsering CMD 10006 正在使用的家具（基地）
// 对齐 Lua: room_handlers.handleFitmentUsering
// 请求: targetUserId(4) (可选，默认使用当前用户)
// 响应: userID(4) + roomID(4) + count(4) + [id(4) + x(4) + y(4) + dir(4) + status(4)]...
func handleFitmentUsering(ctx *gameserver.HandlerContext) {
	targetUserID := ctx.UserID
	if len(ctx.Body) >= 4 {
		targetUserID = int64(binary.BigEndian.Uint32(ctx.Body[0:4]))
	}

	user := ctx.GameServer.GetOrCreateUser(targetUserID)
	if user == nil {
		user = ctx.GameServer.GetOrCreateUser(ctx.UserID)
		targetUserID = ctx.UserID
	}

	// 获取家具列表
	fitments := user.Fitments
	if fitments == nil {
		fitments = []userdb.Fitment{}
	}

	roomID := targetUserID // 房间ID默认使用用户ID

	// 构建响应
	body := make([]byte, 0, 12+len(fitments)*20)
	putU32 := func(v uint32) {
		t := make([]byte, 4)
		binary.BigEndian.PutUint32(t, v)
		body = append(body, t...)
	}

	putU32(uint32(targetUserID))  // userID (房主)
	putU32(uint32(roomID))        // roomID
	putU32(uint32(len(fitments))) // count

	// 添加家具列表
	for _, fitment := range fitments {
		putU32(uint32(fitment.ID))
		putU32(uint32(fitment.X))
		putU32(uint32(fitment.Y))
		putU32(uint32(fitment.Dir))
		putU32(uint32(fitment.Status))
	}

	ctx.GameServer.SendResponse(ctx.ClientData, 10006, ctx.UserID, ctx.SeqID, body)
	logger.Info(fmt.Sprintf("[10006] 正在使用的家具: owner=%d visitor=%d count=%d", targetUserID, ctx.UserID, len(fitments)))
}
